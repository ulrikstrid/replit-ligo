From d7fa95cca4e0eea39dd13f7343d2b33d5f8cf501 Mon Sep 17 00:00:00 2001
From: Ulrik Strid <ulrik.strid@outlook.com>
Date: Mon, 24 May 2021 11:28:18 +0200
Subject: [PATCH 01/12] Fix dependencies and name

---
 ligo.opam                                                       | 1 +
 src/bin/dune                                                    | 1 +
 .../ligo-utils/memory-proto-alpha/tezos-memory-proto-alpha.opam | 2 +-
 3 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/ligo.opam b/ligo.opam
index e8149e4a2..2c552d33c 100644
--- a/ligo.opam
+++ b/ligo.opam
@@ -27,6 +27,7 @@ depends: [
   "terminal_size"
   "pprint"
   "ParserLib"
+  "preprocessor"
   "LexerLib"
   "UnionFind"
   "RedBlackTrees"
diff --git a/src/bin/dune b/src/bin/dune
index 72b69f146..593d828f1 100644
--- a/src/bin/dune
+++ b/src/bin/dune
@@ -45,6 +45,7 @@
   (public_name ligo)
   (instrumentation (backend bisect_ppx))
   (libraries
+    bls12-381-unix
     simple-utils
     cmdliner
     ligo
diff --git a/vendors/ligo-utils/memory-proto-alpha/tezos-memory-proto-alpha.opam b/vendors/ligo-utils/memory-proto-alpha/tezos-memory-proto-alpha.opam
index 310f6b18a..ff5aa8ba6 100644
--- a/vendors/ligo-utils/memory-proto-alpha/tezos-memory-proto-alpha.opam
+++ b/vendors/ligo-utils/memory-proto-alpha/tezos-memory-proto-alpha.opam
@@ -1,5 +1,5 @@
 opam-version: "2.0"
-name: "memory-proto-alpha"
+name: "tezos-memory-proto-alpha"
 version: "1.0"
 synopsis: "Tezos Protocol Alpha in memory"
 maintainer: "Galfour <contact@ligolang.org>"
-- 
GitLab


From cf4d1bb0c8c3b9e96759dc3be72af321b5eef696 Mon Sep 17 00:00:00 2001
From: Ulrik Strid <ulrik.strid@outlook.com>
Date: Wed, 26 May 2021 16:59:51 +0200
Subject: [PATCH 02/12] Start vendoring things to remove dependencies

---
 src/main/main_errors/formatter.ml             |    6 +-
 .../michelson_v1_error_reporter.ml            |  764 ++++++++
 .../michelson_v1_error_reporter.mli           |   34 +
 src/main/main_errors/michelson_v1_macros.ml   | 1543 +++++++++++++++++
 src/main/main_errors/michelson_v1_macros.mli  |   87 +
 src/main/main_errors/michelson_v1_parser.ml   |  131 ++
 src/main/main_errors/michelson_v1_parser.mli  |   55 +
 src/main/main_errors/michelson_v1_printer.ml  |  270 +++
 src/main/main_errors/michelson_v1_printer.mli |   65 +
 src/main/main_errors/operation_result.ml      |  522 ++++++
 src/main/main_errors/operation_result.mli     |   35 +
 .../ligo_008_PtEdo2Zk_test_helpers/dune       |    6 +-
 .../ligo-008-PtEdo2Zk-test-helpers.opam       |    2 +-
 .../michelson_v1_macros.ml                    | 1542 ++++++++++++++++
 .../michelson_v1_macros.mli                   |   86 +
 .../michelson_v1_parser.ml                    |  129 ++
 .../michelson_v1_parser.mli                   |   55 +
 .../michelson_v1_printer.ml                   |  269 +++
 .../michelson_v1_printer.mli                  |   65 +
 vendors/ligo-utils/proto-alpha-utils/dune     |    5 +-
 .../proto-alpha-utils/michelson_v1_macros.ml  | 1543 +++++++++++++++++
 .../proto-alpha-utils/michelson_v1_macros.mli |   87 +
 .../proto-alpha-utils/michelson_v1_parser.ml  |  131 ++
 .../proto-alpha-utils/michelson_v1_parser.mli |   55 +
 .../proto-alpha-utils/michelson_v1_printer.ml |  270 +++
 .../michelson_v1_printer.mli                  |   65 +
 .../proto-alpha-utils/proto-alpha-utils.opam  |    5 +-
 .../proto-alpha-utils/x_memory_proto_alpha.ml |    4 +-
 .../ligo-utils/tezos-utils/tezos-utils.opam   |    2 +-
 29 files changed, 7820 insertions(+), 13 deletions(-)
 create mode 100644 src/main/main_errors/michelson_v1_error_reporter.ml
 create mode 100644 src/main/main_errors/michelson_v1_error_reporter.mli
 create mode 100644 src/main/main_errors/michelson_v1_macros.ml
 create mode 100644 src/main/main_errors/michelson_v1_macros.mli
 create mode 100644 src/main/main_errors/michelson_v1_parser.ml
 create mode 100644 src/main/main_errors/michelson_v1_parser.mli
 create mode 100644 src/main/main_errors/michelson_v1_printer.ml
 create mode 100644 src/main/main_errors/michelson_v1_printer.mli
 create mode 100644 src/main/main_errors/operation_result.ml
 create mode 100644 src/main/main_errors/operation_result.mli
 create mode 100644 vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_macros.ml
 create mode 100644 vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_macros.mli
 create mode 100644 vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_parser.ml
 create mode 100644 vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_parser.mli
 create mode 100644 vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_printer.ml
 create mode 100644 vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_printer.mli
 create mode 100644 vendors/ligo-utils/proto-alpha-utils/michelson_v1_macros.ml
 create mode 100644 vendors/ligo-utils/proto-alpha-utils/michelson_v1_macros.mli
 create mode 100644 vendors/ligo-utils/proto-alpha-utils/michelson_v1_parser.ml
 create mode 100644 vendors/ligo-utils/proto-alpha-utils/michelson_v1_parser.mli
 create mode 100644 vendors/ligo-utils/proto-alpha-utils/michelson_v1_printer.ml
 create mode 100644 vendors/ligo-utils/proto-alpha-utils/michelson_v1_printer.mli

diff --git a/src/main/main_errors/formatter.ml b/src/main/main_errors/formatter.ml
index 2b33f80f1..6cdd79c6f 100644
--- a/src/main/main_errors/formatter.ml
+++ b/src/main/main_errors/formatter.ml
@@ -83,17 +83,17 @@ let rec error_ppformat : display_format:string display_format ->
     | `Main_unparse_tracer errs ->
       let errs = List.map ~f:( fun e -> match e with `Tezos_alpha_error a -> a) errs in
       Format.fprintf f "@[Error(s) occurred while translating to Michelson:@.%a@]"
-      (Tezos_client_008_PtEdo2Zk.Michelson_v1_error_reporter.report_errors ~details:true ~show_source:true ?parsed:(None)) errs
+      (Michelson_v1_error_reporter.report_errors ~details:true ~show_source:true ?parsed:(None)) errs
 
     | `Main_typecheck_contract_tracer (_c,err_l) ->
       let errs = List.map ~f:( fun e -> match e with `Tezos_alpha_error a -> a) err_l in
       Format.fprintf f "@[<hv>Error(s) occurred while type checking the contract:@.%a@]"
-      (Tezos_client_008_PtEdo2Zk.Michelson_v1_error_reporter.report_errors ~details:true ~show_source:true ?parsed:(None)) errs
+      (Michelson_v1_error_reporter.report_errors ~details:true ~show_source:true ?parsed:(None)) errs
 
     | `Main_could_not_serialize errs ->
       let errs = List.map ~f:( fun e -> match e with `Tezos_alpha_error a -> a) errs in
       Format.fprintf f "@[<hv>Error(s) occurred while serializing Michelson code:@.%a @]"
-      (Tezos_client_008_PtEdo2Zk.Michelson_v1_error_reporter.report_errors ~details:true ~show_source:true ?parsed:(None)) errs
+      (Michelson_v1_error_reporter.report_errors ~details:true ~show_source:true ?parsed:(None)) errs
 
     | `Main_check_typed_arguments (Simple_utils.Runned_result.Check_parameter, err) ->
       Format.fprintf f "@[<hv>Invalid command line argument. @.The provided parameter does not have the correct type for the given entrypoint.@ %a@]"
diff --git a/src/main/main_errors/michelson_v1_error_reporter.ml b/src/main/main_errors/michelson_v1_error_reporter.ml
new file mode 100644
index 000000000..c6d3e99a8
--- /dev/null
+++ b/src/main/main_errors/michelson_v1_error_reporter.ml
@@ -0,0 +1,764 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Tezos_protocol_008_PtEdo2Zk.Protocol
+open Alpha_context
+open Tezos_micheline
+open Script_tc_errors
+open Script_interpreter
+open Michelson_v1_printer
+open Tezos_base__TzPervasives
+
+let rec assoc ~equal k = function
+  | [] ->
+      None
+  | (kk, v) :: kvs ->
+      if equal k kk then Some v else assoc ~equal k kvs
+
+let hd = function x :: _ -> Some x | [] -> None
+
+let print_ty ppf ty = Michelson_v1_printer.print_expr_unwrapped ppf ty
+
+let print_var_annot ppf annot = List.iter (Format.fprintf ppf "@ %s") annot
+
+let print_stack_ty ?(depth = max_int) ppf s =
+  let rec loop depth ppf = function
+    | [] ->
+        ()
+    | _ when depth <= 0 ->
+        Format.fprintf ppf "..."
+    | [(last, annot)] ->
+        Format.fprintf ppf "%a%a" print_ty last print_var_annot annot
+    | (last, annot) :: rest ->
+        Format.fprintf
+          ppf
+          "%a%a@ :@ %a"
+          print_ty
+          last
+          print_var_annot
+          annot
+          (loop (depth - 1))
+          rest
+  in
+  match s with
+  | [] ->
+      Format.fprintf ppf "[]"
+  | sty ->
+      Format.fprintf ppf "@[<hov 2>[ %a ]@]" (loop depth) sty
+
+let rec print_enumeration ppf = function
+  | [single] ->
+      Format.fprintf ppf "%a" Format.pp_print_text single
+  | [prev; last] ->
+      Format.fprintf
+        ppf
+        "%a@ or@ %a"
+        Format.pp_print_text
+        prev
+        Format.pp_print_text
+        last
+  | first :: rest ->
+      Format.fprintf
+        ppf
+        "%a,@ %a"
+        Format.pp_print_text
+        first
+        print_enumeration
+        rest
+  | [] ->
+      assert false
+
+let collect_error_locations errs =
+  let rec collect acc = function
+    | Environment.Ecoproto_error
+        ( Ill_formed_type (_, _, _)
+        | No_such_entrypoint _
+        | Duplicate_entrypoint _
+        | Unreachable_entrypoint _
+        | Runtime_contract_error (_, _)
+        | Michelson_v1_primitives.Invalid_primitive_name (_, _)
+        | Ill_typed_data (_, _, _)
+        | Ill_typed_contract (_, _) )
+      :: _
+    | [] ->
+        acc
+    | Environment.Ecoproto_error
+        ( Invalid_arity (loc, _, _, _)
+        | Invalid_seq_arity (loc, _, _)
+        | Inconsistent_type_annotations (loc, _, _)
+        | Unexpected_annotation loc
+        | Ungrouped_annotations loc
+        | Type_too_large (loc, _, _)
+        | Invalid_namespace (loc, _, _, _)
+        | Invalid_primitive (loc, _, _)
+        | Invalid_kind (loc, _, _)
+        | Invalid_never_expr loc
+        | Duplicate_field (loc, _)
+        | Unexpected_lazy_storage loc
+        | Unexpected_operation loc
+        | Fail_not_in_tail_position loc
+        | Undefined_binop (loc, _, _, _)
+        | Undefined_unop (loc, _, _)
+        | Bad_return (loc, _, _)
+        | Bad_stack (loc, _, _, _)
+        | Unmatched_branches (loc, _, _)
+        | Self_in_lambda loc
+        | Invalid_constant (loc, _, _)
+        | Invalid_syntactic_constant (loc, _, _)
+        | Invalid_contract (loc, _)
+        | Comparable_type_expected (loc, _)
+        | Overflow (loc, _)
+        | Reject (loc, _, _)
+        | Pair_bad_argument loc
+        | Unpair_bad_argument loc
+        | Dup_n_bad_argument loc )
+      :: rest ->
+        collect (loc :: acc) rest
+    | _ :: rest ->
+        collect acc rest
+  in
+  collect [] errs
+
+let report_errors ~details ~show_source ?parsed ppf errs =
+  let rec print_trace locations errs =
+    let print_loc ppf loc =
+      match locations loc with
+      | None ->
+          Format.fprintf ppf "At (unshown) location %d, " loc
+      | Some loc ->
+          Format.fprintf
+            ppf
+            "%s,@ "
+            (String.capitalize_ascii
+               (Format.asprintf "%a" Micheline_parser.print_location loc))
+    in
+    let parsed_locations parsed loc =
+      let ( >?? ) = Option.bind in
+      assoc
+        ~equal:Int.equal
+        loc
+        parsed.Michelson_v1_parser.unexpansion_table
+      >?? fun oloc ->
+      assoc ~equal:Int.equal oloc parsed.expansion_table
+      >?? fun (ploc, _) -> Some ploc
+    in
+    let print_source ppf (parsed, _hilights) (* TODO *) =
+      let lines =
+        String.split_on_char '\n' parsed.Michelson_v1_parser.source
+      in
+      let cols = String.length (string_of_int (List.length lines)) in
+      Format.fprintf
+        ppf
+        "@[<v 0>%a@]"
+        (Format.pp_print_list (fun ppf (i, l) ->
+             Format.fprintf ppf "%0*d: %s" cols i l))
+        (List.mapi (fun i l -> (i + 1, l)) lines)
+    in
+    match errs with
+    | [] ->
+        ()
+    | Environment.Ecoproto_error
+        (Michelson_v1_primitives.Invalid_primitive_name (expr, loc))
+      :: rest ->
+        let parsed =
+          match parsed with
+          | Some parsed ->
+              if
+                Micheline.strip_locations
+                  (Michelson_v1_macros.unexpand_rec (Micheline.root expr))
+                = parsed.Michelson_v1_parser.unexpanded
+              then parsed
+              else Michelson_v1_printer.unparse_invalid expr
+          | None ->
+              Michelson_v1_printer.unparse_invalid expr
+        in
+        let hilights = loc :: collect_error_locations rest in
+        if show_source then
+          Format.fprintf
+            ppf
+            "@[<hov 0>@[<hov 2>Invalid primitive:@ %a@]@]"
+            print_source
+            (parsed, hilights)
+        else Format.fprintf ppf "Invalid primitive." ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace (parsed_locations parsed) rest
+    | Environment.Ecoproto_error (Ill_typed_data (name, expr, ty)) :: rest ->
+        let parsed =
+          match parsed with
+          | Some parsed when expr = parsed.Michelson_v1_parser.expanded ->
+              parsed
+          | Some _ | None ->
+              Michelson_v1_printer.unparse_expression expr
+        in
+        let hilights = collect_error_locations rest in
+        Format.fprintf
+          ppf
+          "@[<hov 0>@[<hov 2>Ill typed %adata:@ %a@]@ @[<hov 2>is not an \
+           expression of type@ %a@]@]"
+          (fun ppf -> function None -> () | Some s ->
+                Format.fprintf ppf "%s " s)
+          name
+          print_source
+          (parsed, hilights)
+          print_ty
+          ty ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace (parsed_locations parsed) rest
+    | Environment.Ecoproto_error (No_such_entrypoint entrypoint) :: rest ->
+        Format.fprintf ppf "Contract has no entrypoint named %s" entrypoint ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+    | Environment.Ecoproto_error (Duplicate_entrypoint entrypoint) :: rest ->
+        Format.fprintf ppf "Contract has two entrypoints named %s" entrypoint ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+    | Environment.Ecoproto_error (Unreachable_entrypoint path) :: rest ->
+        let path =
+          String.concat
+            "/"
+            (List.map Michelson_v1_primitives.string_of_prim path)
+        in
+        Format.fprintf ppf "Entrypoint at path %s is not reachable" path ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+    | Environment.Ecoproto_error (Ill_formed_type (_, expr, loc)) :: rest ->
+        let parsed =
+          match parsed with
+          | Some parsed when expr = parsed.Michelson_v1_parser.expanded ->
+              parsed
+          | Some _ | None ->
+              Michelson_v1_printer.unparse_expression expr
+        in
+        let hilights = loc :: collect_error_locations errs in
+        if show_source then
+          Format.fprintf
+            ppf
+            "@[<v 2>%aill formed type:@ %a@]"
+            print_loc
+            loc
+            print_source
+            (parsed, hilights)
+        else Format.fprintf ppf "Ill formed type." ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace (parsed_locations parsed) rest
+    | Environment.Ecoproto_error (Ill_typed_contract (expr, type_map)) :: rest
+      ->
+        let parsed =
+          match parsed with
+          | Some parsed
+            when (not details) && expr = parsed.Michelson_v1_parser.expanded ->
+              parsed
+          | Some _ | None ->
+              Michelson_v1_printer.unparse_toplevel ~type_map expr
+        in
+        let hilights = collect_error_locations rest in
+        if show_source then
+          Format.fprintf
+            ppf
+            "@[<v 0>Ill typed contract:@,  %a@]"
+            print_source
+            (parsed, hilights)
+        else Format.fprintf ppf "Ill typed contract." ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace (parsed_locations parsed) rest
+    | Environment.Ecoproto_error Apply.Gas_quota_exceeded_init_deserialize
+      :: rest ->
+        Format.fprintf
+          ppf
+          "@[<v 0>Not enough gas to deserialize the operation.@,\
+           Injecting such a transaction could have you banned from mempools.@]" ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+    | Environment.Ecoproto_error Cannot_serialize_error :: rest ->
+        Format.fprintf
+          ppf
+          "Error too big to serialize within the provided gas bounds." ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+    | Environment.Ecoproto_error (Deprecated_instruction prim) :: rest ->
+        Format.fprintf
+          ppf
+          "@[<v 0>Use of deprecated instruction: %s@]"
+          (Michelson_v1_primitives.string_of_prim prim) ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+    | Environment.Ecoproto_error Cannot_serialize_storage :: rest ->
+        Format.fprintf
+          ppf
+          "Cannot serialize the resulting storage value within the provided \
+           gas bounds." ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+    | Environment.Ecoproto_error (Missing_field prim) :: rest ->
+        Format.fprintf
+          ppf
+          "@[<v 0>Missing contract field: %s@]"
+          (Michelson_v1_primitives.string_of_prim prim) ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+    | Environment.Ecoproto_error (Duplicate_field (loc, prim)) :: rest ->
+        Format.fprintf
+          ppf
+          "@[<v 0>%aduplicate contract field: %s@]"
+          print_loc
+          loc
+          (Michelson_v1_primitives.string_of_prim prim) ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+    | Environment.Ecoproto_error (Unexpected_lazy_storage loc) :: rest ->
+        Format.fprintf
+          ppf
+          "%abig_map or sapling_state type not expected here"
+          print_loc
+          loc ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+    | Environment.Ecoproto_error (Unexpected_operation loc) :: rest ->
+        Format.fprintf
+          ppf
+          "%aoperation type forbidden in parameter, storage and constants"
+          print_loc
+          loc ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+    | Environment.Ecoproto_error (Unexpected_contract loc) :: rest ->
+        Format.fprintf
+          ppf
+          "%acontract type forbidden in storage and constants"
+          print_loc
+          loc ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+    | Environment.Ecoproto_error (Runtime_contract_error (contract, expr))
+      :: rest ->
+        let parsed =
+          match parsed with
+          | Some parsed when expr = parsed.Michelson_v1_parser.expanded ->
+              parsed
+          | Some _ | None ->
+              Michelson_v1_printer.unparse_toplevel expr
+        in
+        let hilights = collect_error_locations rest in
+        Format.fprintf
+          ppf
+          "@[<v 2>Runtime error in contract %a:@ %a@]"
+          Contract.pp
+          contract
+          print_source
+          (parsed, hilights) ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace (parsed_locations parsed) rest
+    | Environment.Ecoproto_error (Apply.Internal_operation_replay op) :: rest
+      ->
+        Format.fprintf
+          ppf
+          "@[<v 2>Internal operation replay attempt:@,%a@]"
+          Operation_result.pp_internal_operation
+          op ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+    | Environment.Ecoproto_error Gas.Gas_limit_too_high :: rest ->
+        Format.fprintf
+          ppf
+          "Gas limit for the operation is out of the protocol hard bounds." ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+    | Environment.Ecoproto_error Gas.Block_quota_exceeded :: rest ->
+        Format.fprintf
+          ppf
+          "Gas limit for the block exceeded during typechecking or execution." ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+    | Environment.Ecoproto_error Gas.Operation_quota_exceeded :: rest ->
+        Format.fprintf
+          ppf
+          "@[<v 0>Gas limit exceeded during typechecking or execution.@,\
+           Try again with a higher gas limit.@]" ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+    | Environment.Ecoproto_error Fees.Operation_quota_exceeded :: rest ->
+        Format.fprintf
+          ppf
+          "@[<v 0>Storage limit exceeded during typechecking or execution.@,\
+           Try again with a higher storage limit.@]" ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+    | [Environment.Ecoproto_error (Script_interpreter.Bad_contract_parameter c)]
+      ->
+        Format.fprintf
+          ppf
+          "@[<v 0>Account %a is not a smart contract, it does not take \
+           arguments.@,\
+           The `-arg' flag should not be used when transferring to an \
+           account.@]"
+          Contract.pp
+          c
+    | Environment.Ecoproto_error err :: rest ->
+        ( match err with
+        | Script_interpreter.Bad_contract_parameter c ->
+            Format.fprintf
+              ppf
+              "Invalid argument passed to contract %a."
+              Contract.pp
+              c
+        | Invalid_arity (loc, name, exp, got) ->
+            Format.fprintf
+              ppf
+              "%aprimitive %s expects %d arguments but is given %d."
+              print_loc
+              loc
+              (Michelson_v1_primitives.string_of_prim name)
+              exp
+              got
+        | Invalid_seq_arity (loc, exp, got) ->
+            Format.fprintf
+              ppf
+              "%asequence expects at least %d elements but is given %d."
+              print_loc
+              loc
+              exp
+              got
+        | Invalid_namespace (loc, name, exp, got) ->
+            let human_namespace = function
+              | Michelson_v1_primitives.Instr_namespace ->
+                  ("an", "instruction")
+              | Type_namespace ->
+                  ("a", "type name")
+              | Constant_namespace ->
+                  ("a", "constant constructor")
+              | Keyword_namespace ->
+                  ("a", "keyword")
+            in
+            Format.fprintf
+              ppf
+              "@[%aunexpected %s %s, only %s %s can be used here."
+              print_loc
+              loc
+              (snd (human_namespace got))
+              (Michelson_v1_primitives.string_of_prim name)
+              (fst (human_namespace exp))
+              (snd (human_namespace exp))
+        | Invalid_primitive (loc, exp, got) ->
+            Format.fprintf
+              ppf
+              "@[%ainvalid primitive %s, only %a can be used here."
+              print_loc
+              loc
+              (Michelson_v1_primitives.string_of_prim got)
+              print_enumeration
+              (List.map Michelson_v1_primitives.string_of_prim exp)
+        | Invalid_kind (loc, exp, got) ->
+            let human_kind = function
+              | Seq_kind ->
+                  ("a", "sequence")
+              | Prim_kind ->
+                  ("a", "primitive")
+              | Int_kind ->
+                  ("an", "int")
+              | String_kind ->
+                  ("a", "string")
+              | Bytes_kind ->
+                  ("a", "byte sequence")
+            in
+            Format.fprintf
+              ppf
+              "@[%aunexpected %s, only@ %a@ can be used here."
+              print_loc
+              loc
+              (snd (human_kind got))
+              print_enumeration
+              (List.map
+                 (fun k ->
+                   let (a, n) = human_kind k in
+                   a ^ " " ^ n)
+                 exp)
+        | Invalid_never_expr loc ->
+            Format.fprintf
+              ppf
+              "@[%athis expression should have type never but type never has \
+               no inhabitant."
+              print_loc
+              loc
+        | Duplicate_map_keys (_, expr) ->
+            Format.fprintf
+              ppf
+              "@[<v 2>Map literals cannot contain duplicate keys, however a \
+               duplicate key was found:@ @[%a@]"
+              print_expr
+              expr
+        | Unordered_map_keys (_, expr) ->
+            Format.fprintf
+              ppf
+              "@[<v 2>Keys in a map literal must be in strictly ascending \
+               order, but they were unordered in literal:@ @[%a@]"
+              print_expr
+              expr
+        | Duplicate_set_values (_, expr) ->
+            Format.fprintf
+              ppf
+              "@[<v 2>Set literals cannot contain duplicate values, however a \
+               duplicate value was found:@ @[%a@]"
+              print_expr
+              expr
+        | Unordered_set_values (_, expr) ->
+            Format.fprintf
+              ppf
+              "@[<v 2>Values in a set literal must be in strictly ascending \
+               order, but they were unordered in literal:@ @[%a@]"
+              print_expr
+              expr
+        | Fail_not_in_tail_position loc ->
+            Format.fprintf
+              ppf
+              "%aThe FAIL instruction must appear in a tail position."
+              print_loc
+              loc
+        | Undefined_binop (loc, name, tya, tyb) ->
+            Format.fprintf
+              ppf
+              "@[<hov 0>@[<hov 2>%aoperator %s is undefined between@ %a@]@ \
+               @[<hov 2>and@ %a.@]@]"
+              print_loc
+              loc
+              (Michelson_v1_primitives.string_of_prim name)
+              print_ty
+              tya
+              print_ty
+              tyb
+        | Undefined_unop (loc, name, ty) ->
+            Format.fprintf
+              ppf
+              "@[<hov 0>@[<hov 2>%aoperator %s is undefined on@ %a@]@]"
+              print_loc
+              loc
+              (Michelson_v1_primitives.string_of_prim name)
+              print_ty
+              ty
+        | Bad_return (loc, got, exp) ->
+            Format.fprintf
+              ppf
+              "@[<v 2>%awrong stack type at end of body:@,\
+               - @[<v 0>expected return stack type:@ %a,@]@,\
+               - @[<v 0>actual stack type:@ %a.@]@]"
+              print_loc
+              loc
+              (fun ppf -> print_stack_ty ppf)
+              [(exp, [])]
+              (fun ppf -> print_stack_ty ppf)
+              got
+        | Bad_stack (loc, name, depth, sty) ->
+            Format.fprintf
+              ppf
+              "@[<hov 2>%awrong stack type for instruction %s:@ %a.@]"
+              print_loc
+              loc
+              (Michelson_v1_primitives.string_of_prim name)
+              (print_stack_ty ~depth)
+              sty
+        | Unmatched_branches (loc, sta, stb) ->
+            Format.fprintf
+              ppf
+              "@[<v 2>%atwo branches don't end with the same stack type:@,\
+               - @[<hov>first stack type:@ %a,@]@,\
+               - @[<hov>other stack type:@ %a.@]@]"
+              print_loc
+              loc
+              (fun ppf -> print_stack_ty ppf)
+              sta
+              (fun ppf -> print_stack_ty ppf)
+              stb
+        | Inconsistent_annotations (annot1, annot2) ->
+            Format.fprintf
+              ppf
+              "@[<v 2>The two annotations do not match:@,\
+               - @[<v>%s@]@,\
+               - @[<v>%s@]@]"
+              annot1
+              annot2
+        | Inconsistent_field_annotations (annot1, annot2) ->
+            Format.fprintf
+              ppf
+              "@[<v 2>The field access annotation does not match:@,\
+               - @[<v>%s@]@,\
+               - @[<v>%s@]@]"
+              annot1
+              annot2
+        | Inconsistent_type_annotations (loc, ty1, ty2) ->
+            Format.fprintf
+              ppf
+              "@[<v 2>%athe two types contain incompatible annotations:@,\
+               - @[<hov>%a@]@,\
+               - @[<hov>%a@]@]"
+              print_loc
+              loc
+              print_ty
+              ty1
+              print_ty
+              ty2
+        | Unexpected_annotation loc ->
+            Format.fprintf ppf "@[<v 2>%aunexpected annotation." print_loc loc
+        | Ungrouped_annotations loc ->
+            Format.fprintf
+              ppf
+              "@[<v 2>%aAnnotations of the same kind must be grouped."
+              print_loc
+              loc
+        | Type_too_large (loc, size, maximum_size) ->
+            Format.fprintf
+              ppf
+              "@[<v 2>%atype size (%d) exceeded maximum type size (%d)."
+              print_loc
+              loc
+              size
+              maximum_size
+        | Pair_bad_argument loc ->
+            Format.fprintf
+              ppf
+              "%aPAIR expects an argument of at least 2."
+              print_loc
+              loc
+        | Unpair_bad_argument loc ->
+            Format.fprintf
+              ppf
+              "%aUNPAIR expects an argument of at least 2."
+              print_loc
+              loc
+        | Dup_n_bad_argument loc ->
+            Format.fprintf
+              ppf
+              "%aDUP n expects an argument of at least 1 (passed 0)."
+              print_loc
+              loc
+        | Self_in_lambda loc ->
+            Format.fprintf
+              ppf
+              "%aThe SELF instruction cannot appear in a lambda."
+              print_loc
+              loc
+        | Non_dupable_type (loc, ty) ->
+            Format.fprintf
+              ppf
+              "%aDUP used on the non-dupable type %a."
+              print_loc
+              loc
+              print_ty
+              ty
+        | Unexpected_ticket loc ->
+            Format.fprintf
+              ppf
+              "%aTicket in unauthorized position (type error)."
+              print_loc
+              loc
+        | Bad_stack_length ->
+            Format.fprintf ppf "Bad stack length."
+        | Bad_stack_item lvl ->
+            Format.fprintf ppf "Bad stack item %d." lvl
+        | Unexpected_forged_value loc ->
+            Format.fprintf ppf "%aUnexpected forged value." print_loc loc
+        | Invalid_constant (loc, got, exp) ->
+            Format.fprintf
+              ppf
+              "@[<hov 0>@[<hov 2>%avalue@ %a@]@ @[<hov 2>is invalid for type@ \
+               %a.@]@]"
+              print_loc
+              loc
+              print_expr
+              got
+              print_ty
+              exp
+        | Invalid_syntactic_constant (loc, got, exp) ->
+            Format.fprintf
+              ppf
+              "@[<hov 0>@[<hov 2>%avalue@ %a@]@ @[<hov 2>is invalid, \
+               expected@ %s@]@]"
+              print_loc
+              loc
+              print_expr
+              got
+              exp
+        | Invalid_contract (loc, contract) ->
+            Format.fprintf
+              ppf
+              "%ainvalid contract %a."
+              print_loc
+              loc
+              Contract.pp
+              contract
+        | Comparable_type_expected (loc, ty) ->
+            Format.fprintf ppf "%acomparable type expected." print_loc loc ;
+            Format.fprintf
+              ppf
+              "@[<hov 0>@[<hov 2>Type@ %a@]@ is not comparable.@]"
+              print_ty
+              ty
+        | Inconsistent_types (tya, tyb) ->
+            Format.fprintf
+              ppf
+              "@[<hov 0>@[<hov 2>Type@ %a@]@ @[<hov 2>is not compatible with \
+               type@ %a.@]@]"
+              print_ty
+              tya
+              print_ty
+              tyb
+        | Reject (loc, v, trace) ->
+            Format.fprintf
+              ppf
+              "%ascript reached FAILWITH instruction@ @[<hov 2>with@ %a@]%a"
+              print_loc
+              loc
+              print_expr
+              v
+              (fun ppf -> function None -> () | Some trace ->
+                    Format.fprintf
+                      ppf
+                      "@,@[<v 2>trace@,%a@]"
+                      print_execution_trace
+                      trace)
+              trace
+        | Overflow (loc, trace) ->
+            Format.fprintf
+              ppf
+              "%aunexpected arithmetic overflow%a"
+              print_loc
+              loc
+              (fun ppf -> function None -> () | Some trace ->
+                    Format.fprintf
+                      ppf
+                      "@,@[<v 2>trace@,%a@]"
+                      print_execution_trace
+                      trace)
+              trace
+        | err ->
+            Format.fprintf ppf "%a" Environment.Error_monad.pp err ) ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+    | err :: rest ->
+        Format.fprintf ppf "%a" Error_monad.pp err ;
+        if rest <> [] then Format.fprintf ppf "@," ;
+        print_trace locations rest
+  in
+  Format.fprintf ppf "@[<v 0>" ;
+  print_trace (fun _ -> None) errs ;
+  Format.fprintf ppf "@]"
diff --git a/src/main/main_errors/michelson_v1_error_reporter.mli b/src/main/main_errors/michelson_v1_error_reporter.mli
new file mode 100644
index 000000000..77706ffb0
--- /dev/null
+++ b/src/main/main_errors/michelson_v1_error_reporter.mli
@@ -0,0 +1,34 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Tezos_base__TzPervasives
+
+val report_errors :
+  details:bool ->
+  show_source:bool ->
+  ?parsed:Michelson_v1_parser.parsed ->
+  Format.formatter ->
+  Error_monad.error list ->
+  unit
diff --git a/src/main/main_errors/michelson_v1_macros.ml b/src/main/main_errors/michelson_v1_macros.ml
new file mode 100644
index 000000000..06100482a
--- /dev/null
+++ b/src/main/main_errors/michelson_v1_macros.ml
@@ -0,0 +1,1543 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(* Copyright (c) 2019 Nomadic Labs <contact@nomadic-labs.com>                *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Tezos_micheline
+open Micheline
+open Tezos_base__TzPervasives
+module IntMap = Map.Make (Compare.Int)
+
+type 'l node = ('l, string) Micheline.node
+
+type error += Unexpected_macro_annotation of string
+
+type error += Sequence_expected of string
+
+type error += Invalid_arity of string * int * int
+
+let rec check_letters str i j f =
+  i > j || (f str.[i] && check_letters str (i + 1) j f)
+
+let expand_caddadr original =
+  match original with
+  | Prim (loc, str, args, annot) ->
+      let len = String.length str in
+      if
+        len > 3
+        && str.[0] = 'C'
+        && str.[len - 1] = 'R'
+        && check_letters str 1 (len - 2) (function
+               | 'A' | 'D' ->
+                   true
+               | _ ->
+                   false)
+      then
+        ( match args with
+        | [] ->
+            ok ()
+        | _ :: _ ->
+            error (Invalid_arity (str, List.length args, 0)) )
+        >>? fun () ->
+        let path_annot =
+          List.filter (function "@%" | "@%%" -> true | _ -> false) annot
+        in
+        let rec parse i acc =
+          if i = 0 then Seq (loc, acc)
+          else
+            let annot = if i = len - 2 then annot else path_annot in
+            match str.[i] with
+            | 'A' ->
+                parse (i - 1) (Prim (loc, "CAR", [], annot) :: acc)
+            | 'D' ->
+                parse (i - 1) (Prim (loc, "CDR", [], annot) :: acc)
+            | _ ->
+                assert false
+        in
+        ok (Some (parse (len - 2) []))
+      else ok None
+  | _ ->
+      ok None
+
+let expand_carn original =
+  match original with
+  | Prim (loc, "CAR", [Int (loc2, n)], annot) ->
+      ok
+        (Some
+           (Seq
+              ( loc,
+                [ Prim
+                    ( loc,
+                      "GET",
+                      [Int (loc2, Z.(of_int 1 + (n * of_int 2)))],
+                      annot ) ] )))
+  | _ ->
+      ok None
+
+let expand_cdrn original =
+  match original with
+  | Prim (loc, "CDR", [Int (loc2, n)], annot) ->
+      ok
+        (Some
+           (Seq
+              (loc, [Prim (loc, "GET", [Int (loc2, Z.(n * of_int 2))], annot)])))
+  | _ ->
+      ok None
+
+let extract_field_annots annot =
+  List.partition
+    (fun a ->
+      match a.[0] with
+      | '%' ->
+          true
+      | _ ->
+          false
+      | exception Invalid_argument _ ->
+          false)
+    annot
+
+let expand_set_caddadr original =
+  match original with
+  | Prim (loc, str, args, annot) ->
+      let len = String.length str in
+      if
+        len >= 7
+        && String.sub str 0 5 = "SET_C"
+        && str.[len - 1] = 'R'
+        && check_letters str 5 (len - 2) (function
+               | 'A' | 'D' ->
+                   true
+               | _ ->
+                   false)
+      then
+        ( match args with
+        | [] ->
+            ok ()
+        | _ :: _ ->
+            error (Invalid_arity (str, List.length args, 0)) )
+        >>? fun () ->
+        ( match extract_field_annots annot with
+        | ([], annot) ->
+            ok (None, annot)
+        | ([f], annot) ->
+            ok (Some f, annot)
+        | (_, _) ->
+            error (Unexpected_macro_annotation str) )
+        >>? fun (field_annot, annot) ->
+        let rec parse i acc =
+          if i = 4 then acc
+          else
+            let annot = if i = 5 then annot else [] in
+            match str.[i] with
+            | 'A' ->
+                let acc =
+                  Seq
+                    ( loc,
+                      [ Prim (loc, "DUP", [], []);
+                        Prim
+                          ( loc,
+                            "DIP",
+                            [Seq (loc, [Prim (loc, "CAR", [], ["@%%"]); acc])],
+                            [] );
+                        Prim (loc, "CDR", [], ["@%%"]);
+                        Prim (loc, "SWAP", [], []);
+                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
+                in
+                parse (i - 1) acc
+            | 'D' ->
+                let acc =
+                  Seq
+                    ( loc,
+                      [ Prim (loc, "DUP", [], []);
+                        Prim
+                          ( loc,
+                            "DIP",
+                            [Seq (loc, [Prim (loc, "CDR", [], ["@%%"]); acc])],
+                            [] );
+                        Prim (loc, "CAR", [], ["@%%"]);
+                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
+                in
+                parse (i - 1) acc
+            | _ ->
+                assert false
+        in
+        match str.[len - 2] with
+        | 'A' ->
+            let access_check =
+              match field_annot with
+              | None ->
+                  []
+              | Some f ->
+                  [ Prim (loc, "DUP", [], []);
+                    Prim (loc, "CAR", [], [f]);
+                    Prim (loc, "DROP", [], []) ]
+            in
+            let encoding =
+              [Prim (loc, "CDR", [], ["@%%"]); Prim (loc, "SWAP", [], [])]
+            in
+            let pair =
+              [ Prim
+                  ( loc,
+                    "PAIR",
+                    [],
+                    [Option.value field_annot ~default:"%"; "%@"] ) ]
+            in
+            let init = Seq (loc, access_check @ encoding @ pair) in
+            ok (Some (parse (len - 3) init))
+        | 'D' ->
+            let access_check =
+              match field_annot with
+              | None ->
+                  []
+              | Some f ->
+                  [ Prim (loc, "DUP", [], []);
+                    Prim (loc, "CDR", [], [f]);
+                    Prim (loc, "DROP", [], []) ]
+            in
+            let encoding = [Prim (loc, "CAR", [], ["@%%"])] in
+            let pair =
+              [ Prim
+                  ( loc,
+                    "PAIR",
+                    [],
+                    ["%@"; Option.value field_annot ~default:"%"] ) ]
+            in
+            let init = Seq (loc, access_check @ encoding @ pair) in
+            ok (Some (parse (len - 3) init))
+        | _ ->
+            assert false
+      else ok None
+  | _ ->
+      ok None
+
+let expand_map_caddadr original =
+  match original with
+  | Prim (loc, str, args, annot) ->
+      let len = String.length str in
+      if
+        len >= 7
+        && String.sub str 0 5 = "MAP_C"
+        && str.[len - 1] = 'R'
+        && check_letters str 5 (len - 2) (function
+               | 'A' | 'D' ->
+                   true
+               | _ ->
+                   false)
+      then
+        ( match args with
+        | [(Seq _ as code)] ->
+            ok code
+        | [_] ->
+            error (Sequence_expected str)
+        | [] | _ :: _ :: _ ->
+            error (Invalid_arity (str, List.length args, 1)) )
+        >>? fun code ->
+        ( match extract_field_annots annot with
+        | ([], annot) ->
+            ok (None, annot)
+        | ([f], annot) ->
+            ok (Some f, annot)
+        | (_, _) ->
+            error (Unexpected_macro_annotation str) )
+        >>? fun (field_annot, annot) ->
+        let rec parse i acc =
+          if i = 4 then acc
+          else
+            let annot = if i = 5 then annot else [] in
+            match str.[i] with
+            | 'A' ->
+                let acc =
+                  Seq
+                    ( loc,
+                      [ Prim (loc, "DUP", [], []);
+                        Prim
+                          ( loc,
+                            "DIP",
+                            [Seq (loc, [Prim (loc, "CAR", [], ["@%%"]); acc])],
+                            [] );
+                        Prim (loc, "CDR", [], ["@%%"]);
+                        Prim (loc, "SWAP", [], []);
+                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
+                in
+                parse (i - 1) acc
+            | 'D' ->
+                let acc =
+                  Seq
+                    ( loc,
+                      [ Prim (loc, "DUP", [], []);
+                        Prim
+                          ( loc,
+                            "DIP",
+                            [Seq (loc, [Prim (loc, "CDR", [], ["@%%"]); acc])],
+                            [] );
+                        Prim (loc, "CAR", [], ["@%%"]);
+                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
+                in
+                parse (i - 1) acc
+            | _ ->
+                assert false
+        in
+        let cr_annot =
+          match field_annot with
+          | None ->
+              []
+          | Some f ->
+              ["@" ^ String.sub f 1 (String.length f - 1)]
+        in
+        match str.[len - 2] with
+        | 'A' ->
+            let init =
+              Seq
+                ( loc,
+                  [ Prim (loc, "DUP", [], []);
+                    Prim (loc, "CDR", [], ["@%%"]);
+                    Prim
+                      ( loc,
+                        "DIP",
+                        [Seq (loc, [Prim (loc, "CAR", [], cr_annot); code])],
+                        [] );
+                    Prim (loc, "SWAP", [], []);
+                    Prim
+                      ( loc,
+                        "PAIR",
+                        [],
+                        [Option.value field_annot ~default:"%"; "%@"] ) ] )
+            in
+            ok (Some (parse (len - 3) init))
+        | 'D' ->
+            let init =
+              Seq
+                ( loc,
+                  [ Prim (loc, "DUP", [], []);
+                    Prim (loc, "CDR", [], cr_annot);
+                    code;
+                    Prim (loc, "SWAP", [], []);
+                    Prim (loc, "CAR", [], ["@%%"]);
+                    Prim
+                      ( loc,
+                        "PAIR",
+                        [],
+                        ["%@"; Option.value field_annot ~default:"%"] ) ] )
+            in
+            ok (Some (parse (len - 3) init))
+        | _ ->
+            assert false
+      else ok None
+  | _ ->
+      ok None
+
+exception Not_a_roman
+
+let decimal_of_roman roman =
+  (* http://rosettacode.org/wiki/Roman_numerals/Decode#OCaml *)
+  let arabic = ref 0 in
+  let lastval = ref 0 in
+  for i = String.length roman - 1 downto 0 do
+    let n =
+      match roman.[i] with
+      | 'M' ->
+          1000
+      | 'D' ->
+          500
+      | 'C' ->
+          100
+      | 'L' ->
+          50
+      | 'X' ->
+          10
+      | 'V' ->
+          5
+      | 'I' ->
+          1
+      | _ ->
+          raise_notrace Not_a_roman
+    in
+    if Compare.Int.(n < !lastval) then arabic := !arabic - n
+    else arabic := !arabic + n ;
+    lastval := n
+  done ;
+  !arabic
+
+let dip ~loc ?(annot = []) depth instr =
+  assert (depth >= 0) ;
+  if depth = 1 then Prim (loc, "DIP", [instr], annot)
+  else Prim (loc, "DIP", [Int (loc, Z.of_int depth); instr], annot)
+
+let expand_deprecated_dxiiivp original =
+  (* transparently expands deprecated macro [DI...IP] to instruction [DIP n] *)
+  match original with
+  | Prim (loc, str, args, annot) ->
+      let len = String.length str in
+      if len > 3 && str.[0] = 'D' && str.[len - 1] = 'P' then
+        try
+          let depth = decimal_of_roman (String.sub str 1 (len - 2)) in
+          match args with
+          | [(Seq (_, _) as arg)] ->
+              ok @@ Some (dip ~loc ~annot depth arg)
+          | [_] ->
+              error (Sequence_expected str)
+          | [] | _ :: _ :: _ ->
+              error (Invalid_arity (str, List.length args, 1))
+        with Not_a_roman -> ok None
+      else ok None
+  | _ ->
+      ok None
+
+exception Not_a_pair
+
+type pair_item = A | I | P of int * pair_item * pair_item
+
+let parse_pair_substr str ~len start =
+  let rec parse ?left i =
+    if i = len - 1 then raise_notrace Not_a_pair
+    else if str.[i] = 'P' then
+      let (next_i, l) = parse ~left:true (i + 1) in
+      let (next_i, r) = parse ~left:false next_i in
+      (next_i, P (i, l, r))
+    else if str.[i] = 'A' && left = Some true then (i + 1, A)
+    else if str.[i] = 'I' && left <> Some true then (i + 1, I)
+    else raise_notrace Not_a_pair
+  in
+  let (last, ast) = parse start in
+  if last <> len - 1 then raise_notrace Not_a_pair else ast
+
+let unparse_pair_item ast =
+  let rec unparse ast acc =
+    match ast with
+    | P (_, l, r) ->
+        unparse r (unparse l ("P" :: acc))
+    | A ->
+        "A" :: acc
+    | I ->
+        "I" :: acc
+  in
+  List.rev ("R" :: unparse ast []) |> String.concat ""
+
+let pappaiir_annots_pos ast annot =
+  let rec find_annots_pos p_pos ast annots acc =
+    match (ast, annots) with
+    | (_, []) ->
+        (annots, acc)
+    | (P (i, left, right), _) ->
+        let (annots, acc) = find_annots_pos i left annots acc in
+        find_annots_pos i right annots acc
+    | (A, a :: annots) ->
+        let pos =
+          match IntMap.find p_pos acc with
+          | None ->
+              ([a], [])
+          | Some (_, cdr) ->
+              ([a], cdr)
+        in
+        (annots, IntMap.add p_pos pos acc)
+    | (I, a :: annots) ->
+        let pos =
+          match IntMap.find p_pos acc with
+          | None ->
+              ([], [a])
+          | Some (car, _) ->
+              (car, [a])
+        in
+        (annots, IntMap.add p_pos pos acc)
+  in
+  snd (find_annots_pos 0 ast annot IntMap.empty)
+
+let expand_pappaiir original =
+  match original with
+  | Prim (loc, str, args, annot) ->
+      let len = String.length str in
+      if
+        len > 4
+        && str.[0] = 'P'
+        && str.[len - 1] = 'R'
+        && check_letters str 1 (len - 2) (function
+               | 'P' | 'A' | 'I' ->
+                   true
+               | _ ->
+                   false)
+      then
+        try
+          let (field_annots, annot) = extract_field_annots annot in
+          let ast = parse_pair_substr str ~len 0 in
+          let field_annots_pos = pappaiir_annots_pos ast field_annots in
+          let rec parse p (depth, acc) =
+            match p with
+            | P (i, left, right) ->
+                let annot =
+                  match (i, IntMap.find i field_annots_pos) with
+                  | (0, None) ->
+                      annot
+                  | (_, None) ->
+                      []
+                  | (0, Some ([], cdr_annot)) ->
+                      ("%" :: cdr_annot) @ annot
+                  | (_, Some ([], cdr_annot)) ->
+                      "%" :: cdr_annot
+                  | (0, Some (car_annot, cdr_annot)) ->
+                      car_annot @ cdr_annot @ annot
+                  | (_, Some (car_annot, cdr_annot)) ->
+                      car_annot @ cdr_annot
+                in
+                let acc =
+                  if depth = 0 then Prim (loc, "PAIR", [], annot) :: acc
+                  else
+                    dip ~loc depth (Seq (loc, [Prim (loc, "PAIR", [], annot)]))
+                    :: acc
+                in
+                (depth, acc) |> parse left |> parse right
+            | A | I ->
+                (depth + 1, acc)
+          in
+          let (_, expanded) = parse ast (0, []) in
+          ( match args with
+          | [] ->
+              ok ()
+          | _ :: _ ->
+              error (Invalid_arity (str, List.length args, 0)) )
+          >>? fun () -> ok (Some (Seq (loc, expanded)))
+        with Not_a_pair -> ok None
+      else ok None
+  | _ ->
+      ok None
+
+let expand_unpappaiir original =
+  match original with
+  | Prim (loc, str, args, _annot) ->
+      let len = String.length str in
+      if
+        len > 6
+        && String.sub str 0 3 = "UNP"
+        && str.[len - 1] = 'R'
+        && check_letters str 3 (len - 2) (function
+               | 'P' | 'A' | 'I' ->
+                   true
+               | _ ->
+                   false)
+      then
+        try
+          let unpair = Prim (loc, "UNPAIR", [], []) in
+          let ast = parse_pair_substr str ~len 2 in
+          let rec parse p (depth, acc) =
+            match p with
+            | P (_i, left, right) ->
+                let acc =
+                  if depth = 0 then unpair :: acc
+                  else dip ~loc depth (Seq (loc, [unpair])) :: acc
+                in
+                (depth, acc) |> parse left |> parse right
+            | A | I ->
+                (depth + 1, acc)
+          in
+          let (_, rev_expanded) = parse ast (0, []) in
+          let expanded = Seq (loc, List.rev rev_expanded) in
+          ( match args with
+          | [] ->
+              ok ()
+          | _ :: _ ->
+              error (Invalid_arity (str, List.length args, 0)) )
+          >>? fun () -> ok (Some expanded)
+        with Not_a_pair -> ok None
+      else ok None
+  | _ ->
+      ok None
+
+exception Not_a_dup
+
+let expand_deprecated_duuuuup original =
+  (* transparently expands deprecated macro [DU...UP] to [{ DUP n }] *)
+  match original with
+  | Prim (loc, str, args, annot) ->
+      let len = String.length str in
+      if
+        len > 3
+        && str.[0] = 'D'
+        && str.[len - 1] = 'P'
+        && check_letters str 1 (len - 2) (( = ) 'U')
+      then
+        ( match args with
+        | [] ->
+            ok ()
+        | _ :: _ ->
+            error (Invalid_arity (str, List.length args, 0)) )
+        >>? fun () ->
+        try
+          let rec parse i =
+            if i = 1 then
+              Prim (loc, "DUP", [Int (loc, Z.of_int (len - 2))], annot)
+            else if str.[i] = 'U' then parse (i - 1)
+            else raise_notrace Not_a_dup
+          in
+          ok (Some (parse (len - 2)))
+        with Not_a_dup -> ok None
+      else ok None
+  | _ ->
+      ok None
+
+let expand_compare original =
+  let cmp loc is annot =
+    let is =
+      match List.rev_map (fun i -> Prim (loc, i, [], [])) is with
+      | Prim (loc, i, args, _) :: r ->
+          List.rev (Prim (loc, i, args, annot) :: r)
+      | is ->
+          List.rev is
+    in
+    ok (Some (Seq (loc, is)))
+  in
+  let ifcmp loc is l r annot =
+    let is =
+      List.map (fun i -> Prim (loc, i, [], [])) is
+      @ [Prim (loc, "IF", [l; r], annot)]
+    in
+    ok (Some (Seq (loc, is)))
+  in
+  match original with
+  | Prim (loc, "CMPEQ", [], annot) ->
+      cmp loc ["COMPARE"; "EQ"] annot
+  | Prim (loc, "CMPNEQ", [], annot) ->
+      cmp loc ["COMPARE"; "NEQ"] annot
+  | Prim (loc, "CMPLT", [], annot) ->
+      cmp loc ["COMPARE"; "LT"] annot
+  | Prim (loc, "CMPGT", [], annot) ->
+      cmp loc ["COMPARE"; "GT"] annot
+  | Prim (loc, "CMPLE", [], annot) ->
+      cmp loc ["COMPARE"; "LE"] annot
+  | Prim (loc, "CMPGE", [], annot) ->
+      cmp loc ["COMPARE"; "GE"] annot
+  | Prim
+      ( _,
+        (("CMPEQ" | "CMPNEQ" | "CMPLT" | "CMPGT" | "CMPLE" | "CMPGE") as str),
+        args,
+        [] ) ->
+      error (Invalid_arity (str, List.length args, 0))
+  | Prim (loc, "IFCMPEQ", [l; r], annot) ->
+      ifcmp loc ["COMPARE"; "EQ"] l r annot
+  | Prim (loc, "IFCMPNEQ", [l; r], annot) ->
+      ifcmp loc ["COMPARE"; "NEQ"] l r annot
+  | Prim (loc, "IFCMPLT", [l; r], annot) ->
+      ifcmp loc ["COMPARE"; "LT"] l r annot
+  | Prim (loc, "IFCMPGT", [l; r], annot) ->
+      ifcmp loc ["COMPARE"; "GT"] l r annot
+  | Prim (loc, "IFCMPLE", [l; r], annot) ->
+      ifcmp loc ["COMPARE"; "LE"] l r annot
+  | Prim (loc, "IFCMPGE", [l; r], annot) ->
+      ifcmp loc ["COMPARE"; "GE"] l r annot
+  | Prim (loc, "IFEQ", [l; r], annot) ->
+      ifcmp loc ["EQ"] l r annot
+  | Prim (loc, "IFNEQ", [l; r], annot) ->
+      ifcmp loc ["NEQ"] l r annot
+  | Prim (loc, "IFLT", [l; r], annot) ->
+      ifcmp loc ["LT"] l r annot
+  | Prim (loc, "IFGT", [l; r], annot) ->
+      ifcmp loc ["GT"] l r annot
+  | Prim (loc, "IFLE", [l; r], annot) ->
+      ifcmp loc ["LE"] l r annot
+  | Prim (loc, "IFGE", [l; r], annot) ->
+      ifcmp loc ["GE"] l r annot
+  | Prim
+      ( _,
+        ( ( "IFCMPEQ"
+          | "IFCMPNEQ"
+          | "IFCMPLT"
+          | "IFCMPGT"
+          | "IFCMPLE"
+          | "IFCMPGE"
+          | "IFEQ"
+          | "IFNEQ"
+          | "IFLT"
+          | "IFGT"
+          | "IFLE"
+          | "IFGE" ) as str ),
+        args,
+        [] ) ->
+      error (Invalid_arity (str, List.length args, 2))
+  | Prim
+      ( _,
+        ( ( "IFCMPEQ"
+          | "IFCMPNEQ"
+          | "IFCMPLT"
+          | "IFCMPGT"
+          | "IFCMPLE"
+          | "IFCMPGE"
+          | "IFEQ"
+          | "IFNEQ"
+          | "IFLT"
+          | "IFGT"
+          | "IFLE"
+          | "IFGE" ) as str ),
+        [],
+        _ :: _ ) ->
+      error (Unexpected_macro_annotation str)
+  | _ ->
+      ok None
+
+let expand_asserts original =
+  let may_rename loc = function
+    | [] ->
+        Seq (loc, [])
+    | annot ->
+        Seq (loc, [Prim (loc, "RENAME", [], annot)])
+  in
+  let fail_false ?(annot = []) loc =
+    [may_rename loc annot; Seq (loc, [Prim (loc, "FAIL", [], [])])]
+  in
+  let fail_true ?(annot = []) loc =
+    [Seq (loc, [Prim (loc, "FAIL", [], [])]); may_rename loc annot]
+  in
+  match original with
+  | Prim (loc, "ASSERT", [], []) ->
+      ok @@ Some (Seq (loc, [Prim (loc, "IF", fail_false loc, [])]))
+  | Prim (loc, "ASSERT_NONE", [], []) ->
+      ok @@ Some (Seq (loc, [Prim (loc, "IF_NONE", fail_false loc, [])]))
+  | Prim (loc, "ASSERT_SOME", [], annot) ->
+      ok @@ Some (Seq (loc, [Prim (loc, "IF_NONE", fail_true ~annot loc, [])]))
+  | Prim (loc, "ASSERT_LEFT", [], annot) ->
+      ok
+      @@ Some (Seq (loc, [Prim (loc, "IF_LEFT", fail_false ~annot loc, [])]))
+  | Prim (loc, "ASSERT_RIGHT", [], annot) ->
+      ok @@ Some (Seq (loc, [Prim (loc, "IF_LEFT", fail_true ~annot loc, [])]))
+  | Prim
+      ( _,
+        ( ( "ASSERT"
+          | "ASSERT_NONE"
+          | "ASSERT_SOME"
+          | "ASSERT_LEFT"
+          | "ASSERT_RIGHT" ) as str ),
+        args,
+        [] ) ->
+      error (Invalid_arity (str, List.length args, 0))
+  | Prim (_, (("ASSERT" | "ASSERT_NONE") as str), [], _ :: _) ->
+      error (Unexpected_macro_annotation str)
+  | Prim (loc, s, args, annot)
+    when String.(length s > 7 && equal (sub s 0 7) "ASSERT_") -> (
+      ( match args with
+      | [] ->
+          ok ()
+      | _ :: _ ->
+          error (Invalid_arity (s, List.length args, 0)) )
+      >>? fun () ->
+      ( match annot with
+      | _ :: _ ->
+          error (Unexpected_macro_annotation s)
+      | [] ->
+          ok () )
+      >>? fun () ->
+      let remaining = String.(sub s 7 (length s - 7)) in
+      let remaining_prim = Prim (loc, remaining, [], []) in
+      match remaining with
+      | "EQ" | "NEQ" | "LT" | "LE" | "GE" | "GT" ->
+          ok
+          @@ Some
+               (Seq
+                  (loc, [remaining_prim; Prim (loc, "IF", fail_false loc, [])]))
+      | _ -> (
+          expand_compare remaining_prim
+          >|? function
+          | None ->
+              None
+          | Some seq ->
+              Some (Seq (loc, [seq; Prim (loc, "IF", fail_false loc, [])])) ) )
+  | _ ->
+      ok None
+
+let expand_if_some = function
+  | Prim (loc, "IF_SOME", [right; left], annot) ->
+      ok @@ Some (Seq (loc, [Prim (loc, "IF_NONE", [left; right], annot)]))
+  | Prim (_, "IF_SOME", args, _annot) ->
+      error (Invalid_arity ("IF_SOME", List.length args, 2))
+  | _ ->
+      ok @@ None
+
+let expand_if_right = function
+  | Prim (loc, "IF_RIGHT", [right; left], annot) ->
+      ok @@ Some (Seq (loc, [Prim (loc, "IF_LEFT", [left; right], annot)]))
+  | Prim (_, "IF_RIGHT", args, _annot) ->
+      error (Invalid_arity ("IF_RIGHT", List.length args, 2))
+  | _ ->
+      ok @@ None
+
+let expand_fail = function
+  | Prim (loc, "FAIL", [], []) ->
+      ok
+      @@ Some
+           (Seq
+              ( loc,
+                [Prim (loc, "UNIT", [], []); Prim (loc, "FAILWITH", [], [])] ))
+  | _ ->
+      ok @@ None
+
+let expand original =
+  let rec try_expansions = function
+    | [] ->
+        ok @@ original
+    | expander :: expanders -> (
+        expander original
+        >>? function
+        | None -> try_expansions expanders | Some rewritten -> ok rewritten )
+  in
+  try_expansions
+    [ expand_carn;
+      expand_cdrn;
+      expand_caddadr;
+      expand_set_caddadr;
+      expand_map_caddadr;
+      expand_deprecated_dxiiivp;
+      (* expand_paaiair ; *)
+      expand_pappaiir;
+      (* expand_unpaaiair ; *)
+      expand_unpappaiir;
+      expand_deprecated_duuuuup;
+      expand_compare;
+      expand_asserts;
+      expand_if_some;
+      expand_if_right;
+      expand_fail ]
+
+let expand_rec expr =
+  let rec error_map (expanded, errors) f = function
+    | [] ->
+        (List.rev expanded, List.rev errors)
+    | hd :: tl ->
+        let (new_expanded, new_errors) = f hd in
+        error_map
+          (new_expanded :: expanded, List.rev_append new_errors errors)
+          f
+          tl
+  in
+  let error_map = error_map ([], []) in
+  let rec expand_rec expr =
+    match expand expr with
+    | Ok expanded -> (
+      match expanded with
+      | Seq (loc, items) ->
+          let (items, errors) = error_map expand_rec items in
+          (Seq (loc, items), errors)
+      | Prim (loc, name, args, annot) ->
+          let (args, errors) = error_map expand_rec args in
+          (Prim (loc, name, args, annot), errors)
+      | (Int _ | String _ | Bytes _) as atom ->
+          (atom, []) )
+    | Error errors ->
+        (expr, errors)
+  in
+  expand_rec expr
+
+let unexpand_carn_and_cdrn expanded =
+  match expanded with
+  | Seq (loc, [Prim (_, "GET", [Int (locn, n)], annot)]) ->
+      let (half, parity) = Z.ediv_rem n (Z.of_int 2) in
+      if Z.(parity = zero) then
+        Some (Prim (loc, "CDR", [Int (locn, half)], annot))
+      else Some (Prim (loc, "CAR", [Int (locn, half)], annot))
+  | _ ->
+      None
+
+let unexpand_caddadr expanded =
+  let rec rsteps acc = function
+    | [] ->
+        Some acc
+    | Prim (_, "CAR", [], []) :: rest ->
+        rsteps ("A" :: acc) rest
+    | Prim (_, "CDR", [], []) :: rest ->
+        rsteps ("D" :: acc) rest
+    | _ ->
+        None
+  in
+  match expanded with
+  | Seq (loc, (Prim (_, "CAR", [], []) :: _ as nodes))
+  | Seq (loc, (Prim (_, "CDR", [], []) :: _ as nodes)) -> (
+    match rsteps [] nodes with
+    | Some steps ->
+        let name = String.concat "" ("C" :: List.rev ("R" :: steps)) in
+        Some (Prim (loc, name, [], []))
+    | None ->
+        None )
+  | _ ->
+      None
+
+let unexpand_set_caddadr expanded =
+  let rec steps acc annots = function
+    | Seq
+        ( loc,
+          [ Prim (_, "CDR", [], _);
+            Prim (_, "SWAP", [], _);
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "A" :: acc, annots)
+    | Seq
+        ( loc,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "CAR", [], [field_annot]);
+            Prim (_, "DROP", [], []);
+            Prim (_, "CDR", [], _);
+            Prim (_, "SWAP", [], []);
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "A" :: acc, field_annot :: annots)
+    | Seq (loc, [Prim (_, "CAR", [], _); Prim (_, "PAIR", [], _)]) ->
+        Some (loc, "D" :: acc, annots)
+    | Seq
+        ( loc,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "CDR", [], [field_annot]);
+            Prim (_, "DROP", [], []);
+            Prim (_, "CAR", [], _);
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "D" :: acc, field_annot :: annots)
+    | Seq
+        ( _,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "DIP", [Seq (_, [Prim (_, "CAR", [], _); sub])], []);
+            Prim (_, "CDR", [], _);
+            Prim (_, "SWAP", [], []);
+            Prim (_, "PAIR", [], pair_annots) ] ) ->
+        let (_, pair_annots) = extract_field_annots pair_annots in
+        steps ("A" :: acc) (List.rev_append pair_annots annots) sub
+    | Seq
+        ( _,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], _); sub])], []);
+            Prim (_, "CAR", [], _);
+            Prim (_, "PAIR", [], pair_annots) ] ) ->
+        let (_, pair_annots) = extract_field_annots pair_annots in
+        steps ("D" :: acc) (List.rev_append pair_annots annots) sub
+    | _ ->
+        None
+  in
+  match steps [] [] expanded with
+  | Some (loc, steps, annots) ->
+      let name = String.concat "" ("SET_C" :: List.rev ("R" :: steps)) in
+      Some (Prim (loc, name, [], List.rev annots))
+  | None ->
+      None
+
+let unexpand_map_caddadr expanded =
+  let rec steps acc annots = function
+    | Seq
+        ( loc,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "CDR", [], _);
+            Prim (_, "SWAP", [], []);
+            Prim (_, "DIP", [Seq (_, [Prim (_, "CAR", [], []); code])], []);
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "A" :: acc, annots, code)
+    | Seq
+        ( loc,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "CDR", [], _);
+            Prim (_, "SWAP", [], []);
+            Prim
+              ( _,
+                "DIP",
+                [Seq (_, [Prim (_, "CAR", [], [field_annot]); code])],
+                [] );
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "A" :: acc, field_annot :: annots, code)
+    | Seq
+        ( loc,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "CDR", [], []);
+            code;
+            Prim (_, "SWAP", [], []);
+            Prim (_, "CAR", [], _);
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "D" :: acc, annots, code)
+    | Seq
+        ( loc,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "CDR", [], [field_annot]);
+            code;
+            Prim (_, "SWAP", [], []);
+            Prim (_, "CAR", [], _);
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "D" :: acc, field_annot :: annots, code)
+    | Seq
+        ( _,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "DIP", [Seq (_, [Prim (_, "CAR", [], _); sub])], []);
+            Prim (_, "CDR", [], _);
+            Prim (_, "SWAP", [], []);
+            Prim (_, "PAIR", [], pair_annots) ] ) ->
+        let (_, pair_annots) = extract_field_annots pair_annots in
+        steps ("A" :: acc) (List.rev_append pair_annots annots) sub
+    | Seq
+        ( _,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], []); sub])], []);
+            Prim (_, "CAR", [], []);
+            Prim (_, "PAIR", [], pair_annots) ] ) ->
+        let (_, pair_annots) = extract_field_annots pair_annots in
+        steps ("D" :: acc) (List.rev_append pair_annots annots) sub
+    | _ ->
+        None
+  in
+  match steps [] [] expanded with
+  | Some (loc, steps, annots, code) ->
+      let name = String.concat "" ("MAP_C" :: List.rev ("R" :: steps)) in
+      Some (Prim (loc, name, [code], List.rev annots))
+  | None ->
+      None
+
+let unexpand_deprecated_dxiiivp expanded =
+  (* transparently turn the old expansion of deprecated [DI...IP] to [DIP n] *)
+  match expanded with
+  | Seq
+      ( loc,
+        [Prim (_, "DIP", [(Seq (_, [Prim (_, "DIP", [_], [])]) as sub)], [])]
+      ) ->
+      let rec count acc = function
+        | Seq (_, [Prim (_, "DIP", [sub], [])]) ->
+            count (acc + 1) sub
+        | sub ->
+            (acc, sub)
+      in
+      let (depth, sub) = count 1 sub in
+      Some (Prim (loc, "DIP", [Int (loc, Z.of_int depth); sub], []))
+  | _ ->
+      None
+
+let unexpand_dupn expanded =
+  match expanded with
+  | Seq
+      ( loc,
+        [ Prim
+            (_, "DIP", [Int (_, np); Seq (_, [Prim (_, "DUP", [], annot)])], []);
+          Prim (_, "DIG", [Int (nloc, ng)], []) ] )
+    when Z.equal np (Z.pred ng) ->
+      Some (Prim (loc, "DUP", [Int (nloc, ng)], annot))
+  | _ ->
+      None
+
+let unexpand_deprecated_duuuuup expanded =
+  (* transparently turn the old expansion of deprecated [DU...UP] to [DUP n] *)
+  let rec expand n = function
+    | Seq (loc, [Prim (nloc, "DUP", [], annot)]) ->
+        if n = 1 then None
+        else Some (Prim (loc, "DUP", [Int (nloc, Z.of_int n)], annot))
+    | Seq (_, [Prim (_, "DIP", [expanded'], []); Prim (_, "SWAP", [], [])]) ->
+        expand (n + 1) expanded'
+    | _ ->
+        None
+  in
+  expand 1 expanded
+
+let rec normalize_pair_item ?(right = false) = function
+  | P (i, a, b) ->
+      P (i, normalize_pair_item a, normalize_pair_item ~right:true b)
+  | A when right ->
+      I
+  | A ->
+      A
+  | I ->
+      I
+
+let unexpand_pappaiir expanded =
+  match expanded with
+  | Seq (_, [Prim (_, "PAIR", [], [])]) ->
+      Some expanded
+  | Seq (loc, (_ :: _ as nodes)) -> (
+      let rec exec stack nodes =
+        match (nodes, stack) with
+        | ([], _) ->
+            stack
+        (* support new expansion using [DIP n] *)
+        | ( Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest,
+            a :: rstack )
+          when Z.to_int n > 1 ->
+            exec
+              ( a
+              :: exec
+                   rstack
+                   [ Prim
+                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
+                   ] )
+              rest
+        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, a :: rstack)
+          when Z.to_int n = 1 ->
+            exec (a :: exec rstack sub) rest
+        | (Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest, [])
+          when Z.to_int n > 1 ->
+            exec
+              ( A
+              :: exec
+                   []
+                   [ Prim
+                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
+                   ] )
+              rest
+        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, [])
+          when Z.to_int n = 1 ->
+            exec (A :: exec [] sub) rest
+        (* support old expansion using [DIP] *)
+        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, a :: rstack) ->
+            exec (a :: exec rstack sub) rest
+        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, []) ->
+            exec (A :: exec [] sub) rest
+        | (Prim (_, "PAIR", [], []) :: rest, a :: b :: rstack) ->
+            exec (P (0, a, b) :: rstack) rest
+        | (Prim (_, "PAIR", [], []) :: rest, [a]) ->
+            exec [P (0, a, I)] rest
+        | (Prim (_, "PAIR", [], []) :: rest, []) ->
+            exec [P (0, A, I)] rest
+        | _ ->
+            raise_notrace Not_a_pair
+      in
+      match exec [] nodes with
+      | [] ->
+          None
+      | res :: _ ->
+          let res = normalize_pair_item res in
+          let name = unparse_pair_item res in
+          Some (Prim (loc, name, [], []))
+      | exception Not_a_pair ->
+          None )
+  | _ ->
+      None
+
+let unexpand_unpappaiir expanded =
+  match expanded with
+  | Seq (loc, (_ :: _ as nodes)) -> (
+      let rec exec stack nodes =
+        match (nodes, stack) with
+        | ([], _) ->
+            stack
+        (* support new expansion using [DIP n] *)
+        | ( Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest,
+            a :: rstack )
+          when Z.to_int n > 1 ->
+            exec
+              ( a
+              :: exec
+                   rstack
+                   [ Prim
+                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
+                   ] )
+              rest
+        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, a :: rstack)
+          when Z.to_int n = 1 ->
+            exec (a :: exec rstack sub) rest
+        | (Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest, [])
+          when Z.to_int n > 1 ->
+            exec
+              ( A
+              :: exec
+                   []
+                   [ Prim
+                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
+                   ] )
+              rest
+        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, [])
+          when Z.to_int n = 1 ->
+            exec (A :: exec [] sub) rest
+        (* support old expansion using [DIP] *)
+        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, a :: rstack) ->
+            exec (a :: exec rstack sub) rest
+        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, []) ->
+            exec (A :: exec [] sub) rest
+        | ( Seq
+              ( _,
+                [ Prim (_, "DUP", [], []);
+                  Prim (_, "CAR", [], []);
+                  Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], [])])], []) ]
+              )
+            :: rest,
+            a :: b :: rstack ) ->
+            exec (P (0, a, b) :: rstack) rest
+        | ( Seq
+              ( _,
+                [ Prim (_, "DUP", [], []);
+                  Prim (_, "CAR", [], []);
+                  Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], [])])], []) ]
+              )
+            :: rest,
+            [a] ) ->
+            exec [P (0, a, I)] rest
+        | ( Seq
+              ( _,
+                [ Prim (_, "DUP", [], []);
+                  Prim (_, "CAR", [], []);
+                  Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], [])])], []) ]
+              )
+            :: rest,
+            [] ) ->
+            exec [P (0, A, I)] rest
+        | _ ->
+            raise_notrace Not_a_pair
+      in
+      match exec [] (List.rev nodes) with
+      | [] ->
+          None
+      | res :: _ ->
+          let res = normalize_pair_item res in
+          let name = "UN" ^ unparse_pair_item res in
+          Some (Prim (loc, name, [], []))
+      | exception Not_a_pair ->
+          None )
+  | _ ->
+      None
+
+let unexpand_compare expanded =
+  match expanded with
+  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "EQ", [], annot)]) ->
+      Some (Prim (loc, "CMPEQ", [], annot))
+  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "NEQ", [], annot)]) ->
+      Some (Prim (loc, "CMPNEQ", [], annot))
+  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "LT", [], annot)]) ->
+      Some (Prim (loc, "CMPLT", [], annot))
+  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "GT", [], annot)]) ->
+      Some (Prim (loc, "CMPGT", [], annot))
+  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "LE", [], annot)]) ->
+      Some (Prim (loc, "CMPLE", [], annot))
+  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "GE", [], annot)]) ->
+      Some (Prim (loc, "CMPGE", [], annot))
+  | Seq
+      ( loc,
+        [ Prim (_, "COMPARE", [], _);
+          Prim (_, "EQ", [], _);
+          Prim (_, "IF", args, annot) ] ) ->
+      Some (Prim (loc, "IFCMPEQ", args, annot))
+  | Seq
+      ( loc,
+        [ Prim (_, "COMPARE", [], _);
+          Prim (_, "NEQ", [], _);
+          Prim (_, "IF", args, annot) ] ) ->
+      Some (Prim (loc, "IFCMPNEQ", args, annot))
+  | Seq
+      ( loc,
+        [ Prim (_, "COMPARE", [], _);
+          Prim (_, "LT", [], _);
+          Prim (_, "IF", args, annot) ] ) ->
+      Some (Prim (loc, "IFCMPLT", args, annot))
+  | Seq
+      ( loc,
+        [ Prim (_, "COMPARE", [], _);
+          Prim (_, "GT", [], _);
+          Prim (_, "IF", args, annot) ] ) ->
+      Some (Prim (loc, "IFCMPGT", args, annot))
+  | Seq
+      ( loc,
+        [ Prim (_, "COMPARE", [], _);
+          Prim (_, "LE", [], _);
+          Prim (_, "IF", args, annot) ] ) ->
+      Some (Prim (loc, "IFCMPLE", args, annot))
+  | Seq
+      ( loc,
+        [ Prim (_, "COMPARE", [], _);
+          Prim (_, "GE", [], _);
+          Prim (_, "IF", args, annot) ] ) ->
+      Some (Prim (loc, "IFCMPGE", args, annot))
+  | Seq (loc, [Prim (_, "EQ", [], _); Prim (_, "IF", args, annot)]) ->
+      Some (Prim (loc, "IFEQ", args, annot))
+  | Seq (loc, [Prim (_, "NEQ", [], _); Prim (_, "IF", args, annot)]) ->
+      Some (Prim (loc, "IFNEQ", args, annot))
+  | Seq (loc, [Prim (_, "LT", [], _); Prim (_, "IF", args, annot)]) ->
+      Some (Prim (loc, "IFLT", args, annot))
+  | Seq (loc, [Prim (_, "GT", [], _); Prim (_, "IF", args, annot)]) ->
+      Some (Prim (loc, "IFGT", args, annot))
+  | Seq (loc, [Prim (_, "LE", [], _); Prim (_, "IF", args, annot)]) ->
+      Some (Prim (loc, "IFLE", args, annot))
+  | Seq (loc, [Prim (_, "GE", [], _); Prim (_, "IF", args, annot)]) ->
+      Some (Prim (loc, "IFGE", args, annot))
+  | _ ->
+      None
+
+let unexpand_asserts expanded =
+  match expanded with
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF",
+              [ Seq (_, []);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT", [], []))
+  | Seq
+      ( loc,
+        [ Seq (_, [Prim (_, "COMPARE", [], []); Prim (_, comparison, [], [])]);
+          Prim
+            ( _,
+              "IF",
+              [ Seq (_, []);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_CMP" ^ comparison, [], []))
+  | Seq
+      ( loc,
+        [ Prim (_, comparison, [], []);
+          Prim
+            ( _,
+              "IF",
+              [ Seq (_, []);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_" ^ comparison, [], []))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_NONE",
+              [ Seq (_, [Prim (_, "RENAME", [], annot)]);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_NONE", [], annot))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_NONE",
+              [ Seq (_, []);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_NONE", [], []))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_NONE",
+              [ Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] );
+                Seq (_, []) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_SOME", [], []))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_NONE",
+              [ Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] );
+                Seq (_, [Prim (_, "RENAME", [], annot)]) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_SOME", [], annot))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_LEFT",
+              [ Seq (_, []);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_LEFT", [], []))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_LEFT",
+              [ Seq (_, [Prim (_, "RENAME", [], annot)]);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_LEFT", [], annot))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_LEFT",
+              [ Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] );
+                Seq (_, []) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_RIGHT", [], []))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_LEFT",
+              [ Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] );
+                Seq (_, [Prim (_, "RENAME", [], annot)]) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_RIGHT", [], annot))
+  | _ ->
+      None
+
+let unexpand_if_some = function
+  | Seq (loc, [Prim (_, "IF_NONE", [left; right], annot)]) ->
+      Some (Prim (loc, "IF_SOME", [right; left], annot))
+  | _ ->
+      None
+
+let unexpand_if_right = function
+  | Seq (loc, [Prim (_, "IF_LEFT", [left; right], annot)]) ->
+      Some (Prim (loc, "IF_RIGHT", [right; left], annot))
+  | _ ->
+      None
+
+let unexpand_fail = function
+  | Seq (loc, [Prim (_, "UNIT", [], []); Prim (_, "FAILWITH", [], [])]) ->
+      Some (Prim (loc, "FAIL", [], []))
+  | _ ->
+      None
+
+let unexpand original =
+  let try_unexpansions unexpanders =
+    match
+      List.fold_left
+        (fun acc f ->
+          match acc with
+          | None ->
+              f original
+          | Some rewritten ->
+              Some rewritten)
+        None
+        unexpanders
+    with
+    | None ->
+        original
+    | Some rewritten ->
+        rewritten
+  in
+  try_unexpansions
+    [ unexpand_asserts;
+      unexpand_carn_and_cdrn;
+      unexpand_caddadr;
+      unexpand_set_caddadr;
+      unexpand_map_caddadr;
+      unexpand_deprecated_dxiiivp;
+      unexpand_pappaiir;
+      unexpand_unpappaiir;
+      unexpand_deprecated_duuuuup;
+      unexpand_dupn;
+      unexpand_compare;
+      unexpand_if_some;
+      unexpand_if_right;
+      unexpand_fail ]
+
+(*
+   If an argument of Prim is a sequence, we do not want to unexpand
+   its root in case the source already contains an expanded macro. In
+   which case unexpansion would remove surrounding braces and generate
+   ill-formed code.
+
+   For example, DIIP { DIP { DUP }; SWAP } is not unexpandable but
+   DIIP {{ DIP { DUP }; SWAP }} (note the double braces) is unexpanded
+   to DIIP { DUUP }.
+
+   unexpand_rec_but_root is the same as unexpand_rec but does not try
+   to unexpand at root *)
+
+let rec unexpand_rec expr = unexpand_rec_but_root (unexpand expr)
+
+and unexpand_rec_but_root = function
+  | Seq (loc, items) ->
+      Seq (loc, List.map unexpand_rec items)
+  | Prim (loc, name, args, annot) ->
+      Prim (loc, name, List.map unexpand_rec_but_root args, annot)
+  | (Int _ | String _ | Bytes _) as atom ->
+      atom
+
+let () =
+  let open Data_encoding in
+  register_error_kind
+    `Permanent
+    ~id:"michelson.macros.unexpected_annotation"
+    ~title:"Unexpected annotation"
+    ~description:
+      "A macro had an annotation, but no annotation was permitted on this \
+       macro."
+    ~pp:(fun ppf -> Format.fprintf ppf "Unexpected annotation on macro %s.")
+    (obj1 (req "macro_name" string))
+    (function Unexpected_macro_annotation str -> Some str | _ -> None)
+    (fun s -> Unexpected_macro_annotation s) ;
+  register_error_kind
+    `Permanent
+    ~id:"michelson.macros.sequence_expected"
+    ~title:"Macro expects a sequence"
+    ~description:"An macro expects a sequence, but a sequence was not provided"
+    ~pp:(fun ppf name ->
+      Format.fprintf
+        ppf
+        "Macro %s expects a sequence, but did not receive one."
+        name)
+    (obj1 (req "macro_name" string))
+    (function Sequence_expected name -> Some name | _ -> None)
+    (fun name -> Sequence_expected name) ;
+  register_error_kind
+    `Permanent
+    ~id:"michelson.macros.bas_arity"
+    ~title:"Wrong number of arguments to macro"
+    ~description:"A wrong number of arguments was provided to a macro"
+    ~pp:(fun ppf (name, got, exp) ->
+      Format.fprintf
+        ppf
+        "Macro %s expects %d arguments, was given %d."
+        name
+        exp
+        got)
+    (obj3
+       (req "macro_name" string)
+       (req "given_number_of_arguments" uint16)
+       (req "expected_number_of_arguments" uint16))
+    (function
+      | Invalid_arity (name, got, exp) -> Some (name, got, exp) | _ -> None)
+    (fun (name, got, exp) -> Invalid_arity (name, got, exp))
diff --git a/src/main/main_errors/michelson_v1_macros.mli b/src/main/main_errors/michelson_v1_macros.mli
new file mode 100644
index 000000000..26f52ddaf
--- /dev/null
+++ b/src/main/main_errors/michelson_v1_macros.mli
@@ -0,0 +1,87 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Tezos_micheline
+open Tezos_base__TzPervasives
+
+type 'l node = ('l, string) Micheline.node
+
+type error += Unexpected_macro_annotation of string
+
+type error += Sequence_expected of string
+
+type error += Invalid_arity of string * int * int
+
+val expand : 'l node -> 'l node tzresult
+
+val expand_rec : 'l node -> 'l node * error list
+
+val expand_caddadr : 'l node -> 'l node option tzresult
+
+val expand_set_caddadr : 'l node -> 'l node option tzresult
+
+val expand_map_caddadr : 'l node -> 'l node option tzresult
+
+val expand_deprecated_dxiiivp : 'l node -> 'l node option tzresult
+
+val expand_pappaiir : 'l node -> 'l node option tzresult
+
+val expand_deprecated_duuuuup : 'l node -> 'l node option tzresult
+
+val expand_compare : 'l node -> 'l node option tzresult
+
+val expand_asserts : 'l node -> 'l node option tzresult
+
+val expand_unpappaiir : 'l node -> 'l node option tzresult
+
+val expand_if_some : 'l node -> 'l node option tzresult
+
+val expand_if_right : 'l node -> 'l node option tzresult
+
+val unexpand : 'l node -> 'l node
+
+val unexpand_rec : 'l node -> 'l node
+
+val unexpand_caddadr : 'l node -> 'l node option
+
+val unexpand_set_caddadr : 'l node -> 'l node option
+
+val unexpand_map_caddadr : 'l node -> 'l node option
+
+val unexpand_deprecated_dxiiivp : 'l node -> 'l node option
+
+val unexpand_pappaiir : 'l node -> 'l node option
+
+val unexpand_deprecated_duuuuup : 'l node -> 'l node option
+
+val unexpand_compare : 'l node -> 'l node option
+
+val unexpand_asserts : 'l node -> 'l node option
+
+val unexpand_unpappaiir : 'l node -> 'l node option
+
+val unexpand_if_some : 'l node -> 'l node option
+
+val unexpand_if_right : 'l node -> 'l node option
diff --git a/src/main/main_errors/michelson_v1_parser.ml b/src/main/main_errors/michelson_v1_parser.ml
new file mode 100644
index 000000000..f41e68515
--- /dev/null
+++ b/src/main/main_errors/michelson_v1_parser.ml
@@ -0,0 +1,131 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Tezos_base__TzPervasives
+
+module Tezos_List = struct
+  let rev_map2 ~when_different_lengths f xs ys =
+    let open List in
+    let rec aux zs xs ys =
+      match (xs, ys) with
+      | ([], []) ->
+          Ok zs
+      | ([], _ :: _) | (_ :: _, []) ->
+          Error when_different_lengths
+      | (x :: xs, y :: ys) ->
+          let z = f x y in
+          (aux [@ocaml.tailcall]) (z :: zs) xs ys
+    in
+    aux [] xs ys
+
+  let map2 ~when_different_lengths f xs ys =
+    rev_map2 ~when_different_lengths f xs ys >|? List.rev
+end
+
+open Tezos_protocol_008_PtEdo2Zk.Protocol
+open Tezos_micheline
+open Micheline_parser
+open Micheline
+
+type parsed = {
+  source : string;
+  unexpanded : string canonical;
+  expanded : Michelson_v1_primitives.prim canonical;
+  expansion_table : (int * (Micheline_parser.location * int list)) list;
+  unexpansion_table : (int * int) list;
+}
+
+let compare_parsed = Stdlib.compare
+
+(* Unexpanded toplevel expression should be a sequence *)
+let expand_all source ast errors =
+  let (unexpanded, loc_table) = extract_locations ast in
+  let (expanded, expansion_errors) =
+    Michelson_v1_macros.expand_rec (root unexpanded)
+  in
+  let (expanded, unexpansion_table) = extract_locations expanded in
+  let expansion_table =
+    let sorted =
+      List.sort (fun (_, a) (_, b) -> Stdlib.compare a b) unexpansion_table
+    in
+    let grouped =
+      let rec group = function
+        | (acc, []) ->
+            acc
+        | ([], (u, e) :: r) ->
+            group ([(e, [u])], r)
+        | (((pe, us) :: racc as acc), (u, e) :: r) ->
+            if e = pe then group ((e, u :: us) :: racc, r)
+            else group ((e, [u]) :: acc, r)
+      in
+      group ([], sorted)
+    in
+    match
+      Tezos_List.map2
+        ~when_different_lengths:()
+        (fun (l, ploc) (l', elocs) ->
+          assert (l = l') ;
+          (l, (ploc, elocs)))
+        (List.sort Stdlib.compare loc_table)
+        (List.sort Stdlib.compare grouped)
+    with
+    | Ok v ->
+        v
+    | Error () ->
+        invalid_arg "Michelson_v1_parser.expand_all"
+  in
+  match
+    Environment.wrap_error (Michelson_v1_primitives.prims_of_strings expanded)
+  with
+  | Ok expanded ->
+      ( {source; unexpanded; expanded; expansion_table; unexpansion_table},
+        errors @ expansion_errors )
+  | Error errs ->
+      ( {
+          source;
+          unexpanded;
+          expanded = Micheline.strip_locations (Seq ((), []));
+          expansion_table;
+          unexpansion_table;
+        },
+        errors @ expansion_errors @ errs )
+
+let parse_toplevel ?check source =
+  let (tokens, lexing_errors) = Micheline_parser.tokenize source in
+  let (asts, parsing_errors) = Micheline_parser.parse_toplevel ?check tokens in
+  let ast =
+    let start = min_point asts and stop = max_point asts in
+    Seq ({start; stop}, asts)
+  in
+  expand_all source ast (lexing_errors @ parsing_errors)
+
+let parse_expression ?check source =
+  let (tokens, lexing_errors) = Micheline_parser.tokenize source in
+  let (ast, parsing_errors) =
+    Micheline_parser.parse_expression ?check tokens
+  in
+  expand_all source ast (lexing_errors @ parsing_errors)
+
+let expand_all ~source ~original = expand_all source original []
diff --git a/src/main/main_errors/michelson_v1_parser.mli b/src/main/main_errors/michelson_v1_parser.mli
new file mode 100644
index 000000000..6a85aaf0a
--- /dev/null
+++ b/src/main/main_errors/michelson_v1_parser.mli
@@ -0,0 +1,55 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Tezos_protocol_008_PtEdo2Zk.Protocol
+open Alpha_context
+open Tezos_micheline
+
+(** The result of parsing and expanding a Michelson V1 script or data. *)
+type parsed = {
+  source : string;  (** The original source code. *)
+  unexpanded : string Micheline.canonical;
+      (** Original expression with macros. *)
+  expanded : Script.expr;  (** Expression with macros fully expanded. *)
+  expansion_table : (int * (Micheline_parser.location * int list)) list;
+      (** Associates unexpanded nodes to their parsing locations and
+        the nodes expanded from it in the expanded expression. *)
+  unexpansion_table : (int * int) list;
+      (** Associates an expanded node to its source in the unexpanded
+        expression. *)
+}
+
+val compare_parsed : parsed -> parsed -> int
+
+val parse_toplevel :
+  ?check:bool -> string -> parsed Micheline_parser.parsing_result
+
+val parse_expression :
+  ?check:bool -> string -> parsed Micheline_parser.parsing_result
+
+val expand_all :
+  source:string ->
+  original:Micheline_parser.node ->
+  parsed Micheline_parser.parsing_result
diff --git a/src/main/main_errors/michelson_v1_printer.ml b/src/main/main_errors/michelson_v1_printer.ml
new file mode 100644
index 000000000..4535d456a
--- /dev/null
+++ b/src/main/main_errors/michelson_v1_printer.ml
@@ -0,0 +1,270 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Tezos_protocol_008_PtEdo2Zk.Protocol
+open Tezos_base__TzPervasives
+open Alpha_context
+open Tezos_micheline
+open Micheline
+open Micheline_printer
+
+let rec assoc ~equal k = function
+  | [] ->
+      None
+  | (kk, v) :: kvs ->
+      if equal k kk then Some v else assoc ~equal k kvs
+
+let hd = function x :: _ -> Some x | [] -> None
+
+let anon = {comment = None}
+
+let print_expr ppf expr =
+  expr |> Michelson_v1_primitives.strings_of_prims
+  |> Micheline.inject_locations (fun _ -> anon)
+  |> print_expr ppf
+
+let print_expr_unwrapped ppf expr =
+  expr |> Michelson_v1_primitives.strings_of_prims
+  |> Micheline.inject_locations (fun _ -> anon)
+  |> print_expr_unwrapped ppf
+
+let print_var_annots ppf = List.iter (Format.fprintf ppf "%s ")
+
+let print_annot_expr_unwrapped ppf (expr, annot) =
+  Format.fprintf ppf "%a%a" print_var_annots annot print_expr_unwrapped expr
+
+let print_stack ppf = function
+  | [] ->
+      Format.fprintf ppf "[]"
+  | more ->
+      Format.fprintf
+        ppf
+        "@[<hov 0>[ %a ]@]"
+        (Format.pp_print_list
+           ~pp_sep:(fun ppf () -> Format.fprintf ppf "@ : ")
+           print_annot_expr_unwrapped)
+        more
+
+let print_execution_trace ppf trace =
+  Format.pp_print_list
+    (fun ppf (loc, gas, stack) ->
+      Format.fprintf
+        ppf
+        "- @[<v 0>location: %d (remaining gas: %a)@,[ @[<v 0>%a ]@]@]"
+        loc
+        Gas.pp
+        gas
+        (Format.pp_print_list (fun ppf (e, annot) ->
+             Format.fprintf
+               ppf
+               "@[<v 0>%a  \t%s@]"
+               print_expr
+               e
+               (match annot with None -> "" | Some a -> a)))
+        stack)
+    ppf
+    trace
+
+let print_big_map_diff ppf lazy_storage_diff =
+  let diff =
+    Contract.Legacy_big_map_diff.of_lazy_storage_diff lazy_storage_diff
+  in
+  let pp_map ppf id =
+    if Compare.Z.(id < Z.zero) then
+      Format.fprintf ppf "temp(%s)" (Z.to_string (Z.neg id))
+    else Format.fprintf ppf "map(%s)" (Z.to_string id)
+  in
+  Format.fprintf
+    ppf
+    "@[<v 0>%a@]"
+    (Format.pp_print_list ~pp_sep:Format.pp_print_space (fun ppf ->
+       function
+       | Contract.Legacy_big_map_diff.Clear id ->
+           Format.fprintf ppf "Clear %a" pp_map id
+       | Contract.Legacy_big_map_diff.Alloc {big_map; key_type; value_type} ->
+           Format.fprintf
+             ppf
+             "New %a of type (big_map %a %a)"
+             pp_map
+             big_map
+             print_expr
+             key_type
+             print_expr
+             value_type
+       | Contract.Legacy_big_map_diff.Copy {src; dst} ->
+           Format.fprintf ppf "Copy %a to %a" pp_map src pp_map dst
+       | Contract.Legacy_big_map_diff.Update {big_map; diff_key; diff_value; _}
+         ->
+           Format.fprintf
+             ppf
+             "%s %a[%a]%a"
+             (match diff_value with None -> "Unset" | Some _ -> "Set")
+             pp_map
+             big_map
+             print_expr
+             diff_key
+             (fun ppf -> function None -> () | Some x ->
+                   Format.fprintf ppf " to %a" print_expr x)
+             diff_value))
+    (diff :> Contract.Legacy_big_map_diff.item list)
+
+let inject_types type_map parsed =
+  let rec inject_expr = function
+    | Seq (loc, items) ->
+        Seq (inject_loc `before loc, List.map inject_expr items)
+    | Prim (loc, name, items, annot) ->
+        Prim (inject_loc `after loc, name, List.map inject_expr items, annot)
+    | Int (loc, value) ->
+        Int (inject_loc `after loc, value)
+    | String (loc, value) ->
+        String (inject_loc `after loc, value)
+    | Bytes (loc, value) ->
+        Bytes (inject_loc `after loc, value)
+  and inject_loc which loc =
+    let comment =
+      let ( >?? ) = Option.bind in
+      assoc
+        ~equal:Int.equal
+        loc
+        parsed.Michelson_v1_parser.expansion_table
+      >?? fun (_, locs) ->
+      let locs = List.sort compare locs in
+      hd locs
+      >?? fun head_loc ->
+      assoc ~equal:Int.equal head_loc type_map
+      >?? fun (bef, aft) ->
+      let stack = match which with `before -> bef | `after -> aft in
+      Some (Format.asprintf "%a" print_stack stack)
+    in
+    {comment}
+  in
+  inject_expr (root parsed.unexpanded)
+
+let unparse ?type_map parse expanded =
+  let source =
+    match type_map with
+    | Some type_map ->
+        let (unexpanded, unexpansion_table) =
+          expanded |> Michelson_v1_primitives.strings_of_prims |> root
+          |> Michelson_v1_macros.unexpand_rec |> Micheline.extract_locations
+        in
+        let rec inject_expr = function
+          | Seq (loc, items) ->
+              Seq (inject_loc `before loc, List.map inject_expr items)
+          | Prim (loc, name, items, annot) ->
+              Prim
+                (inject_loc `after loc, name, List.map inject_expr items, annot)
+          | Int (loc, value) ->
+              Int (inject_loc `after loc, value)
+          | String (loc, value) ->
+              String (inject_loc `after loc, value)
+          | Bytes (loc, value) ->
+              Bytes (inject_loc `after loc, value)
+        and inject_loc which loc =
+          let comment =
+            let ( >?? ) = Option.bind in
+            assoc ~equal:Int.equal loc unexpansion_table
+            >?? fun loc ->
+            assoc ~equal:Int.equal loc type_map
+            >?? fun (bef, aft) ->
+            let stack = match which with `before -> bef | `after -> aft in
+            Some (Format.asprintf "%a" print_stack stack)
+          in
+          {comment}
+        in
+        unexpanded |> root |> inject_expr
+        |> Format.asprintf "%a" Micheline_printer.print_expr
+    | None ->
+        expanded |> Michelson_v1_primitives.strings_of_prims |> root
+        |> Michelson_v1_macros.unexpand_rec |> Micheline.strip_locations
+        |> Micheline_printer.printable (fun n -> n)
+        |> Format.asprintf "%a" Micheline_printer.print_expr
+  in
+  match parse source with
+  | (res, []) ->
+      res
+  | (_, _ :: _) ->
+      Stdlib.failwith "Michelson_v1_printer.unparse"
+
+let unparse_toplevel ?type_map =
+  unparse ?type_map Michelson_v1_parser.parse_toplevel
+
+let unparse_expression = unparse Michelson_v1_parser.parse_expression
+
+let unparse_invalid expanded =
+  let source =
+    expanded |> root |> Michelson_v1_macros.unexpand_rec
+    |> Micheline.strip_locations
+    |> Micheline_printer.printable (fun n -> n)
+    |> Format.asprintf "%a" Micheline_printer.print_expr_unwrapped
+  in
+  fst (Michelson_v1_parser.parse_toplevel source)
+
+let ocaml_constructor_of_prim prim =
+  (* Assuming all the prim constructor prefixes match the
+     [[Michelson_v1_primitives.namespace]]. *)
+  let prefix =
+    Michelson_v1_primitives.(namespace prim |> string_of_namespace)
+  in
+  Format.asprintf "%s_%s" prefix @@ Michelson_v1_primitives.string_of_prim prim
+
+let micheline_string_of_expression ~zero_loc expression =
+  let string_of_list : string list -> string =
+   fun xs -> String.concat "; " xs |> Format.asprintf "[%s]"
+  in
+  let show_loc loc = if zero_loc then 0 else loc in
+  let rec string_of_node = function
+    | Int (loc, i) ->
+        let z =
+          match Z.to_int i with
+          | 0 ->
+              "Z.zero"
+          | 1 ->
+              "Z.one"
+          | i ->
+              Format.asprintf "Z.of_int %d" i
+        in
+        Format.asprintf "Int (%d, %s)" (show_loc loc) z
+    | String (loc, s) ->
+        Format.asprintf "String (%d, \"%s\")" (show_loc loc) s
+    | Bytes (loc, b) ->
+        Format.asprintf
+          "Bytes (%d, Bytes.of_string \"%s\")"
+          (show_loc loc)
+          Bytes.(escaped b |> to_string)
+    | Prim (loc, prim, nodes, annot) ->
+        Format.asprintf
+          "Prim (%d, %s, %s, %s)"
+          (show_loc loc)
+          (ocaml_constructor_of_prim prim)
+          (string_of_list @@ List.map string_of_node nodes)
+          (string_of_list @@ List.map (Format.asprintf "\"%s\"") annot)
+    | Seq (loc, nodes) ->
+        Format.asprintf
+          "Seq (%d, %s)"
+          (show_loc loc)
+          (string_of_list @@ List.map string_of_node nodes)
+  in
+  string_of_node (root expression)
diff --git a/src/main/main_errors/michelson_v1_printer.mli b/src/main/main_errors/michelson_v1_printer.mli
new file mode 100644
index 000000000..334ede78b
--- /dev/null
+++ b/src/main/main_errors/michelson_v1_printer.mli
@@ -0,0 +1,65 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Tezos_protocol_008_PtEdo2Zk.Protocol
+open Alpha_context
+open Tezos_micheline
+
+val print_expr : Format.formatter -> Script_repr.expr -> unit
+
+val print_expr_unwrapped : Format.formatter -> Script_repr.expr -> unit
+
+val print_execution_trace :
+  Format.formatter ->
+  (Script.location * Gas.t * (Script.expr * string option) list) list ->
+  unit
+
+val print_big_map_diff : Format.formatter -> Lazy_storage.diffs -> unit
+
+(** Insert the type map returned by the typechecker as comments in a
+    printable Micheline AST. *)
+val inject_types :
+  Script_tc_errors.type_map ->
+  Michelson_v1_parser.parsed ->
+  Micheline_printer.node
+
+(** Unexpand the macros and produce the result of parsing an
+    intermediate pretty printed source. Useful when working with
+    contracts extracted from the blockchain and not local files. *)
+val unparse_toplevel :
+  ?type_map:Script_tc_errors.type_map ->
+  Script.expr ->
+  Michelson_v1_parser.parsed
+
+val unparse_expression : Script.expr -> Michelson_v1_parser.parsed
+
+(** Unexpand the macros and produce the result of parsing an
+    intermediate pretty printed source. Works on generic trees,for
+    programs that fail to be converted to a specific script version. *)
+val unparse_invalid : string Micheline.canonical -> Michelson_v1_parser.parsed
+
+val ocaml_constructor_of_prim : Michelson_v1_primitives.prim -> string
+
+val micheline_string_of_expression : zero_loc:bool -> Script.expr -> string
diff --git a/src/main/main_errors/operation_result.ml b/src/main/main_errors/operation_result.ml
new file mode 100644
index 000000000..3e40bef72
--- /dev/null
+++ b/src/main/main_errors/operation_result.ml
@@ -0,0 +1,522 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Tezos_protocol_008_PtEdo2Zk.Protocol
+open Alpha_context
+open Apply_results
+
+let pp_manager_operation_content (type kind) source internal pp_result ppf
+    ((operation, result) : kind manager_operation * _) =
+  Format.fprintf ppf "@[<v 0>" ;
+  ( match operation with
+  | Transaction {destination; amount; parameters; entrypoint} ->
+      Format.fprintf
+        ppf
+        "@[<v 2>%s:@,Amount: %s%a@,From: %a@,To: %a"
+        (if internal then "Internal transaction" else "Transaction")
+        Client_proto_args.tez_sym
+        Tez.pp
+        amount
+        Contract.pp
+        source
+        Contract.pp
+        destination ;
+      ( match entrypoint with
+      | "default" ->
+          ()
+      | _ ->
+          Format.fprintf ppf "@,Entrypoint: %s" entrypoint ) ;
+      ( if not (Script_repr.is_unit_parameter parameters) then
+        let expr =
+          WithExceptions.Option.to_exn
+            ~none:(Failure "ill-serialized argument")
+            (Data_encoding.force_decode parameters)
+        in
+        Format.fprintf
+          ppf
+          "@,Parameter: @[<v 0>%a@]"
+          Michelson_v1_printer.print_expr
+          expr ) ;
+      pp_result ppf result ; Format.fprintf ppf "@]"
+  | Origination {delegate; credit; script = {code; storage}; preorigination = _}
+    ->
+      Format.fprintf
+        ppf
+        "@[<v 2>%s:@,From: %a@,Credit: %s%a"
+        (if internal then "Internal origination" else "Origination")
+        Contract.pp
+        source
+        Client_proto_args.tez_sym
+        Tez.pp
+        credit ;
+      let code =
+        WithExceptions.Option.to_exn
+          ~none:(Failure "ill-serialized code")
+          (Data_encoding.force_decode code)
+      and storage =
+        WithExceptions.Option.to_exn
+          ~none:(Failure "ill-serialized storage")
+          (Data_encoding.force_decode storage)
+      in
+      let {Michelson_v1_parser.source; _} =
+        Michelson_v1_printer.unparse_toplevel code
+      in
+      Format.fprintf
+        ppf
+        "@,@[<hv 2>Script:@ @[<h>%a@]@,@[<hv 2>Initial storage:@ %a@]"
+        Format.pp_print_text
+        source
+        Michelson_v1_printer.print_expr
+        storage ;
+      ( match delegate with
+      | None ->
+          Format.fprintf ppf "@,No delegate for this contract"
+      | Some delegate ->
+          Format.fprintf
+            ppf
+            "@,Delegate: %a"
+            Signature.Public_key_hash.pp
+            delegate ) ;
+      pp_result ppf result ; Format.fprintf ppf "@]"
+  | Reveal key ->
+      Format.fprintf
+        ppf
+        "@[<v 2>%s of manager public key:@,Contract: %a@,Key: %a%a@]"
+        (if internal then "Internal revelation" else "Revelation")
+        Contract.pp
+        source
+        Signature.Public_key.pp
+        key
+        pp_result
+        result
+  | Delegation None ->
+      Format.fprintf
+        ppf
+        "@[<v 2>%s:@,Contract: %a@,To: nobody%a@]"
+        (if internal then "Internal Delegation" else "Delegation")
+        Contract.pp
+        source
+        pp_result
+        result
+  | Delegation (Some delegate) ->
+      Format.fprintf
+        ppf
+        "@[<v 2>%s:@,Contract: %a@,To: %a%a@]"
+        (if internal then "Internal Delegation" else "Delegation")
+        Contract.pp
+        source
+        Signature.Public_key_hash.pp
+        delegate
+        pp_result
+        result ) ;
+  Format.fprintf ppf "@]"
+
+let pp_balance_updates ppf = function
+  | [] ->
+      ()
+  | balance_updates ->
+      let open Delegate in
+      (* For dry runs, the baker's key is zero
+         (tz1Ke2h7sDdakHJQh8WX4Z372du1KChsksyU). Instead of printing this
+         key hash, we want to make the result more informative. *)
+      let pp_baker ppf baker =
+        if Signature.Public_key_hash.equal baker Signature.Public_key_hash.zero
+        then Format.fprintf ppf "the baker who will include this operation"
+        else Signature.Public_key_hash.pp ppf baker
+      in
+      let balance_updates =
+        List.map
+          (fun (balance, update) ->
+            let balance =
+              match balance with
+              | Contract c ->
+                  Format.asprintf "%a" Contract.pp c
+              | Rewards (pkh, l) ->
+                  Format.asprintf "rewards(%a,%a)" pp_baker pkh Cycle.pp l
+              | Fees (pkh, l) ->
+                  Format.asprintf "fees(%a,%a)" pp_baker pkh Cycle.pp l
+              | Deposits (pkh, l) ->
+                  Format.asprintf "deposits(%a,%a)" pp_baker pkh Cycle.pp l
+            in
+            (balance, update))
+          balance_updates
+      in
+      let column_size =
+        List.fold_left
+          (fun acc (balance, _) -> Compare.Int.max acc (String.length balance))
+          0
+          balance_updates
+      in
+      let pp_update ppf = function
+        | Credited amount ->
+            Format.fprintf ppf "+%s%a" Client_proto_args.tez_sym Tez.pp amount
+        | Debited amount ->
+            Format.fprintf ppf "-%s%a" Client_proto_args.tez_sym Tez.pp amount
+      in
+      let pp_one ppf (balance, update) =
+        let to_fill = column_size + 3 - String.length balance in
+        let filler = String.make to_fill '.' in
+        Format.fprintf ppf "%s %s %a" balance filler pp_update update
+      in
+      Format.fprintf
+        ppf
+        "@[<v 0>%a@]"
+        (Format.pp_print_list pp_one)
+        balance_updates
+
+let pp_manager_operation_contents_and_result ppf
+    ( Manager_operation
+        {source; fee; operation; counter; gas_limit; storage_limit},
+      Manager_operation_result
+        {balance_updates; operation_result; internal_operation_results} ) =
+  let pp_lazy_storage_diff = function
+    | None ->
+        ()
+    | Some lazy_storage_diff -> (
+        let big_map_diff =
+          Contract.Legacy_big_map_diff.of_lazy_storage_diff lazy_storage_diff
+        in
+        match (big_map_diff :> Contract.Legacy_big_map_diff.item list) with
+        | [] ->
+            ()
+        | _ :: _ ->
+            (* TODO: print all lazy storage diff *)
+            Format.fprintf
+              ppf
+              "@,@[<v 2>Updated big_maps:@ %a@]"
+              Michelson_v1_printer.print_big_map_diff
+              lazy_storage_diff )
+  in
+  let pp_transaction_result
+      (Transaction_result
+        { balance_updates;
+          consumed_gas;
+          storage;
+          originated_contracts;
+          storage_size;
+          paid_storage_size_diff;
+          lazy_storage_diff;
+          allocated_destination_contract = _ }) =
+    ( match originated_contracts with
+    | [] ->
+        ()
+    | contracts ->
+        Format.fprintf
+          ppf
+          "@,@[<v 2>Originated contracts:@,%a@]"
+          (Format.pp_print_list Contract.pp)
+          contracts ) ;
+    ( match storage with
+    | None ->
+        ()
+    | Some expr ->
+        Format.fprintf
+          ppf
+          "@,@[<hv 2>Updated storage:@ %a@]"
+          Michelson_v1_printer.print_expr
+          expr ) ;
+    pp_lazy_storage_diff lazy_storage_diff ;
+    if storage_size <> Z.zero then
+      Format.fprintf ppf "@,Storage size: %s bytes" (Z.to_string storage_size) ;
+    if paid_storage_size_diff <> Z.zero then
+      Format.fprintf
+        ppf
+        "@,Paid storage size diff: %s bytes"
+        (Z.to_string paid_storage_size_diff) ;
+    Format.fprintf ppf "@,Consumed gas: %a" Gas.Arith.pp consumed_gas ;
+    match balance_updates with
+    | [] ->
+        ()
+    | balance_updates ->
+        Format.fprintf
+          ppf
+          "@,Balance updates:@,  %a"
+          pp_balance_updates
+          balance_updates
+  in
+  let pp_origination_result
+      (Origination_result
+        { lazy_storage_diff;
+          balance_updates;
+          consumed_gas;
+          originated_contracts;
+          storage_size;
+          paid_storage_size_diff }) =
+    ( match originated_contracts with
+    | [] ->
+        ()
+    | contracts ->
+        Format.fprintf
+          ppf
+          "@,@[<v 2>Originated contracts:@,%a@]"
+          (Format.pp_print_list Contract.pp)
+          contracts ) ;
+    if storage_size <> Z.zero then
+      Format.fprintf ppf "@,Storage size: %s bytes" (Z.to_string storage_size) ;
+    pp_lazy_storage_diff lazy_storage_diff ;
+    if paid_storage_size_diff <> Z.zero then
+      Format.fprintf
+        ppf
+        "@,Paid storage size diff: %s bytes"
+        (Z.to_string paid_storage_size_diff) ;
+    Format.fprintf ppf "@,Consumed gas: %a" Gas.Arith.pp consumed_gas ;
+    match balance_updates with
+    | [] ->
+        ()
+    | balance_updates ->
+        Format.fprintf
+          ppf
+          "@,Balance updates:@,  %a"
+          pp_balance_updates
+          balance_updates
+  in
+  let pp_result (type kind) ppf (result : kind manager_operation_result) =
+    Format.fprintf ppf "@," ;
+    match result with
+    | Skipped _ ->
+        Format.fprintf ppf "This operation was skipped"
+    | Failed (_, _errs) ->
+        Format.fprintf ppf "This operation FAILED."
+    | Applied (Reveal_result {consumed_gas}) ->
+        Format.fprintf ppf "This revelation was successfully applied" ;
+        Format.fprintf ppf "@,Consumed gas: %a" Gas.Arith.pp consumed_gas
+    | Backtracked (Reveal_result _, _) ->
+        Format.fprintf
+          ppf
+          "@[<v 0>This revelation was BACKTRACKED, its expected effects were \
+           NOT applied.@]"
+    | Applied (Delegation_result {consumed_gas}) ->
+        Format.fprintf ppf "This delegation was successfully applied" ;
+        Format.fprintf ppf "@,Consumed gas: %a" Gas.Arith.pp consumed_gas
+    | Backtracked (Delegation_result _, _) ->
+        Format.fprintf
+          ppf
+          "@[<v 0>This delegation was BACKTRACKED, its expected effects were \
+           NOT applied.@]"
+    | Applied (Transaction_result _ as tx) ->
+        Format.fprintf ppf "This transaction was successfully applied" ;
+        pp_transaction_result tx
+    | Backtracked ((Transaction_result _ as tx), _errs) ->
+        Format.fprintf
+          ppf
+          "@[<v 0>This transaction was BACKTRACKED, its expected effects (as \
+           follow) were NOT applied.@]" ;
+        pp_transaction_result tx
+    | Applied (Origination_result _ as op) ->
+        Format.fprintf ppf "This origination was successfully applied" ;
+        pp_origination_result op
+    | Backtracked ((Origination_result _ as op), _errs) ->
+        Format.fprintf
+          ppf
+          "@[<v 0>This origination was BACKTRACKED, its expected effects (as \
+           follow) were NOT applied.@]" ;
+        pp_origination_result op
+  in
+  Format.fprintf
+    ppf
+    "@[<v 0>@[<v 2>Manager signed operations:@,\
+     From: %a@,\
+     Fee to the baker: %s%a@,\
+     Expected counter: %s@,\
+     Gas limit: %a@,\
+     Storage limit: %s bytes"
+    Signature.Public_key_hash.pp
+    source
+    Client_proto_args.tez_sym
+    Tez.pp
+    fee
+    (Z.to_string counter)
+    Gas.Arith.pp_integral
+    gas_limit
+    (Z.to_string storage_limit) ;
+  ( match balance_updates with
+  | [] ->
+      ()
+  | balance_updates ->
+      Format.fprintf
+        ppf
+        "@,Balance updates:@,  %a"
+        pp_balance_updates
+        balance_updates ) ;
+  Format.fprintf
+    ppf
+    "@,%a"
+    (pp_manager_operation_content
+       (Contract.implicit_contract source)
+       false
+       pp_result)
+    (operation, operation_result) ;
+  ( match internal_operation_results with
+  | [] ->
+      ()
+  | _ :: _ ->
+      Format.fprintf
+        ppf
+        "@,@[<v 2>Internal operations:@ %a@]"
+        (Format.pp_print_list (fun ppf (Internal_operation_result (op, res)) ->
+             pp_manager_operation_content
+               op.source
+               false
+               pp_result
+               ppf
+               (op.operation, res)))
+        internal_operation_results ) ;
+  Format.fprintf ppf "@]"
+
+let rec pp_contents_and_result_list :
+    type kind. Format.formatter -> kind contents_and_result_list -> unit =
+ fun ppf -> function
+  | Single_and_result
+      (Seed_nonce_revelation {level; nonce}, Seed_nonce_revelation_result bus)
+    ->
+      Format.fprintf
+        ppf
+        "@[<v 2>Seed nonce revelation:@,\
+         Level: %a@,\
+         Nonce (hash): %a@,\
+         Balance updates:@,\
+        \  %a@]"
+        Raw_level.pp
+        level
+        Nonce_hash.pp
+        (Nonce.hash nonce)
+        pp_balance_updates
+        bus
+  | Single_and_result
+      (Double_baking_evidence {bh1; bh2}, Double_baking_evidence_result bus) ->
+      Format.fprintf
+        ppf
+        "@[<v 2>Double baking evidence:@,\
+         Exhibit A: %a@,\
+         Exhibit B: %a@,\
+         Balance updates:@,\
+        \  %a@]"
+        Block_hash.pp
+        (Block_header.hash bh1)
+        Block_hash.pp
+        (Block_header.hash bh2)
+        pp_balance_updates
+        bus
+  | Single_and_result
+      ( Double_endorsement_evidence {op1; op2},
+        Double_endorsement_evidence_result bus ) ->
+      Format.fprintf
+        ppf
+        "@[<v 2>Double endorsement evidence:@,\
+         Exhibit A: %a@,\
+         Exhibit B: %a@,\
+         Balance updates:@,\
+        \  %a@]"
+        Operation_hash.pp
+        (Operation.hash op1)
+        Operation_hash.pp
+        (Operation.hash op2)
+        pp_balance_updates
+        bus
+  | Single_and_result (Activate_account {id; _}, Activate_account_result bus)
+    ->
+      Format.fprintf
+        ppf
+        "@[<v 2>Genesis account activation:@,\
+         Account: %a@,\
+         Balance updates:@,\
+        \  %a@]"
+        Ed25519.Public_key_hash.pp
+        id
+        pp_balance_updates
+        bus
+  | Single_and_result
+      ( Endorsement {level},
+        Endorsement_result {balance_updates; delegate; slots} ) ->
+      Format.fprintf
+        ppf
+        "@[<v 2>Endorsement:@,\
+         Level: %a@,\
+         Balance updates:%a@,\
+         Delegate: %a@,\
+         Slots: %a@]"
+        Raw_level.pp
+        level
+        pp_balance_updates
+        balance_updates
+        Signature.Public_key_hash.pp
+        delegate
+        (Format.pp_print_list ~pp_sep:Format.pp_print_space Format.pp_print_int)
+        slots
+  | Single_and_result (Proposals {source; period; proposals}, Proposals_result)
+    ->
+      Format.fprintf
+        ppf
+        "@[<v 2>Proposals:@,\
+         From: %a@,\
+         Period: %ld@,\
+         Protocols:@,\
+        \  @[<v 0>%a@]@]"
+        Signature.Public_key_hash.pp
+        source
+        period
+        (Format.pp_print_list Protocol_hash.pp)
+        proposals
+  | Single_and_result (Ballot {source; period; proposal; ballot}, Ballot_result)
+    ->
+      Format.fprintf
+        ppf
+        "@[<v 2>Ballot:@,From: %a@,Period: %ld@,Protocol: %a@,Vote: %a@]"
+        Signature.Public_key_hash.pp
+        source
+        period
+        Protocol_hash.pp
+        proposal
+        Data_encoding.Json.pp
+        (Data_encoding.Json.construct Vote.ballot_encoding ballot)
+  | Single_and_result
+      ((Manager_operation _ as op), (Manager_operation_result _ as res)) ->
+      Format.fprintf ppf "%a" pp_manager_operation_contents_and_result (op, res)
+  | Cons_and_result
+      ((Manager_operation _ as op), (Manager_operation_result _ as res), rest)
+    ->
+      Format.fprintf
+        ppf
+        "%a@\n%a"
+        pp_manager_operation_contents_and_result
+        (op, res)
+        pp_contents_and_result_list
+        rest
+
+let pp_operation_result ppf
+    ((op, res) : 'kind contents_list * 'kind contents_result_list) =
+  Format.fprintf ppf "@[<v 0>" ;
+  let contents_and_result_list = Apply_results.pack_contents_list op res in
+  pp_contents_and_result_list ppf contents_and_result_list ;
+  Format.fprintf ppf "@]@."
+
+let pp_internal_operation ppf
+    (Internal_operation {source; operation; nonce = _}) =
+  pp_manager_operation_content
+    source
+    true
+    (fun _ppf () -> ())
+    ppf
+    (operation, ())
diff --git a/src/main/main_errors/operation_result.mli b/src/main/main_errors/operation_result.mli
new file mode 100644
index 000000000..52ea953d9
--- /dev/null
+++ b/src/main/main_errors/operation_result.mli
@@ -0,0 +1,35 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Tezos_protocol_008_PtEdo2Zk.Protocol
+open Alpha_context
+
+val pp_internal_operation :
+  Format.formatter -> packed_internal_operation -> unit
+
+val pp_operation_result :
+  Format.formatter ->
+  'kind contents_list * 'kind Apply_results.contents_result_list ->
+  unit
diff --git a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/dune b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/dune
index 2e0b38dd0..768fdd99e 100644
--- a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/dune
+++ b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/dune
@@ -8,11 +8,13 @@
             tezos-protocol-environment
             tezos-protocol-008-PtEdo2Zk
             tezos-protocol-008-PtEdo2Zk-parameters
-            tezos-client-008-PtEdo2Zk)
+            tezos-error-monad
+            ;tezos-client-008-PtEdo2Zk
+ )
  (flags (:standard -open Tezos_base__TzPervasives
                    -open Tezos_micheline
                    -open Tezos_stdlib_unix
                    -open Tezos_protocol_008_PtEdo2Zk
-                   -open Tezos_client_008_PtEdo2Zk
+                   ;-open Tezos_client_008_PtEdo2Zk
                    -open Tezos_protocol_environment_008_PtEdo2Zk
                    -open Tezos_shell_services)))
\ No newline at end of file
diff --git a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/ligo-008-PtEdo2Zk-test-helpers.opam b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/ligo-008-PtEdo2Zk-test-helpers.opam
index a1b02251f..2e9913076 100644
--- a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/ligo-008-PtEdo2Zk-test-helpers.opam
+++ b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/ligo-008-PtEdo2Zk-test-helpers.opam
@@ -13,7 +13,7 @@ depends: [
   "tezos-protocol-environment"
   "tezos-protocol-008-PtEdo2Zk"
   "tezos-protocol-008-PtEdo2Zk-parameters"
-  "tezos-client-008-PtEdo2Zk"
+  # "tezos-client-008-PtEdo2Zk"
   "alcotest-lwt"
 ]
 build: [
diff --git a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_macros.ml b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_macros.ml
new file mode 100644
index 000000000..a2e1bb897
--- /dev/null
+++ b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_macros.ml
@@ -0,0 +1,1542 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(* Copyright (c) 2019 Nomadic Labs <contact@nomadic-labs.com>                *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Tezos_micheline
+open Micheline
+module IntMap = Map.Make (Compare.Int)
+
+type 'l node = ('l, string) Micheline.node
+
+type error += Unexpected_macro_annotation of string
+
+type error += Sequence_expected of string
+
+type error += Invalid_arity of string * int * int
+
+let rec check_letters str i j f =
+  i > j || (f str.[i] && check_letters str (i + 1) j f)
+
+let expand_caddadr original =
+  match original with
+  | Prim (loc, str, args, annot) ->
+      let len = String.length str in
+      if
+        len > 3
+        && str.[0] = 'C'
+        && str.[len - 1] = 'R'
+        && check_letters str 1 (len - 2) (function
+               | 'A' | 'D' ->
+                   true
+               | _ ->
+                   false)
+      then
+        ( match args with
+        | [] ->
+            ok ()
+        | _ :: _ ->
+            error (Invalid_arity (str, List.length args, 0)) )
+        >>? fun () ->
+        let path_annot =
+          List.filter (function "@%" | "@%%" -> true | _ -> false) annot
+        in
+        let rec parse i acc =
+          if i = 0 then Seq (loc, acc)
+          else
+            let annot = if i = len - 2 then annot else path_annot in
+            match str.[i] with
+            | 'A' ->
+                parse (i - 1) (Prim (loc, "CAR", [], annot) :: acc)
+            | 'D' ->
+                parse (i - 1) (Prim (loc, "CDR", [], annot) :: acc)
+            | _ ->
+                assert false
+        in
+        ok (Some (parse (len - 2) []))
+      else ok None
+  | _ ->
+      ok None
+
+let expand_carn original =
+  match original with
+  | Prim (loc, "CAR", [Int (loc2, n)], annot) ->
+      ok
+        (Some
+           (Seq
+              ( loc,
+                [ Prim
+                    ( loc,
+                      "GET",
+                      [Int (loc2, Z.(of_int 1 + (n * of_int 2)))],
+                      annot ) ] )))
+  | _ ->
+      ok None
+
+let expand_cdrn original =
+  match original with
+  | Prim (loc, "CDR", [Int (loc2, n)], annot) ->
+      ok
+        (Some
+           (Seq
+              (loc, [Prim (loc, "GET", [Int (loc2, Z.(n * of_int 2))], annot)])))
+  | _ ->
+      ok None
+
+let extract_field_annots annot =
+  List.partition
+    (fun a ->
+      match a.[0] with
+      | '%' ->
+          true
+      | _ ->
+          false
+      | exception Invalid_argument _ ->
+          false)
+    annot
+
+let expand_set_caddadr original =
+  match original with
+  | Prim (loc, str, args, annot) ->
+      let len = String.length str in
+      if
+        len >= 7
+        && String.sub str 0 5 = "SET_C"
+        && str.[len - 1] = 'R'
+        && check_letters str 5 (len - 2) (function
+               | 'A' | 'D' ->
+                   true
+               | _ ->
+                   false)
+      then
+        ( match args with
+        | [] ->
+            ok ()
+        | _ :: _ ->
+            error (Invalid_arity (str, List.length args, 0)) )
+        >>? fun () ->
+        ( match extract_field_annots annot with
+        | ([], annot) ->
+            ok (None, annot)
+        | ([f], annot) ->
+            ok (Some f, annot)
+        | (_, _) ->
+            error (Unexpected_macro_annotation str) )
+        >>? fun (field_annot, annot) ->
+        let rec parse i acc =
+          if i = 4 then acc
+          else
+            let annot = if i = 5 then annot else [] in
+            match str.[i] with
+            | 'A' ->
+                let acc =
+                  Seq
+                    ( loc,
+                      [ Prim (loc, "DUP", [], []);
+                        Prim
+                          ( loc,
+                            "DIP",
+                            [Seq (loc, [Prim (loc, "CAR", [], ["@%%"]); acc])],
+                            [] );
+                        Prim (loc, "CDR", [], ["@%%"]);
+                        Prim (loc, "SWAP", [], []);
+                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
+                in
+                parse (i - 1) acc
+            | 'D' ->
+                let acc =
+                  Seq
+                    ( loc,
+                      [ Prim (loc, "DUP", [], []);
+                        Prim
+                          ( loc,
+                            "DIP",
+                            [Seq (loc, [Prim (loc, "CDR", [], ["@%%"]); acc])],
+                            [] );
+                        Prim (loc, "CAR", [], ["@%%"]);
+                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
+                in
+                parse (i - 1) acc
+            | _ ->
+                assert false
+        in
+        match str.[len - 2] with
+        | 'A' ->
+            let access_check =
+              match field_annot with
+              | None ->
+                  []
+              | Some f ->
+                  [ Prim (loc, "DUP", [], []);
+                    Prim (loc, "CAR", [], [f]);
+                    Prim (loc, "DROP", [], []) ]
+            in
+            let encoding =
+              [Prim (loc, "CDR", [], ["@%%"]); Prim (loc, "SWAP", [], [])]
+            in
+            let pair =
+              [ Prim
+                  ( loc,
+                    "PAIR",
+                    [],
+                    [Option.value field_annot ~default:"%"; "%@"] ) ]
+            in
+            let init = Seq (loc, access_check @ encoding @ pair) in
+            ok (Some (parse (len - 3) init))
+        | 'D' ->
+            let access_check =
+              match field_annot with
+              | None ->
+                  []
+              | Some f ->
+                  [ Prim (loc, "DUP", [], []);
+                    Prim (loc, "CDR", [], [f]);
+                    Prim (loc, "DROP", [], []) ]
+            in
+            let encoding = [Prim (loc, "CAR", [], ["@%%"])] in
+            let pair =
+              [ Prim
+                  ( loc,
+                    "PAIR",
+                    [],
+                    ["%@"; Option.value field_annot ~default:"%"] ) ]
+            in
+            let init = Seq (loc, access_check @ encoding @ pair) in
+            ok (Some (parse (len - 3) init))
+        | _ ->
+            assert false
+      else ok None
+  | _ ->
+      ok None
+
+let expand_map_caddadr original =
+  match original with
+  | Prim (loc, str, args, annot) ->
+      let len = String.length str in
+      if
+        len >= 7
+        && String.sub str 0 5 = "MAP_C"
+        && str.[len - 1] = 'R'
+        && check_letters str 5 (len - 2) (function
+               | 'A' | 'D' ->
+                   true
+               | _ ->
+                   false)
+      then
+        ( match args with
+        | [(Seq _ as code)] ->
+            ok code
+        | [_] ->
+            error (Sequence_expected str)
+        | [] | _ :: _ :: _ ->
+            error (Invalid_arity (str, List.length args, 1)) )
+        >>? fun code ->
+        ( match extract_field_annots annot with
+        | ([], annot) ->
+            ok (None, annot)
+        | ([f], annot) ->
+            ok (Some f, annot)
+        | (_, _) ->
+            error (Unexpected_macro_annotation str) )
+        >>? fun (field_annot, annot) ->
+        let rec parse i acc =
+          if i = 4 then acc
+          else
+            let annot = if i = 5 then annot else [] in
+            match str.[i] with
+            | 'A' ->
+                let acc =
+                  Seq
+                    ( loc,
+                      [ Prim (loc, "DUP", [], []);
+                        Prim
+                          ( loc,
+                            "DIP",
+                            [Seq (loc, [Prim (loc, "CAR", [], ["@%%"]); acc])],
+                            [] );
+                        Prim (loc, "CDR", [], ["@%%"]);
+                        Prim (loc, "SWAP", [], []);
+                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
+                in
+                parse (i - 1) acc
+            | 'D' ->
+                let acc =
+                  Seq
+                    ( loc,
+                      [ Prim (loc, "DUP", [], []);
+                        Prim
+                          ( loc,
+                            "DIP",
+                            [Seq (loc, [Prim (loc, "CDR", [], ["@%%"]); acc])],
+                            [] );
+                        Prim (loc, "CAR", [], ["@%%"]);
+                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
+                in
+                parse (i - 1) acc
+            | _ ->
+                assert false
+        in
+        let cr_annot =
+          match field_annot with
+          | None ->
+              []
+          | Some f ->
+              ["@" ^ String.sub f 1 (String.length f - 1)]
+        in
+        match str.[len - 2] with
+        | 'A' ->
+            let init =
+              Seq
+                ( loc,
+                  [ Prim (loc, "DUP", [], []);
+                    Prim (loc, "CDR", [], ["@%%"]);
+                    Prim
+                      ( loc,
+                        "DIP",
+                        [Seq (loc, [Prim (loc, "CAR", [], cr_annot); code])],
+                        [] );
+                    Prim (loc, "SWAP", [], []);
+                    Prim
+                      ( loc,
+                        "PAIR",
+                        [],
+                        [Option.value field_annot ~default:"%"; "%@"] ) ] )
+            in
+            ok (Some (parse (len - 3) init))
+        | 'D' ->
+            let init =
+              Seq
+                ( loc,
+                  [ Prim (loc, "DUP", [], []);
+                    Prim (loc, "CDR", [], cr_annot);
+                    code;
+                    Prim (loc, "SWAP", [], []);
+                    Prim (loc, "CAR", [], ["@%%"]);
+                    Prim
+                      ( loc,
+                        "PAIR",
+                        [],
+                        ["%@"; Option.value field_annot ~default:"%"] ) ] )
+            in
+            ok (Some (parse (len - 3) init))
+        | _ ->
+            assert false
+      else ok None
+  | _ ->
+      ok None
+
+exception Not_a_roman
+
+let decimal_of_roman roman =
+  (* http://rosettacode.org/wiki/Roman_numerals/Decode#OCaml *)
+  let arabic = ref 0 in
+  let lastval = ref 0 in
+  for i = String.length roman - 1 downto 0 do
+    let n =
+      match roman.[i] with
+      | 'M' ->
+          1000
+      | 'D' ->
+          500
+      | 'C' ->
+          100
+      | 'L' ->
+          50
+      | 'X' ->
+          10
+      | 'V' ->
+          5
+      | 'I' ->
+          1
+      | _ ->
+          raise_notrace Not_a_roman
+    in
+    if Compare.Int.(n < !lastval) then arabic := !arabic - n
+    else arabic := !arabic + n ;
+    lastval := n
+  done ;
+  !arabic
+
+let dip ~loc ?(annot = []) depth instr =
+  assert (depth >= 0) ;
+  if depth = 1 then Prim (loc, "DIP", [instr], annot)
+  else Prim (loc, "DIP", [Int (loc, Z.of_int depth); instr], annot)
+
+let expand_deprecated_dxiiivp original =
+  (* transparently expands deprecated macro [DI...IP] to instruction [DIP n] *)
+  match original with
+  | Prim (loc, str, args, annot) ->
+      let len = String.length str in
+      if len > 3 && str.[0] = 'D' && str.[len - 1] = 'P' then
+        try
+          let depth = decimal_of_roman (String.sub str 1 (len - 2)) in
+          match args with
+          | [(Seq (_, _) as arg)] ->
+              ok @@ Some (dip ~loc ~annot depth arg)
+          | [_] ->
+              error (Sequence_expected str)
+          | [] | _ :: _ :: _ ->
+              error (Invalid_arity (str, List.length args, 1))
+        with Not_a_roman -> ok None
+      else ok None
+  | _ ->
+      ok None
+
+exception Not_a_pair
+
+type pair_item = A | I | P of int * pair_item * pair_item
+
+let parse_pair_substr str ~len start =
+  let rec parse ?left i =
+    if i = len - 1 then raise_notrace Not_a_pair
+    else if str.[i] = 'P' then
+      let (next_i, l) = parse ~left:true (i + 1) in
+      let (next_i, r) = parse ~left:false next_i in
+      (next_i, P (i, l, r))
+    else if str.[i] = 'A' && left = Some true then (i + 1, A)
+    else if str.[i] = 'I' && left <> Some true then (i + 1, I)
+    else raise_notrace Not_a_pair
+  in
+  let (last, ast) = parse start in
+  if last <> len - 1 then raise_notrace Not_a_pair else ast
+
+let unparse_pair_item ast =
+  let rec unparse ast acc =
+    match ast with
+    | P (_, l, r) ->
+        unparse r (unparse l ("P" :: acc))
+    | A ->
+        "A" :: acc
+    | I ->
+        "I" :: acc
+  in
+  List.rev ("R" :: unparse ast []) |> String.concat ""
+
+let pappaiir_annots_pos ast annot =
+  let rec find_annots_pos p_pos ast annots acc =
+    match (ast, annots) with
+    | (_, []) ->
+        (annots, acc)
+    | (P (i, left, right), _) ->
+        let (annots, acc) = find_annots_pos i left annots acc in
+        find_annots_pos i right annots acc
+    | (A, a :: annots) ->
+        let pos =
+          match IntMap.find p_pos acc with
+          | None ->
+              ([a], [])
+          | Some (_, cdr) ->
+              ([a], cdr)
+        in
+        (annots, IntMap.add p_pos pos acc)
+    | (I, a :: annots) ->
+        let pos =
+          match IntMap.find p_pos acc with
+          | None ->
+              ([], [a])
+          | Some (car, _) ->
+              (car, [a])
+        in
+        (annots, IntMap.add p_pos pos acc)
+  in
+  snd (find_annots_pos 0 ast annot IntMap.empty)
+
+let expand_pappaiir original =
+  match original with
+  | Prim (loc, str, args, annot) ->
+      let len = String.length str in
+      if
+        len > 4
+        && str.[0] = 'P'
+        && str.[len - 1] = 'R'
+        && check_letters str 1 (len - 2) (function
+               | 'P' | 'A' | 'I' ->
+                   true
+               | _ ->
+                   false)
+      then
+        try
+          let (field_annots, annot) = extract_field_annots annot in
+          let ast = parse_pair_substr str ~len 0 in
+          let field_annots_pos = pappaiir_annots_pos ast field_annots in
+          let rec parse p (depth, acc) =
+            match p with
+            | P (i, left, right) ->
+                let annot =
+                  match (i, IntMap.find i field_annots_pos) with
+                  | (0, None) ->
+                      annot
+                  | (_, None) ->
+                      []
+                  | (0, Some ([], cdr_annot)) ->
+                      ("%" :: cdr_annot) @ annot
+                  | (_, Some ([], cdr_annot)) ->
+                      "%" :: cdr_annot
+                  | (0, Some (car_annot, cdr_annot)) ->
+                      car_annot @ cdr_annot @ annot
+                  | (_, Some (car_annot, cdr_annot)) ->
+                      car_annot @ cdr_annot
+                in
+                let acc =
+                  if depth = 0 then Prim (loc, "PAIR", [], annot) :: acc
+                  else
+                    dip ~loc depth (Seq (loc, [Prim (loc, "PAIR", [], annot)]))
+                    :: acc
+                in
+                (depth, acc) |> parse left |> parse right
+            | A | I ->
+                (depth + 1, acc)
+          in
+          let (_, expanded) = parse ast (0, []) in
+          ( match args with
+          | [] ->
+              ok ()
+          | _ :: _ ->
+              error (Invalid_arity (str, List.length args, 0)) )
+          >>? fun () -> ok (Some (Seq (loc, expanded)))
+        with Not_a_pair -> ok None
+      else ok None
+  | _ ->
+      ok None
+
+let expand_unpappaiir original =
+  match original with
+  | Prim (loc, str, args, _annot) ->
+      let len = String.length str in
+      if
+        len > 6
+        && String.sub str 0 3 = "UNP"
+        && str.[len - 1] = 'R'
+        && check_letters str 3 (len - 2) (function
+               | 'P' | 'A' | 'I' ->
+                   true
+               | _ ->
+                   false)
+      then
+        try
+          let unpair = Prim (loc, "UNPAIR", [], []) in
+          let ast = parse_pair_substr str ~len 2 in
+          let rec parse p (depth, acc) =
+            match p with
+            | P (_i, left, right) ->
+                let acc =
+                  if depth = 0 then unpair :: acc
+                  else dip ~loc depth (Seq (loc, [unpair])) :: acc
+                in
+                (depth, acc) |> parse left |> parse right
+            | A | I ->
+                (depth + 1, acc)
+          in
+          let (_, rev_expanded) = parse ast (0, []) in
+          let expanded = Seq (loc, List.rev rev_expanded) in
+          ( match args with
+          | [] ->
+              ok ()
+          | _ :: _ ->
+              error (Invalid_arity (str, List.length args, 0)) )
+          >>? fun () -> ok (Some expanded)
+        with Not_a_pair -> ok None
+      else ok None
+  | _ ->
+      ok None
+
+exception Not_a_dup
+
+let expand_deprecated_duuuuup original =
+  (* transparently expands deprecated macro [DU...UP] to [{ DUP n }] *)
+  match original with
+  | Prim (loc, str, args, annot) ->
+      let len = String.length str in
+      if
+        len > 3
+        && str.[0] = 'D'
+        && str.[len - 1] = 'P'
+        && check_letters str 1 (len - 2) (( = ) 'U')
+      then
+        ( match args with
+        | [] ->
+            ok ()
+        | _ :: _ ->
+            error (Invalid_arity (str, List.length args, 0)) )
+        >>? fun () ->
+        try
+          let rec parse i =
+            if i = 1 then
+              Prim (loc, "DUP", [Int (loc, Z.of_int (len - 2))], annot)
+            else if str.[i] = 'U' then parse (i - 1)
+            else raise_notrace Not_a_dup
+          in
+          ok (Some (parse (len - 2)))
+        with Not_a_dup -> ok None
+      else ok None
+  | _ ->
+      ok None
+
+let expand_compare original =
+  let cmp loc is annot =
+    let is =
+      match List.rev_map (fun i -> Prim (loc, i, [], [])) is with
+      | Prim (loc, i, args, _) :: r ->
+          List.rev (Prim (loc, i, args, annot) :: r)
+      | is ->
+          List.rev is
+    in
+    ok (Some (Seq (loc, is)))
+  in
+  let ifcmp loc is l r annot =
+    let is =
+      List.map (fun i -> Prim (loc, i, [], [])) is
+      @ [Prim (loc, "IF", [l; r], annot)]
+    in
+    ok (Some (Seq (loc, is)))
+  in
+  match original with
+  | Prim (loc, "CMPEQ", [], annot) ->
+      cmp loc ["COMPARE"; "EQ"] annot
+  | Prim (loc, "CMPNEQ", [], annot) ->
+      cmp loc ["COMPARE"; "NEQ"] annot
+  | Prim (loc, "CMPLT", [], annot) ->
+      cmp loc ["COMPARE"; "LT"] annot
+  | Prim (loc, "CMPGT", [], annot) ->
+      cmp loc ["COMPARE"; "GT"] annot
+  | Prim (loc, "CMPLE", [], annot) ->
+      cmp loc ["COMPARE"; "LE"] annot
+  | Prim (loc, "CMPGE", [], annot) ->
+      cmp loc ["COMPARE"; "GE"] annot
+  | Prim
+      ( _,
+        (("CMPEQ" | "CMPNEQ" | "CMPLT" | "CMPGT" | "CMPLE" | "CMPGE") as str),
+        args,
+        [] ) ->
+      error (Invalid_arity (str, List.length args, 0))
+  | Prim (loc, "IFCMPEQ", [l; r], annot) ->
+      ifcmp loc ["COMPARE"; "EQ"] l r annot
+  | Prim (loc, "IFCMPNEQ", [l; r], annot) ->
+      ifcmp loc ["COMPARE"; "NEQ"] l r annot
+  | Prim (loc, "IFCMPLT", [l; r], annot) ->
+      ifcmp loc ["COMPARE"; "LT"] l r annot
+  | Prim (loc, "IFCMPGT", [l; r], annot) ->
+      ifcmp loc ["COMPARE"; "GT"] l r annot
+  | Prim (loc, "IFCMPLE", [l; r], annot) ->
+      ifcmp loc ["COMPARE"; "LE"] l r annot
+  | Prim (loc, "IFCMPGE", [l; r], annot) ->
+      ifcmp loc ["COMPARE"; "GE"] l r annot
+  | Prim (loc, "IFEQ", [l; r], annot) ->
+      ifcmp loc ["EQ"] l r annot
+  | Prim (loc, "IFNEQ", [l; r], annot) ->
+      ifcmp loc ["NEQ"] l r annot
+  | Prim (loc, "IFLT", [l; r], annot) ->
+      ifcmp loc ["LT"] l r annot
+  | Prim (loc, "IFGT", [l; r], annot) ->
+      ifcmp loc ["GT"] l r annot
+  | Prim (loc, "IFLE", [l; r], annot) ->
+      ifcmp loc ["LE"] l r annot
+  | Prim (loc, "IFGE", [l; r], annot) ->
+      ifcmp loc ["GE"] l r annot
+  | Prim
+      ( _,
+        ( ( "IFCMPEQ"
+          | "IFCMPNEQ"
+          | "IFCMPLT"
+          | "IFCMPGT"
+          | "IFCMPLE"
+          | "IFCMPGE"
+          | "IFEQ"
+          | "IFNEQ"
+          | "IFLT"
+          | "IFGT"
+          | "IFLE"
+          | "IFGE" ) as str ),
+        args,
+        [] ) ->
+      error (Invalid_arity (str, List.length args, 2))
+  | Prim
+      ( _,
+        ( ( "IFCMPEQ"
+          | "IFCMPNEQ"
+          | "IFCMPLT"
+          | "IFCMPGT"
+          | "IFCMPLE"
+          | "IFCMPGE"
+          | "IFEQ"
+          | "IFNEQ"
+          | "IFLT"
+          | "IFGT"
+          | "IFLE"
+          | "IFGE" ) as str ),
+        [],
+        _ :: _ ) ->
+      error (Unexpected_macro_annotation str)
+  | _ ->
+      ok None
+
+let expand_asserts original =
+  let may_rename loc = function
+    | [] ->
+        Seq (loc, [])
+    | annot ->
+        Seq (loc, [Prim (loc, "RENAME", [], annot)])
+  in
+  let fail_false ?(annot = []) loc =
+    [may_rename loc annot; Seq (loc, [Prim (loc, "FAIL", [], [])])]
+  in
+  let fail_true ?(annot = []) loc =
+    [Seq (loc, [Prim (loc, "FAIL", [], [])]); may_rename loc annot]
+  in
+  match original with
+  | Prim (loc, "ASSERT", [], []) ->
+      ok @@ Some (Seq (loc, [Prim (loc, "IF", fail_false loc, [])]))
+  | Prim (loc, "ASSERT_NONE", [], []) ->
+      ok @@ Some (Seq (loc, [Prim (loc, "IF_NONE", fail_false loc, [])]))
+  | Prim (loc, "ASSERT_SOME", [], annot) ->
+      ok @@ Some (Seq (loc, [Prim (loc, "IF_NONE", fail_true ~annot loc, [])]))
+  | Prim (loc, "ASSERT_LEFT", [], annot) ->
+      ok
+      @@ Some (Seq (loc, [Prim (loc, "IF_LEFT", fail_false ~annot loc, [])]))
+  | Prim (loc, "ASSERT_RIGHT", [], annot) ->
+      ok @@ Some (Seq (loc, [Prim (loc, "IF_LEFT", fail_true ~annot loc, [])]))
+  | Prim
+      ( _,
+        ( ( "ASSERT"
+          | "ASSERT_NONE"
+          | "ASSERT_SOME"
+          | "ASSERT_LEFT"
+          | "ASSERT_RIGHT" ) as str ),
+        args,
+        [] ) ->
+      error (Invalid_arity (str, List.length args, 0))
+  | Prim (_, (("ASSERT" | "ASSERT_NONE") as str), [], _ :: _) ->
+      error (Unexpected_macro_annotation str)
+  | Prim (loc, s, args, annot)
+    when String.(length s > 7 && equal (sub s 0 7) "ASSERT_") -> (
+      ( match args with
+      | [] ->
+          ok ()
+      | _ :: _ ->
+          error (Invalid_arity (s, List.length args, 0)) )
+      >>? fun () ->
+      ( match annot with
+      | _ :: _ ->
+          error (Unexpected_macro_annotation s)
+      | [] ->
+          ok () )
+      >>? fun () ->
+      let remaining = String.(sub s 7 (length s - 7)) in
+      let remaining_prim = Prim (loc, remaining, [], []) in
+      match remaining with
+      | "EQ" | "NEQ" | "LT" | "LE" | "GE" | "GT" ->
+          ok
+          @@ Some
+               (Seq
+                  (loc, [remaining_prim; Prim (loc, "IF", fail_false loc, [])]))
+      | _ -> (
+          expand_compare remaining_prim
+          >|? function
+          | None ->
+              None
+          | Some seq ->
+              Some (Seq (loc, [seq; Prim (loc, "IF", fail_false loc, [])])) ) )
+  | _ ->
+      ok None
+
+let expand_if_some = function
+  | Prim (loc, "IF_SOME", [right; left], annot) ->
+      ok @@ Some (Seq (loc, [Prim (loc, "IF_NONE", [left; right], annot)]))
+  | Prim (_, "IF_SOME", args, _annot) ->
+      error (Invalid_arity ("IF_SOME", List.length args, 2))
+  | _ ->
+      ok @@ None
+
+let expand_if_right = function
+  | Prim (loc, "IF_RIGHT", [right; left], annot) ->
+      ok @@ Some (Seq (loc, [Prim (loc, "IF_LEFT", [left; right], annot)]))
+  | Prim (_, "IF_RIGHT", args, _annot) ->
+      error (Invalid_arity ("IF_RIGHT", List.length args, 2))
+  | _ ->
+      ok @@ None
+
+let expand_fail = function
+  | Prim (loc, "FAIL", [], []) ->
+      ok
+      @@ Some
+           (Seq
+              ( loc,
+                [Prim (loc, "UNIT", [], []); Prim (loc, "FAILWITH", [], [])] ))
+  | _ ->
+      ok @@ None
+
+let expand original =
+  let rec try_expansions = function
+    | [] ->
+        ok @@ original
+    | expander :: expanders -> (
+        expander original
+        >>? function
+        | None -> try_expansions expanders | Some rewritten -> ok rewritten )
+  in
+  try_expansions
+    [ expand_carn;
+      expand_cdrn;
+      expand_caddadr;
+      expand_set_caddadr;
+      expand_map_caddadr;
+      expand_deprecated_dxiiivp;
+      (* expand_paaiair ; *)
+      expand_pappaiir;
+      (* expand_unpaaiair ; *)
+      expand_unpappaiir;
+      expand_deprecated_duuuuup;
+      expand_compare;
+      expand_asserts;
+      expand_if_some;
+      expand_if_right;
+      expand_fail ]
+
+let expand_rec expr =
+  let rec error_map (expanded, errors) f = function
+    | [] ->
+        (List.rev expanded, List.rev errors)
+    | hd :: tl ->
+        let (new_expanded, new_errors) = f hd in
+        error_map
+          (new_expanded :: expanded, List.rev_append new_errors errors)
+          f
+          tl
+  in
+  let error_map = error_map ([], []) in
+  let rec expand_rec expr =
+    match expand expr with
+    | Ok expanded -> (
+      match expanded with
+      | Seq (loc, items) ->
+          let (items, errors) = error_map expand_rec items in
+          (Seq (loc, items), errors)
+      | Prim (loc, name, args, annot) ->
+          let (args, errors) = error_map expand_rec args in
+          (Prim (loc, name, args, annot), errors)
+      | (Int _ | String _ | Bytes _) as atom ->
+          (atom, []) )
+    | Error errors ->
+        (expr, errors)
+  in
+  expand_rec expr
+
+let unexpand_carn_and_cdrn expanded =
+  match expanded with
+  | Seq (loc, [Prim (_, "GET", [Int (locn, n)], annot)]) ->
+      let (half, parity) = Z.ediv_rem n (Z.of_int 2) in
+      if Z.(parity = zero) then
+        Some (Prim (loc, "CDR", [Int (locn, half)], annot))
+      else Some (Prim (loc, "CAR", [Int (locn, half)], annot))
+  | _ ->
+      None
+
+let unexpand_caddadr expanded =
+  let rec rsteps acc = function
+    | [] ->
+        Some acc
+    | Prim (_, "CAR", [], []) :: rest ->
+        rsteps ("A" :: acc) rest
+    | Prim (_, "CDR", [], []) :: rest ->
+        rsteps ("D" :: acc) rest
+    | _ ->
+        None
+  in
+  match expanded with
+  | Seq (loc, (Prim (_, "CAR", [], []) :: _ as nodes))
+  | Seq (loc, (Prim (_, "CDR", [], []) :: _ as nodes)) -> (
+    match rsteps [] nodes with
+    | Some steps ->
+        let name = String.concat "" ("C" :: List.rev ("R" :: steps)) in
+        Some (Prim (loc, name, [], []))
+    | None ->
+        None )
+  | _ ->
+      None
+
+let unexpand_set_caddadr expanded =
+  let rec steps acc annots = function
+    | Seq
+        ( loc,
+          [ Prim (_, "CDR", [], _);
+            Prim (_, "SWAP", [], _);
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "A" :: acc, annots)
+    | Seq
+        ( loc,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "CAR", [], [field_annot]);
+            Prim (_, "DROP", [], []);
+            Prim (_, "CDR", [], _);
+            Prim (_, "SWAP", [], []);
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "A" :: acc, field_annot :: annots)
+    | Seq (loc, [Prim (_, "CAR", [], _); Prim (_, "PAIR", [], _)]) ->
+        Some (loc, "D" :: acc, annots)
+    | Seq
+        ( loc,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "CDR", [], [field_annot]);
+            Prim (_, "DROP", [], []);
+            Prim (_, "CAR", [], _);
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "D" :: acc, field_annot :: annots)
+    | Seq
+        ( _,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "DIP", [Seq (_, [Prim (_, "CAR", [], _); sub])], []);
+            Prim (_, "CDR", [], _);
+            Prim (_, "SWAP", [], []);
+            Prim (_, "PAIR", [], pair_annots) ] ) ->
+        let (_, pair_annots) = extract_field_annots pair_annots in
+        steps ("A" :: acc) (List.rev_append pair_annots annots) sub
+    | Seq
+        ( _,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], _); sub])], []);
+            Prim (_, "CAR", [], _);
+            Prim (_, "PAIR", [], pair_annots) ] ) ->
+        let (_, pair_annots) = extract_field_annots pair_annots in
+        steps ("D" :: acc) (List.rev_append pair_annots annots) sub
+    | _ ->
+        None
+  in
+  match steps [] [] expanded with
+  | Some (loc, steps, annots) ->
+      let name = String.concat "" ("SET_C" :: List.rev ("R" :: steps)) in
+      Some (Prim (loc, name, [], List.rev annots))
+  | None ->
+      None
+
+let unexpand_map_caddadr expanded =
+  let rec steps acc annots = function
+    | Seq
+        ( loc,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "CDR", [], _);
+            Prim (_, "SWAP", [], []);
+            Prim (_, "DIP", [Seq (_, [Prim (_, "CAR", [], []); code])], []);
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "A" :: acc, annots, code)
+    | Seq
+        ( loc,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "CDR", [], _);
+            Prim (_, "SWAP", [], []);
+            Prim
+              ( _,
+                "DIP",
+                [Seq (_, [Prim (_, "CAR", [], [field_annot]); code])],
+                [] );
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "A" :: acc, field_annot :: annots, code)
+    | Seq
+        ( loc,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "CDR", [], []);
+            code;
+            Prim (_, "SWAP", [], []);
+            Prim (_, "CAR", [], _);
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "D" :: acc, annots, code)
+    | Seq
+        ( loc,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "CDR", [], [field_annot]);
+            code;
+            Prim (_, "SWAP", [], []);
+            Prim (_, "CAR", [], _);
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "D" :: acc, field_annot :: annots, code)
+    | Seq
+        ( _,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "DIP", [Seq (_, [Prim (_, "CAR", [], _); sub])], []);
+            Prim (_, "CDR", [], _);
+            Prim (_, "SWAP", [], []);
+            Prim (_, "PAIR", [], pair_annots) ] ) ->
+        let (_, pair_annots) = extract_field_annots pair_annots in
+        steps ("A" :: acc) (List.rev_append pair_annots annots) sub
+    | Seq
+        ( _,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], []); sub])], []);
+            Prim (_, "CAR", [], []);
+            Prim (_, "PAIR", [], pair_annots) ] ) ->
+        let (_, pair_annots) = extract_field_annots pair_annots in
+        steps ("D" :: acc) (List.rev_append pair_annots annots) sub
+    | _ ->
+        None
+  in
+  match steps [] [] expanded with
+  | Some (loc, steps, annots, code) ->
+      let name = String.concat "" ("MAP_C" :: List.rev ("R" :: steps)) in
+      Some (Prim (loc, name, [code], List.rev annots))
+  | None ->
+      None
+
+let unexpand_deprecated_dxiiivp expanded =
+  (* transparently turn the old expansion of deprecated [DI...IP] to [DIP n] *)
+  match expanded with
+  | Seq
+      ( loc,
+        [Prim (_, "DIP", [(Seq (_, [Prim (_, "DIP", [_], [])]) as sub)], [])]
+      ) ->
+      let rec count acc = function
+        | Seq (_, [Prim (_, "DIP", [sub], [])]) ->
+            count (acc + 1) sub
+        | sub ->
+            (acc, sub)
+      in
+      let (depth, sub) = count 1 sub in
+      Some (Prim (loc, "DIP", [Int (loc, Z.of_int depth); sub], []))
+  | _ ->
+      None
+
+let unexpand_dupn expanded =
+  match expanded with
+  | Seq
+      ( loc,
+        [ Prim
+            (_, "DIP", [Int (_, np); Seq (_, [Prim (_, "DUP", [], annot)])], []);
+          Prim (_, "DIG", [Int (nloc, ng)], []) ] )
+    when Z.equal np (Z.pred ng) ->
+      Some (Prim (loc, "DUP", [Int (nloc, ng)], annot))
+  | _ ->
+      None
+
+let unexpand_deprecated_duuuuup expanded =
+  (* transparently turn the old expansion of deprecated [DU...UP] to [DUP n] *)
+  let rec expand n = function
+    | Seq (loc, [Prim (nloc, "DUP", [], annot)]) ->
+        if n = 1 then None
+        else Some (Prim (loc, "DUP", [Int (nloc, Z.of_int n)], annot))
+    | Seq (_, [Prim (_, "DIP", [expanded'], []); Prim (_, "SWAP", [], [])]) ->
+        expand (n + 1) expanded'
+    | _ ->
+        None
+  in
+  expand 1 expanded
+
+let rec normalize_pair_item ?(right = false) = function
+  | P (i, a, b) ->
+      P (i, normalize_pair_item a, normalize_pair_item ~right:true b)
+  | A when right ->
+      I
+  | A ->
+      A
+  | I ->
+      I
+
+let unexpand_pappaiir expanded =
+  match expanded with
+  | Seq (_, [Prim (_, "PAIR", [], [])]) ->
+      Some expanded
+  | Seq (loc, (_ :: _ as nodes)) -> (
+      let rec exec stack nodes =
+        match (nodes, stack) with
+        | ([], _) ->
+            stack
+        (* support new expansion using [DIP n] *)
+        | ( Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest,
+            a :: rstack )
+          when Z.to_int n > 1 ->
+            exec
+              ( a
+              :: exec
+                   rstack
+                   [ Prim
+                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
+                   ] )
+              rest
+        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, a :: rstack)
+          when Z.to_int n = 1 ->
+            exec (a :: exec rstack sub) rest
+        | (Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest, [])
+          when Z.to_int n > 1 ->
+            exec
+              ( A
+              :: exec
+                   []
+                   [ Prim
+                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
+                   ] )
+              rest
+        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, [])
+          when Z.to_int n = 1 ->
+            exec (A :: exec [] sub) rest
+        (* support old expansion using [DIP] *)
+        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, a :: rstack) ->
+            exec (a :: exec rstack sub) rest
+        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, []) ->
+            exec (A :: exec [] sub) rest
+        | (Prim (_, "PAIR", [], []) :: rest, a :: b :: rstack) ->
+            exec (P (0, a, b) :: rstack) rest
+        | (Prim (_, "PAIR", [], []) :: rest, [a]) ->
+            exec [P (0, a, I)] rest
+        | (Prim (_, "PAIR", [], []) :: rest, []) ->
+            exec [P (0, A, I)] rest
+        | _ ->
+            raise_notrace Not_a_pair
+      in
+      match exec [] nodes with
+      | [] ->
+          None
+      | res :: _ ->
+          let res = normalize_pair_item res in
+          let name = unparse_pair_item res in
+          Some (Prim (loc, name, [], []))
+      | exception Not_a_pair ->
+          None )
+  | _ ->
+      None
+
+let unexpand_unpappaiir expanded =
+  match expanded with
+  | Seq (loc, (_ :: _ as nodes)) -> (
+      let rec exec stack nodes =
+        match (nodes, stack) with
+        | ([], _) ->
+            stack
+        (* support new expansion using [DIP n] *)
+        | ( Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest,
+            a :: rstack )
+          when Z.to_int n > 1 ->
+            exec
+              ( a
+              :: exec
+                   rstack
+                   [ Prim
+                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
+                   ] )
+              rest
+        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, a :: rstack)
+          when Z.to_int n = 1 ->
+            exec (a :: exec rstack sub) rest
+        | (Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest, [])
+          when Z.to_int n > 1 ->
+            exec
+              ( A
+              :: exec
+                   []
+                   [ Prim
+                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
+                   ] )
+              rest
+        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, [])
+          when Z.to_int n = 1 ->
+            exec (A :: exec [] sub) rest
+        (* support old expansion using [DIP] *)
+        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, a :: rstack) ->
+            exec (a :: exec rstack sub) rest
+        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, []) ->
+            exec (A :: exec [] sub) rest
+        | ( Seq
+              ( _,
+                [ Prim (_, "DUP", [], []);
+                  Prim (_, "CAR", [], []);
+                  Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], [])])], []) ]
+              )
+            :: rest,
+            a :: b :: rstack ) ->
+            exec (P (0, a, b) :: rstack) rest
+        | ( Seq
+              ( _,
+                [ Prim (_, "DUP", [], []);
+                  Prim (_, "CAR", [], []);
+                  Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], [])])], []) ]
+              )
+            :: rest,
+            [a] ) ->
+            exec [P (0, a, I)] rest
+        | ( Seq
+              ( _,
+                [ Prim (_, "DUP", [], []);
+                  Prim (_, "CAR", [], []);
+                  Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], [])])], []) ]
+              )
+            :: rest,
+            [] ) ->
+            exec [P (0, A, I)] rest
+        | _ ->
+            raise_notrace Not_a_pair
+      in
+      match exec [] (List.rev nodes) with
+      | [] ->
+          None
+      | res :: _ ->
+          let res = normalize_pair_item res in
+          let name = "UN" ^ unparse_pair_item res in
+          Some (Prim (loc, name, [], []))
+      | exception Not_a_pair ->
+          None )
+  | _ ->
+      None
+
+let unexpand_compare expanded =
+  match expanded with
+  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "EQ", [], annot)]) ->
+      Some (Prim (loc, "CMPEQ", [], annot))
+  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "NEQ", [], annot)]) ->
+      Some (Prim (loc, "CMPNEQ", [], annot))
+  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "LT", [], annot)]) ->
+      Some (Prim (loc, "CMPLT", [], annot))
+  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "GT", [], annot)]) ->
+      Some (Prim (loc, "CMPGT", [], annot))
+  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "LE", [], annot)]) ->
+      Some (Prim (loc, "CMPLE", [], annot))
+  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "GE", [], annot)]) ->
+      Some (Prim (loc, "CMPGE", [], annot))
+  | Seq
+      ( loc,
+        [ Prim (_, "COMPARE", [], _);
+          Prim (_, "EQ", [], _);
+          Prim (_, "IF", args, annot) ] ) ->
+      Some (Prim (loc, "IFCMPEQ", args, annot))
+  | Seq
+      ( loc,
+        [ Prim (_, "COMPARE", [], _);
+          Prim (_, "NEQ", [], _);
+          Prim (_, "IF", args, annot) ] ) ->
+      Some (Prim (loc, "IFCMPNEQ", args, annot))
+  | Seq
+      ( loc,
+        [ Prim (_, "COMPARE", [], _);
+          Prim (_, "LT", [], _);
+          Prim (_, "IF", args, annot) ] ) ->
+      Some (Prim (loc, "IFCMPLT", args, annot))
+  | Seq
+      ( loc,
+        [ Prim (_, "COMPARE", [], _);
+          Prim (_, "GT", [], _);
+          Prim (_, "IF", args, annot) ] ) ->
+      Some (Prim (loc, "IFCMPGT", args, annot))
+  | Seq
+      ( loc,
+        [ Prim (_, "COMPARE", [], _);
+          Prim (_, "LE", [], _);
+          Prim (_, "IF", args, annot) ] ) ->
+      Some (Prim (loc, "IFCMPLE", args, annot))
+  | Seq
+      ( loc,
+        [ Prim (_, "COMPARE", [], _);
+          Prim (_, "GE", [], _);
+          Prim (_, "IF", args, annot) ] ) ->
+      Some (Prim (loc, "IFCMPGE", args, annot))
+  | Seq (loc, [Prim (_, "EQ", [], _); Prim (_, "IF", args, annot)]) ->
+      Some (Prim (loc, "IFEQ", args, annot))
+  | Seq (loc, [Prim (_, "NEQ", [], _); Prim (_, "IF", args, annot)]) ->
+      Some (Prim (loc, "IFNEQ", args, annot))
+  | Seq (loc, [Prim (_, "LT", [], _); Prim (_, "IF", args, annot)]) ->
+      Some (Prim (loc, "IFLT", args, annot))
+  | Seq (loc, [Prim (_, "GT", [], _); Prim (_, "IF", args, annot)]) ->
+      Some (Prim (loc, "IFGT", args, annot))
+  | Seq (loc, [Prim (_, "LE", [], _); Prim (_, "IF", args, annot)]) ->
+      Some (Prim (loc, "IFLE", args, annot))
+  | Seq (loc, [Prim (_, "GE", [], _); Prim (_, "IF", args, annot)]) ->
+      Some (Prim (loc, "IFGE", args, annot))
+  | _ ->
+      None
+
+let unexpand_asserts expanded =
+  match expanded with
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF",
+              [ Seq (_, []);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT", [], []))
+  | Seq
+      ( loc,
+        [ Seq (_, [Prim (_, "COMPARE", [], []); Prim (_, comparison, [], [])]);
+          Prim
+            ( _,
+              "IF",
+              [ Seq (_, []);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_CMP" ^ comparison, [], []))
+  | Seq
+      ( loc,
+        [ Prim (_, comparison, [], []);
+          Prim
+            ( _,
+              "IF",
+              [ Seq (_, []);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_" ^ comparison, [], []))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_NONE",
+              [ Seq (_, [Prim (_, "RENAME", [], annot)]);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_NONE", [], annot))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_NONE",
+              [ Seq (_, []);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_NONE", [], []))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_NONE",
+              [ Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] );
+                Seq (_, []) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_SOME", [], []))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_NONE",
+              [ Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] );
+                Seq (_, [Prim (_, "RENAME", [], annot)]) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_SOME", [], annot))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_LEFT",
+              [ Seq (_, []);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_LEFT", [], []))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_LEFT",
+              [ Seq (_, [Prim (_, "RENAME", [], annot)]);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_LEFT", [], annot))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_LEFT",
+              [ Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] );
+                Seq (_, []) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_RIGHT", [], []))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_LEFT",
+              [ Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] );
+                Seq (_, [Prim (_, "RENAME", [], annot)]) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_RIGHT", [], annot))
+  | _ ->
+      None
+
+let unexpand_if_some = function
+  | Seq (loc, [Prim (_, "IF_NONE", [left; right], annot)]) ->
+      Some (Prim (loc, "IF_SOME", [right; left], annot))
+  | _ ->
+      None
+
+let unexpand_if_right = function
+  | Seq (loc, [Prim (_, "IF_LEFT", [left; right], annot)]) ->
+      Some (Prim (loc, "IF_RIGHT", [right; left], annot))
+  | _ ->
+      None
+
+let unexpand_fail = function
+  | Seq (loc, [Prim (_, "UNIT", [], []); Prim (_, "FAILWITH", [], [])]) ->
+      Some (Prim (loc, "FAIL", [], []))
+  | _ ->
+      None
+
+let unexpand original =
+  let try_unexpansions unexpanders =
+    match
+      List.fold_left
+        (fun acc f ->
+          match acc with
+          | None ->
+              f original
+          | Some rewritten ->
+              Some rewritten)
+        None
+        unexpanders
+    with
+    | None ->
+        original
+    | Some rewritten ->
+        rewritten
+  in
+  try_unexpansions
+    [ unexpand_asserts;
+      unexpand_carn_and_cdrn;
+      unexpand_caddadr;
+      unexpand_set_caddadr;
+      unexpand_map_caddadr;
+      unexpand_deprecated_dxiiivp;
+      unexpand_pappaiir;
+      unexpand_unpappaiir;
+      unexpand_deprecated_duuuuup;
+      unexpand_dupn;
+      unexpand_compare;
+      unexpand_if_some;
+      unexpand_if_right;
+      unexpand_fail ]
+
+(*
+   If an argument of Prim is a sequence, we do not want to unexpand
+   its root in case the source already contains an expanded macro. In
+   which case unexpansion would remove surrounding braces and generate
+   ill-formed code.
+
+   For example, DIIP { DIP { DUP }; SWAP } is not unexpandable but
+   DIIP {{ DIP { DUP }; SWAP }} (note the double braces) is unexpanded
+   to DIIP { DUUP }.
+
+   unexpand_rec_but_root is the same as unexpand_rec but does not try
+   to unexpand at root *)
+
+let rec unexpand_rec expr = unexpand_rec_but_root (unexpand expr)
+
+and unexpand_rec_but_root = function
+  | Seq (loc, items) ->
+      Seq (loc, List.map unexpand_rec items)
+  | Prim (loc, name, args, annot) ->
+      Prim (loc, name, List.map unexpand_rec_but_root args, annot)
+  | (Int _ | String _ | Bytes _) as atom ->
+      atom
+
+let () =
+  let open Data_encoding in
+  register_error_kind
+    `Permanent
+    ~id:"michelson.macros.unexpected_annotation"
+    ~title:"Unexpected annotation"
+    ~description:
+      "A macro had an annotation, but no annotation was permitted on this \
+       macro."
+    ~pp:(fun ppf -> Format.fprintf ppf "Unexpected annotation on macro %s.")
+    (obj1 (req "macro_name" string))
+    (function Unexpected_macro_annotation str -> Some str | _ -> None)
+    (fun s -> Unexpected_macro_annotation s) ;
+  register_error_kind
+    `Permanent
+    ~id:"michelson.macros.sequence_expected"
+    ~title:"Macro expects a sequence"
+    ~description:"An macro expects a sequence, but a sequence was not provided"
+    ~pp:(fun ppf name ->
+      Format.fprintf
+        ppf
+        "Macro %s expects a sequence, but did not receive one."
+        name)
+    (obj1 (req "macro_name" string))
+    (function Sequence_expected name -> Some name | _ -> None)
+    (fun name -> Sequence_expected name) ;
+  register_error_kind
+    `Permanent
+    ~id:"michelson.macros.bas_arity"
+    ~title:"Wrong number of arguments to macro"
+    ~description:"A wrong number of arguments was provided to a macro"
+    ~pp:(fun ppf (name, got, exp) ->
+      Format.fprintf
+        ppf
+        "Macro %s expects %d arguments, was given %d."
+        name
+        exp
+        got)
+    (obj3
+       (req "macro_name" string)
+       (req "given_number_of_arguments" uint16)
+       (req "expected_number_of_arguments" uint16))
+    (function
+      | Invalid_arity (name, got, exp) -> Some (name, got, exp) | _ -> None)
+    (fun (name, got, exp) -> Invalid_arity (name, got, exp))
diff --git a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_macros.mli b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_macros.mli
new file mode 100644
index 000000000..352a59b00
--- /dev/null
+++ b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_macros.mli
@@ -0,0 +1,86 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Tezos_micheline
+
+type 'l node = ('l, string) Micheline.node
+
+type error += Unexpected_macro_annotation of string
+
+type error += Sequence_expected of string
+
+type error += Invalid_arity of string * int * int
+
+val expand : 'l node -> 'l node tzresult
+
+val expand_rec : 'l node -> 'l node * error list
+
+val expand_caddadr : 'l node -> 'l node option tzresult
+
+val expand_set_caddadr : 'l node -> 'l node option tzresult
+
+val expand_map_caddadr : 'l node -> 'l node option tzresult
+
+val expand_deprecated_dxiiivp : 'l node -> 'l node option tzresult
+
+val expand_pappaiir : 'l node -> 'l node option tzresult
+
+val expand_deprecated_duuuuup : 'l node -> 'l node option tzresult
+
+val expand_compare : 'l node -> 'l node option tzresult
+
+val expand_asserts : 'l node -> 'l node option tzresult
+
+val expand_unpappaiir : 'l node -> 'l node option tzresult
+
+val expand_if_some : 'l node -> 'l node option tzresult
+
+val expand_if_right : 'l node -> 'l node option tzresult
+
+val unexpand : 'l node -> 'l node
+
+val unexpand_rec : 'l node -> 'l node
+
+val unexpand_caddadr : 'l node -> 'l node option
+
+val unexpand_set_caddadr : 'l node -> 'l node option
+
+val unexpand_map_caddadr : 'l node -> 'l node option
+
+val unexpand_deprecated_dxiiivp : 'l node -> 'l node option
+
+val unexpand_pappaiir : 'l node -> 'l node option
+
+val unexpand_deprecated_duuuuup : 'l node -> 'l node option
+
+val unexpand_compare : 'l node -> 'l node option
+
+val unexpand_asserts : 'l node -> 'l node option
+
+val unexpand_unpappaiir : 'l node -> 'l node option
+
+val unexpand_if_some : 'l node -> 'l node option
+
+val unexpand_if_right : 'l node -> 'l node option
diff --git a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_parser.ml b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_parser.ml
new file mode 100644
index 000000000..a74caa039
--- /dev/null
+++ b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_parser.ml
@@ -0,0 +1,129 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+module Tezos_List = struct
+  let rev_map2 ~when_different_lengths f xs ys =
+    let open List in
+    let rec aux zs xs ys =
+      match (xs, ys) with
+      | ([], []) ->
+          Ok zs
+      | ([], _ :: _) | (_ :: _, []) ->
+          Error when_different_lengths
+      | (x :: xs, y :: ys) ->
+          let z = f x y in
+          (aux [@ocaml.tailcall]) (z :: zs) xs ys
+    in
+    aux [] xs ys
+
+  let map2 ~when_different_lengths f xs ys =
+    rev_map2 ~when_different_lengths f xs ys >|? List.rev
+end
+
+open Protocol
+open Tezos_micheline
+open Micheline_parser
+open Micheline
+
+type parsed = {
+  source : string;
+  unexpanded : string canonical;
+  expanded : Michelson_v1_primitives.prim canonical;
+  expansion_table : (int * (Micheline_parser.location * int list)) list;
+  unexpansion_table : (int * int) list;
+}
+
+let compare_parsed = Stdlib.compare
+
+(* Unexpanded toplevel expression should be a sequence *)
+let expand_all source ast errors =
+  let (unexpanded, loc_table) = extract_locations ast in
+  let (expanded, expansion_errors) =
+    Michelson_v1_macros.expand_rec (root unexpanded)
+  in
+  let (expanded, unexpansion_table) = extract_locations expanded in
+  let expansion_table =
+    let sorted =
+      List.sort (fun (_, a) (_, b) -> Stdlib.compare a b) unexpansion_table
+    in
+    let grouped =
+      let rec group = function
+        | (acc, []) ->
+            acc
+        | ([], (u, e) :: r) ->
+            group ([(e, [u])], r)
+        | (((pe, us) :: racc as acc), (u, e) :: r) ->
+            if e = pe then group ((e, u :: us) :: racc, r)
+            else group ((e, [u]) :: acc, r)
+      in
+      group ([], sorted)
+    in
+    match
+      Tezos_List.map2
+        ~when_different_lengths:()
+        (fun (l, ploc) (l', elocs) ->
+          assert (l = l') ;
+          (l, (ploc, elocs)))
+        (List.sort Stdlib.compare loc_table)
+        (List.sort Stdlib.compare grouped)
+    with
+    | Ok v ->
+        v
+    | Error () ->
+        invalid_arg "Michelson_v1_parser.expand_all"
+  in
+  match
+    Environment.wrap_error (Michelson_v1_primitives.prims_of_strings expanded)
+  with
+  | Ok expanded ->
+      ( {source; unexpanded; expanded; expansion_table; unexpansion_table},
+        errors @ expansion_errors )
+  | Error errs ->
+      ( {
+          source;
+          unexpanded;
+          expanded = Micheline.strip_locations (Seq ((), []));
+          expansion_table;
+          unexpansion_table;
+        },
+        errors @ expansion_errors @ errs )
+
+let parse_toplevel ?check source =
+  let (tokens, lexing_errors) = Micheline_parser.tokenize source in
+  let (asts, parsing_errors) = Micheline_parser.parse_toplevel ?check tokens in
+  let ast =
+    let start = min_point asts and stop = max_point asts in
+    Seq ({start; stop}, asts)
+  in
+  expand_all source ast (lexing_errors @ parsing_errors)
+
+let parse_expression ?check source =
+  let (tokens, lexing_errors) = Micheline_parser.tokenize source in
+  let (ast, parsing_errors) =
+    Micheline_parser.parse_expression ?check tokens
+  in
+  expand_all source ast (lexing_errors @ parsing_errors)
+
+let expand_all ~source ~original = expand_all source original []
diff --git a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_parser.mli b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_parser.mli
new file mode 100644
index 000000000..6aa296767
--- /dev/null
+++ b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_parser.mli
@@ -0,0 +1,55 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Protocol
+open Alpha_context
+open Tezos_micheline
+
+(** The result of parsing and expanding a Michelson V1 script or data. *)
+type parsed = {
+  source : string;  (** The original source code. *)
+  unexpanded : string Micheline.canonical;
+      (** Original expression with macros. *)
+  expanded : Script.expr;  (** Expression with macros fully expanded. *)
+  expansion_table : (int * (Micheline_parser.location * int list)) list;
+      (** Associates unexpanded nodes to their parsing locations and
+        the nodes expanded from it in the expanded expression. *)
+  unexpansion_table : (int * int) list;
+      (** Associates an expanded node to its source in the unexpanded
+        expression. *)
+}
+
+val compare_parsed : parsed -> parsed -> int
+
+val parse_toplevel :
+  ?check:bool -> string -> parsed Micheline_parser.parsing_result
+
+val parse_expression :
+  ?check:bool -> string -> parsed Micheline_parser.parsing_result
+
+val expand_all :
+  source:string ->
+  original:Micheline_parser.node ->
+  parsed Micheline_parser.parsing_result
diff --git a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_printer.ml b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_printer.ml
new file mode 100644
index 000000000..702bbb802
--- /dev/null
+++ b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_printer.ml
@@ -0,0 +1,269 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Protocol
+open Alpha_context
+open Tezos_micheline
+open Micheline
+open Micheline_printer
+
+let rec assoc ~equal k = function
+  | [] ->
+      None
+  | (kk, v) :: kvs ->
+      if equal k kk then Some v else assoc ~equal k kvs
+
+let hd = function x :: _ -> Some x | [] -> None
+
+let anon = {comment = None}
+
+let print_expr ppf expr =
+  expr |> Michelson_v1_primitives.strings_of_prims
+  |> Micheline.inject_locations (fun _ -> anon)
+  |> print_expr ppf
+
+let print_expr_unwrapped ppf expr =
+  expr |> Michelson_v1_primitives.strings_of_prims
+  |> Micheline.inject_locations (fun _ -> anon)
+  |> print_expr_unwrapped ppf
+
+let print_var_annots ppf = List.iter (Format.fprintf ppf "%s ")
+
+let print_annot_expr_unwrapped ppf (expr, annot) =
+  Format.fprintf ppf "%a%a" print_var_annots annot print_expr_unwrapped expr
+
+let print_stack ppf = function
+  | [] ->
+      Format.fprintf ppf "[]"
+  | more ->
+      Format.fprintf
+        ppf
+        "@[<hov 0>[ %a ]@]"
+        (Format.pp_print_list
+           ~pp_sep:(fun ppf () -> Format.fprintf ppf "@ : ")
+           print_annot_expr_unwrapped)
+        more
+
+let print_execution_trace ppf trace =
+  Format.pp_print_list
+    (fun ppf (loc, gas, stack) ->
+      Format.fprintf
+        ppf
+        "- @[<v 0>location: %d (remaining gas: %a)@,[ @[<v 0>%a ]@]@]"
+        loc
+        Gas.pp
+        gas
+        (Format.pp_print_list (fun ppf (e, annot) ->
+             Format.fprintf
+               ppf
+               "@[<v 0>%a  \t%s@]"
+               print_expr
+               e
+               (match annot with None -> "" | Some a -> a)))
+        stack)
+    ppf
+    trace
+
+let print_big_map_diff ppf lazy_storage_diff =
+  let diff =
+    Contract.Legacy_big_map_diff.of_lazy_storage_diff lazy_storage_diff
+  in
+  let pp_map ppf id =
+    if Compare.Z.(id < Z.zero) then
+      Format.fprintf ppf "temp(%s)" (Z.to_string (Z.neg id))
+    else Format.fprintf ppf "map(%s)" (Z.to_string id)
+  in
+  Format.fprintf
+    ppf
+    "@[<v 0>%a@]"
+    (Format.pp_print_list ~pp_sep:Format.pp_print_space (fun ppf ->
+       function
+       | Contract.Legacy_big_map_diff.Clear id ->
+           Format.fprintf ppf "Clear %a" pp_map id
+       | Contract.Legacy_big_map_diff.Alloc {big_map; key_type; value_type} ->
+           Format.fprintf
+             ppf
+             "New %a of type (big_map %a %a)"
+             pp_map
+             big_map
+             print_expr
+             key_type
+             print_expr
+             value_type
+       | Contract.Legacy_big_map_diff.Copy {src; dst} ->
+           Format.fprintf ppf "Copy %a to %a" pp_map src pp_map dst
+       | Contract.Legacy_big_map_diff.Update {big_map; diff_key; diff_value; _}
+         ->
+           Format.fprintf
+             ppf
+             "%s %a[%a]%a"
+             (match diff_value with None -> "Unset" | Some _ -> "Set")
+             pp_map
+             big_map
+             print_expr
+             diff_key
+             (fun ppf -> function None -> () | Some x ->
+                   Format.fprintf ppf " to %a" print_expr x)
+             diff_value))
+    (diff :> Contract.Legacy_big_map_diff.item list)
+
+let inject_types type_map parsed =
+  let rec inject_expr = function
+    | Seq (loc, items) ->
+        Seq (inject_loc `before loc, List.map inject_expr items)
+    | Prim (loc, name, items, annot) ->
+        Prim (inject_loc `after loc, name, List.map inject_expr items, annot)
+    | Int (loc, value) ->
+        Int (inject_loc `after loc, value)
+    | String (loc, value) ->
+        String (inject_loc `after loc, value)
+    | Bytes (loc, value) ->
+        Bytes (inject_loc `after loc, value)
+  and inject_loc which loc =
+    let comment =
+      let ( >?? ) = Option.bind in
+      assoc
+        ~equal:Int.equal
+        loc
+        parsed.Michelson_v1_parser.expansion_table
+      >?? fun (_, locs) ->
+      let locs = List.sort compare locs in
+      hd locs
+      >?? fun head_loc ->
+      assoc ~equal:Int.equal head_loc type_map
+      >?? fun (bef, aft) ->
+      let stack = match which with `before -> bef | `after -> aft in
+      Some (Format.asprintf "%a" print_stack stack)
+    in
+    {comment}
+  in
+  inject_expr (root parsed.unexpanded)
+
+let unparse ?type_map parse expanded =
+  let source =
+    match type_map with
+    | Some type_map ->
+        let (unexpanded, unexpansion_table) =
+          expanded |> Michelson_v1_primitives.strings_of_prims |> root
+          |> Michelson_v1_macros.unexpand_rec |> Micheline.extract_locations
+        in
+        let rec inject_expr = function
+          | Seq (loc, items) ->
+              Seq (inject_loc `before loc, List.map inject_expr items)
+          | Prim (loc, name, items, annot) ->
+              Prim
+                (inject_loc `after loc, name, List.map inject_expr items, annot)
+          | Int (loc, value) ->
+              Int (inject_loc `after loc, value)
+          | String (loc, value) ->
+              String (inject_loc `after loc, value)
+          | Bytes (loc, value) ->
+              Bytes (inject_loc `after loc, value)
+        and inject_loc which loc =
+          let comment =
+            let ( >?? ) = Option.bind in
+            assoc ~equal:Int.equal loc unexpansion_table
+            >?? fun loc ->
+            assoc ~equal:Int.equal loc type_map
+            >?? fun (bef, aft) ->
+            let stack = match which with `before -> bef | `after -> aft in
+            Some (Format.asprintf "%a" print_stack stack)
+          in
+          {comment}
+        in
+        unexpanded |> root |> inject_expr
+        |> Format.asprintf "%a" Micheline_printer.print_expr
+    | None ->
+        expanded |> Michelson_v1_primitives.strings_of_prims |> root
+        |> Michelson_v1_macros.unexpand_rec |> Micheline.strip_locations
+        |> Micheline_printer.printable (fun n -> n)
+        |> Format.asprintf "%a" Micheline_printer.print_expr
+  in
+  match parse source with
+  | (res, []) ->
+      res
+  | (_, _ :: _) ->
+      Stdlib.failwith "Michelson_v1_printer.unparse"
+
+let unparse_toplevel ?type_map =
+  unparse ?type_map Michelson_v1_parser.parse_toplevel
+
+let unparse_expression = unparse Michelson_v1_parser.parse_expression
+
+let unparse_invalid expanded =
+  let source =
+    expanded |> root |> Michelson_v1_macros.unexpand_rec
+    |> Micheline.strip_locations
+    |> Micheline_printer.printable (fun n -> n)
+    |> Format.asprintf "%a" Micheline_printer.print_expr_unwrapped
+  in
+  fst (Michelson_v1_parser.parse_toplevel source)
+
+let ocaml_constructor_of_prim prim =
+  (* Assuming all the prim constructor prefixes match the
+     [[Michelson_v1_primitives.namespace]]. *)
+  let prefix =
+    Michelson_v1_primitives.(namespace prim |> string_of_namespace)
+  in
+  Format.asprintf "%s_%s" prefix @@ Michelson_v1_primitives.string_of_prim prim
+
+let micheline_string_of_expression ~zero_loc expression =
+  let string_of_list : string list -> string =
+   fun xs -> String.concat "; " xs |> Format.asprintf "[%s]"
+  in
+  let show_loc loc = if zero_loc then 0 else loc in
+  let rec string_of_node = function
+    | Int (loc, i) ->
+        let z =
+          match Z.to_int i with
+          | 0 ->
+              "Z.zero"
+          | 1 ->
+              "Z.one"
+          | i ->
+              Format.asprintf "Z.of_int %d" i
+        in
+        Format.asprintf "Int (%d, %s)" (show_loc loc) z
+    | String (loc, s) ->
+        Format.asprintf "String (%d, \"%s\")" (show_loc loc) s
+    | Bytes (loc, b) ->
+        Format.asprintf
+          "Bytes (%d, Bytes.of_string \"%s\")"
+          (show_loc loc)
+          Bytes.(escaped b |> to_string)
+    | Prim (loc, prim, nodes, annot) ->
+        Format.asprintf
+          "Prim (%d, %s, %s, %s)"
+          (show_loc loc)
+          (ocaml_constructor_of_prim prim)
+          (string_of_list @@ List.map string_of_node nodes)
+          (string_of_list @@ List.map (Format.asprintf "\"%s\"") annot)
+    | Seq (loc, nodes) ->
+        Format.asprintf
+          "Seq (%d, %s)"
+          (show_loc loc)
+          (string_of_list @@ List.map string_of_node nodes)
+  in
+  string_of_node (root expression)
diff --git a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_printer.mli b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_printer.mli
new file mode 100644
index 000000000..07cb29ae8
--- /dev/null
+++ b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_printer.mli
@@ -0,0 +1,65 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Protocol
+open Alpha_context
+open Tezos_micheline
+
+val print_expr : Format.formatter -> Script_repr.expr -> unit
+
+val print_expr_unwrapped : Format.formatter -> Script_repr.expr -> unit
+
+val print_execution_trace :
+  Format.formatter ->
+  (Script.location * Gas.t * (Script.expr * string option) list) list ->
+  unit
+
+val print_big_map_diff : Format.formatter -> Lazy_storage.diffs -> unit
+
+(** Insert the type map returned by the typechecker as comments in a
+    printable Micheline AST. *)
+val inject_types :
+  Script_tc_errors.type_map ->
+  Michelson_v1_parser.parsed ->
+  Micheline_printer.node
+
+(** Unexpand the macros and produce the result of parsing an
+    intermediate pretty printed source. Useful when working with
+    contracts extracted from the blockchain and not local files. *)
+val unparse_toplevel :
+  ?type_map:Script_tc_errors.type_map ->
+  Script.expr ->
+  Michelson_v1_parser.parsed
+
+val unparse_expression : Script.expr -> Michelson_v1_parser.parsed
+
+(** Unexpand the macros and produce the result of parsing an
+    intermediate pretty printed source. Works on generic trees,for
+    programs that fail to be converted to a specific script version. *)
+val unparse_invalid : string Micheline.canonical -> Michelson_v1_parser.parsed
+
+val ocaml_constructor_of_prim : Michelson_v1_primitives.prim -> string
+
+val micheline_string_of_expression : zero_loc:bool -> Script.expr -> string
diff --git a/vendors/ligo-utils/proto-alpha-utils/dune b/vendors/ligo-utils/proto-alpha-utils/dune
index a1f0e7bcd..1323bd20e 100644
--- a/vendors/ligo-utils/proto-alpha-utils/dune
+++ b/vendors/ligo-utils/proto-alpha-utils/dune
@@ -2,11 +2,12 @@
   (name proto_alpha_utils)
   (public_name proto-alpha-utils)
   (libraries
-    tezos-error-monad
+    tezos-base
     tezos-stdlib-unix
     tezos-protocol-008-PtEdo2Zk
     tezos-protocol-008-PtEdo2Zk-parameters
-    tezos-client-008-PtEdo2Zk
+    tezos-protocol-environment
+    ;tezos-client-008-PtEdo2Zk
     tezos-memory-proto-alpha
     data-encoding
     simple-utils
diff --git a/vendors/ligo-utils/proto-alpha-utils/michelson_v1_macros.ml b/vendors/ligo-utils/proto-alpha-utils/michelson_v1_macros.ml
new file mode 100644
index 000000000..06100482a
--- /dev/null
+++ b/vendors/ligo-utils/proto-alpha-utils/michelson_v1_macros.ml
@@ -0,0 +1,1543 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(* Copyright (c) 2019 Nomadic Labs <contact@nomadic-labs.com>                *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Tezos_micheline
+open Micheline
+open Tezos_base__TzPervasives
+module IntMap = Map.Make (Compare.Int)
+
+type 'l node = ('l, string) Micheline.node
+
+type error += Unexpected_macro_annotation of string
+
+type error += Sequence_expected of string
+
+type error += Invalid_arity of string * int * int
+
+let rec check_letters str i j f =
+  i > j || (f str.[i] && check_letters str (i + 1) j f)
+
+let expand_caddadr original =
+  match original with
+  | Prim (loc, str, args, annot) ->
+      let len = String.length str in
+      if
+        len > 3
+        && str.[0] = 'C'
+        && str.[len - 1] = 'R'
+        && check_letters str 1 (len - 2) (function
+               | 'A' | 'D' ->
+                   true
+               | _ ->
+                   false)
+      then
+        ( match args with
+        | [] ->
+            ok ()
+        | _ :: _ ->
+            error (Invalid_arity (str, List.length args, 0)) )
+        >>? fun () ->
+        let path_annot =
+          List.filter (function "@%" | "@%%" -> true | _ -> false) annot
+        in
+        let rec parse i acc =
+          if i = 0 then Seq (loc, acc)
+          else
+            let annot = if i = len - 2 then annot else path_annot in
+            match str.[i] with
+            | 'A' ->
+                parse (i - 1) (Prim (loc, "CAR", [], annot) :: acc)
+            | 'D' ->
+                parse (i - 1) (Prim (loc, "CDR", [], annot) :: acc)
+            | _ ->
+                assert false
+        in
+        ok (Some (parse (len - 2) []))
+      else ok None
+  | _ ->
+      ok None
+
+let expand_carn original =
+  match original with
+  | Prim (loc, "CAR", [Int (loc2, n)], annot) ->
+      ok
+        (Some
+           (Seq
+              ( loc,
+                [ Prim
+                    ( loc,
+                      "GET",
+                      [Int (loc2, Z.(of_int 1 + (n * of_int 2)))],
+                      annot ) ] )))
+  | _ ->
+      ok None
+
+let expand_cdrn original =
+  match original with
+  | Prim (loc, "CDR", [Int (loc2, n)], annot) ->
+      ok
+        (Some
+           (Seq
+              (loc, [Prim (loc, "GET", [Int (loc2, Z.(n * of_int 2))], annot)])))
+  | _ ->
+      ok None
+
+let extract_field_annots annot =
+  List.partition
+    (fun a ->
+      match a.[0] with
+      | '%' ->
+          true
+      | _ ->
+          false
+      | exception Invalid_argument _ ->
+          false)
+    annot
+
+let expand_set_caddadr original =
+  match original with
+  | Prim (loc, str, args, annot) ->
+      let len = String.length str in
+      if
+        len >= 7
+        && String.sub str 0 5 = "SET_C"
+        && str.[len - 1] = 'R'
+        && check_letters str 5 (len - 2) (function
+               | 'A' | 'D' ->
+                   true
+               | _ ->
+                   false)
+      then
+        ( match args with
+        | [] ->
+            ok ()
+        | _ :: _ ->
+            error (Invalid_arity (str, List.length args, 0)) )
+        >>? fun () ->
+        ( match extract_field_annots annot with
+        | ([], annot) ->
+            ok (None, annot)
+        | ([f], annot) ->
+            ok (Some f, annot)
+        | (_, _) ->
+            error (Unexpected_macro_annotation str) )
+        >>? fun (field_annot, annot) ->
+        let rec parse i acc =
+          if i = 4 then acc
+          else
+            let annot = if i = 5 then annot else [] in
+            match str.[i] with
+            | 'A' ->
+                let acc =
+                  Seq
+                    ( loc,
+                      [ Prim (loc, "DUP", [], []);
+                        Prim
+                          ( loc,
+                            "DIP",
+                            [Seq (loc, [Prim (loc, "CAR", [], ["@%%"]); acc])],
+                            [] );
+                        Prim (loc, "CDR", [], ["@%%"]);
+                        Prim (loc, "SWAP", [], []);
+                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
+                in
+                parse (i - 1) acc
+            | 'D' ->
+                let acc =
+                  Seq
+                    ( loc,
+                      [ Prim (loc, "DUP", [], []);
+                        Prim
+                          ( loc,
+                            "DIP",
+                            [Seq (loc, [Prim (loc, "CDR", [], ["@%%"]); acc])],
+                            [] );
+                        Prim (loc, "CAR", [], ["@%%"]);
+                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
+                in
+                parse (i - 1) acc
+            | _ ->
+                assert false
+        in
+        match str.[len - 2] with
+        | 'A' ->
+            let access_check =
+              match field_annot with
+              | None ->
+                  []
+              | Some f ->
+                  [ Prim (loc, "DUP", [], []);
+                    Prim (loc, "CAR", [], [f]);
+                    Prim (loc, "DROP", [], []) ]
+            in
+            let encoding =
+              [Prim (loc, "CDR", [], ["@%%"]); Prim (loc, "SWAP", [], [])]
+            in
+            let pair =
+              [ Prim
+                  ( loc,
+                    "PAIR",
+                    [],
+                    [Option.value field_annot ~default:"%"; "%@"] ) ]
+            in
+            let init = Seq (loc, access_check @ encoding @ pair) in
+            ok (Some (parse (len - 3) init))
+        | 'D' ->
+            let access_check =
+              match field_annot with
+              | None ->
+                  []
+              | Some f ->
+                  [ Prim (loc, "DUP", [], []);
+                    Prim (loc, "CDR", [], [f]);
+                    Prim (loc, "DROP", [], []) ]
+            in
+            let encoding = [Prim (loc, "CAR", [], ["@%%"])] in
+            let pair =
+              [ Prim
+                  ( loc,
+                    "PAIR",
+                    [],
+                    ["%@"; Option.value field_annot ~default:"%"] ) ]
+            in
+            let init = Seq (loc, access_check @ encoding @ pair) in
+            ok (Some (parse (len - 3) init))
+        | _ ->
+            assert false
+      else ok None
+  | _ ->
+      ok None
+
+let expand_map_caddadr original =
+  match original with
+  | Prim (loc, str, args, annot) ->
+      let len = String.length str in
+      if
+        len >= 7
+        && String.sub str 0 5 = "MAP_C"
+        && str.[len - 1] = 'R'
+        && check_letters str 5 (len - 2) (function
+               | 'A' | 'D' ->
+                   true
+               | _ ->
+                   false)
+      then
+        ( match args with
+        | [(Seq _ as code)] ->
+            ok code
+        | [_] ->
+            error (Sequence_expected str)
+        | [] | _ :: _ :: _ ->
+            error (Invalid_arity (str, List.length args, 1)) )
+        >>? fun code ->
+        ( match extract_field_annots annot with
+        | ([], annot) ->
+            ok (None, annot)
+        | ([f], annot) ->
+            ok (Some f, annot)
+        | (_, _) ->
+            error (Unexpected_macro_annotation str) )
+        >>? fun (field_annot, annot) ->
+        let rec parse i acc =
+          if i = 4 then acc
+          else
+            let annot = if i = 5 then annot else [] in
+            match str.[i] with
+            | 'A' ->
+                let acc =
+                  Seq
+                    ( loc,
+                      [ Prim (loc, "DUP", [], []);
+                        Prim
+                          ( loc,
+                            "DIP",
+                            [Seq (loc, [Prim (loc, "CAR", [], ["@%%"]); acc])],
+                            [] );
+                        Prim (loc, "CDR", [], ["@%%"]);
+                        Prim (loc, "SWAP", [], []);
+                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
+                in
+                parse (i - 1) acc
+            | 'D' ->
+                let acc =
+                  Seq
+                    ( loc,
+                      [ Prim (loc, "DUP", [], []);
+                        Prim
+                          ( loc,
+                            "DIP",
+                            [Seq (loc, [Prim (loc, "CDR", [], ["@%%"]); acc])],
+                            [] );
+                        Prim (loc, "CAR", [], ["@%%"]);
+                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
+                in
+                parse (i - 1) acc
+            | _ ->
+                assert false
+        in
+        let cr_annot =
+          match field_annot with
+          | None ->
+              []
+          | Some f ->
+              ["@" ^ String.sub f 1 (String.length f - 1)]
+        in
+        match str.[len - 2] with
+        | 'A' ->
+            let init =
+              Seq
+                ( loc,
+                  [ Prim (loc, "DUP", [], []);
+                    Prim (loc, "CDR", [], ["@%%"]);
+                    Prim
+                      ( loc,
+                        "DIP",
+                        [Seq (loc, [Prim (loc, "CAR", [], cr_annot); code])],
+                        [] );
+                    Prim (loc, "SWAP", [], []);
+                    Prim
+                      ( loc,
+                        "PAIR",
+                        [],
+                        [Option.value field_annot ~default:"%"; "%@"] ) ] )
+            in
+            ok (Some (parse (len - 3) init))
+        | 'D' ->
+            let init =
+              Seq
+                ( loc,
+                  [ Prim (loc, "DUP", [], []);
+                    Prim (loc, "CDR", [], cr_annot);
+                    code;
+                    Prim (loc, "SWAP", [], []);
+                    Prim (loc, "CAR", [], ["@%%"]);
+                    Prim
+                      ( loc,
+                        "PAIR",
+                        [],
+                        ["%@"; Option.value field_annot ~default:"%"] ) ] )
+            in
+            ok (Some (parse (len - 3) init))
+        | _ ->
+            assert false
+      else ok None
+  | _ ->
+      ok None
+
+exception Not_a_roman
+
+let decimal_of_roman roman =
+  (* http://rosettacode.org/wiki/Roman_numerals/Decode#OCaml *)
+  let arabic = ref 0 in
+  let lastval = ref 0 in
+  for i = String.length roman - 1 downto 0 do
+    let n =
+      match roman.[i] with
+      | 'M' ->
+          1000
+      | 'D' ->
+          500
+      | 'C' ->
+          100
+      | 'L' ->
+          50
+      | 'X' ->
+          10
+      | 'V' ->
+          5
+      | 'I' ->
+          1
+      | _ ->
+          raise_notrace Not_a_roman
+    in
+    if Compare.Int.(n < !lastval) then arabic := !arabic - n
+    else arabic := !arabic + n ;
+    lastval := n
+  done ;
+  !arabic
+
+let dip ~loc ?(annot = []) depth instr =
+  assert (depth >= 0) ;
+  if depth = 1 then Prim (loc, "DIP", [instr], annot)
+  else Prim (loc, "DIP", [Int (loc, Z.of_int depth); instr], annot)
+
+let expand_deprecated_dxiiivp original =
+  (* transparently expands deprecated macro [DI...IP] to instruction [DIP n] *)
+  match original with
+  | Prim (loc, str, args, annot) ->
+      let len = String.length str in
+      if len > 3 && str.[0] = 'D' && str.[len - 1] = 'P' then
+        try
+          let depth = decimal_of_roman (String.sub str 1 (len - 2)) in
+          match args with
+          | [(Seq (_, _) as arg)] ->
+              ok @@ Some (dip ~loc ~annot depth arg)
+          | [_] ->
+              error (Sequence_expected str)
+          | [] | _ :: _ :: _ ->
+              error (Invalid_arity (str, List.length args, 1))
+        with Not_a_roman -> ok None
+      else ok None
+  | _ ->
+      ok None
+
+exception Not_a_pair
+
+type pair_item = A | I | P of int * pair_item * pair_item
+
+let parse_pair_substr str ~len start =
+  let rec parse ?left i =
+    if i = len - 1 then raise_notrace Not_a_pair
+    else if str.[i] = 'P' then
+      let (next_i, l) = parse ~left:true (i + 1) in
+      let (next_i, r) = parse ~left:false next_i in
+      (next_i, P (i, l, r))
+    else if str.[i] = 'A' && left = Some true then (i + 1, A)
+    else if str.[i] = 'I' && left <> Some true then (i + 1, I)
+    else raise_notrace Not_a_pair
+  in
+  let (last, ast) = parse start in
+  if last <> len - 1 then raise_notrace Not_a_pair else ast
+
+let unparse_pair_item ast =
+  let rec unparse ast acc =
+    match ast with
+    | P (_, l, r) ->
+        unparse r (unparse l ("P" :: acc))
+    | A ->
+        "A" :: acc
+    | I ->
+        "I" :: acc
+  in
+  List.rev ("R" :: unparse ast []) |> String.concat ""
+
+let pappaiir_annots_pos ast annot =
+  let rec find_annots_pos p_pos ast annots acc =
+    match (ast, annots) with
+    | (_, []) ->
+        (annots, acc)
+    | (P (i, left, right), _) ->
+        let (annots, acc) = find_annots_pos i left annots acc in
+        find_annots_pos i right annots acc
+    | (A, a :: annots) ->
+        let pos =
+          match IntMap.find p_pos acc with
+          | None ->
+              ([a], [])
+          | Some (_, cdr) ->
+              ([a], cdr)
+        in
+        (annots, IntMap.add p_pos pos acc)
+    | (I, a :: annots) ->
+        let pos =
+          match IntMap.find p_pos acc with
+          | None ->
+              ([], [a])
+          | Some (car, _) ->
+              (car, [a])
+        in
+        (annots, IntMap.add p_pos pos acc)
+  in
+  snd (find_annots_pos 0 ast annot IntMap.empty)
+
+let expand_pappaiir original =
+  match original with
+  | Prim (loc, str, args, annot) ->
+      let len = String.length str in
+      if
+        len > 4
+        && str.[0] = 'P'
+        && str.[len - 1] = 'R'
+        && check_letters str 1 (len - 2) (function
+               | 'P' | 'A' | 'I' ->
+                   true
+               | _ ->
+                   false)
+      then
+        try
+          let (field_annots, annot) = extract_field_annots annot in
+          let ast = parse_pair_substr str ~len 0 in
+          let field_annots_pos = pappaiir_annots_pos ast field_annots in
+          let rec parse p (depth, acc) =
+            match p with
+            | P (i, left, right) ->
+                let annot =
+                  match (i, IntMap.find i field_annots_pos) with
+                  | (0, None) ->
+                      annot
+                  | (_, None) ->
+                      []
+                  | (0, Some ([], cdr_annot)) ->
+                      ("%" :: cdr_annot) @ annot
+                  | (_, Some ([], cdr_annot)) ->
+                      "%" :: cdr_annot
+                  | (0, Some (car_annot, cdr_annot)) ->
+                      car_annot @ cdr_annot @ annot
+                  | (_, Some (car_annot, cdr_annot)) ->
+                      car_annot @ cdr_annot
+                in
+                let acc =
+                  if depth = 0 then Prim (loc, "PAIR", [], annot) :: acc
+                  else
+                    dip ~loc depth (Seq (loc, [Prim (loc, "PAIR", [], annot)]))
+                    :: acc
+                in
+                (depth, acc) |> parse left |> parse right
+            | A | I ->
+                (depth + 1, acc)
+          in
+          let (_, expanded) = parse ast (0, []) in
+          ( match args with
+          | [] ->
+              ok ()
+          | _ :: _ ->
+              error (Invalid_arity (str, List.length args, 0)) )
+          >>? fun () -> ok (Some (Seq (loc, expanded)))
+        with Not_a_pair -> ok None
+      else ok None
+  | _ ->
+      ok None
+
+let expand_unpappaiir original =
+  match original with
+  | Prim (loc, str, args, _annot) ->
+      let len = String.length str in
+      if
+        len > 6
+        && String.sub str 0 3 = "UNP"
+        && str.[len - 1] = 'R'
+        && check_letters str 3 (len - 2) (function
+               | 'P' | 'A' | 'I' ->
+                   true
+               | _ ->
+                   false)
+      then
+        try
+          let unpair = Prim (loc, "UNPAIR", [], []) in
+          let ast = parse_pair_substr str ~len 2 in
+          let rec parse p (depth, acc) =
+            match p with
+            | P (_i, left, right) ->
+                let acc =
+                  if depth = 0 then unpair :: acc
+                  else dip ~loc depth (Seq (loc, [unpair])) :: acc
+                in
+                (depth, acc) |> parse left |> parse right
+            | A | I ->
+                (depth + 1, acc)
+          in
+          let (_, rev_expanded) = parse ast (0, []) in
+          let expanded = Seq (loc, List.rev rev_expanded) in
+          ( match args with
+          | [] ->
+              ok ()
+          | _ :: _ ->
+              error (Invalid_arity (str, List.length args, 0)) )
+          >>? fun () -> ok (Some expanded)
+        with Not_a_pair -> ok None
+      else ok None
+  | _ ->
+      ok None
+
+exception Not_a_dup
+
+let expand_deprecated_duuuuup original =
+  (* transparently expands deprecated macro [DU...UP] to [{ DUP n }] *)
+  match original with
+  | Prim (loc, str, args, annot) ->
+      let len = String.length str in
+      if
+        len > 3
+        && str.[0] = 'D'
+        && str.[len - 1] = 'P'
+        && check_letters str 1 (len - 2) (( = ) 'U')
+      then
+        ( match args with
+        | [] ->
+            ok ()
+        | _ :: _ ->
+            error (Invalid_arity (str, List.length args, 0)) )
+        >>? fun () ->
+        try
+          let rec parse i =
+            if i = 1 then
+              Prim (loc, "DUP", [Int (loc, Z.of_int (len - 2))], annot)
+            else if str.[i] = 'U' then parse (i - 1)
+            else raise_notrace Not_a_dup
+          in
+          ok (Some (parse (len - 2)))
+        with Not_a_dup -> ok None
+      else ok None
+  | _ ->
+      ok None
+
+let expand_compare original =
+  let cmp loc is annot =
+    let is =
+      match List.rev_map (fun i -> Prim (loc, i, [], [])) is with
+      | Prim (loc, i, args, _) :: r ->
+          List.rev (Prim (loc, i, args, annot) :: r)
+      | is ->
+          List.rev is
+    in
+    ok (Some (Seq (loc, is)))
+  in
+  let ifcmp loc is l r annot =
+    let is =
+      List.map (fun i -> Prim (loc, i, [], [])) is
+      @ [Prim (loc, "IF", [l; r], annot)]
+    in
+    ok (Some (Seq (loc, is)))
+  in
+  match original with
+  | Prim (loc, "CMPEQ", [], annot) ->
+      cmp loc ["COMPARE"; "EQ"] annot
+  | Prim (loc, "CMPNEQ", [], annot) ->
+      cmp loc ["COMPARE"; "NEQ"] annot
+  | Prim (loc, "CMPLT", [], annot) ->
+      cmp loc ["COMPARE"; "LT"] annot
+  | Prim (loc, "CMPGT", [], annot) ->
+      cmp loc ["COMPARE"; "GT"] annot
+  | Prim (loc, "CMPLE", [], annot) ->
+      cmp loc ["COMPARE"; "LE"] annot
+  | Prim (loc, "CMPGE", [], annot) ->
+      cmp loc ["COMPARE"; "GE"] annot
+  | Prim
+      ( _,
+        (("CMPEQ" | "CMPNEQ" | "CMPLT" | "CMPGT" | "CMPLE" | "CMPGE") as str),
+        args,
+        [] ) ->
+      error (Invalid_arity (str, List.length args, 0))
+  | Prim (loc, "IFCMPEQ", [l; r], annot) ->
+      ifcmp loc ["COMPARE"; "EQ"] l r annot
+  | Prim (loc, "IFCMPNEQ", [l; r], annot) ->
+      ifcmp loc ["COMPARE"; "NEQ"] l r annot
+  | Prim (loc, "IFCMPLT", [l; r], annot) ->
+      ifcmp loc ["COMPARE"; "LT"] l r annot
+  | Prim (loc, "IFCMPGT", [l; r], annot) ->
+      ifcmp loc ["COMPARE"; "GT"] l r annot
+  | Prim (loc, "IFCMPLE", [l; r], annot) ->
+      ifcmp loc ["COMPARE"; "LE"] l r annot
+  | Prim (loc, "IFCMPGE", [l; r], annot) ->
+      ifcmp loc ["COMPARE"; "GE"] l r annot
+  | Prim (loc, "IFEQ", [l; r], annot) ->
+      ifcmp loc ["EQ"] l r annot
+  | Prim (loc, "IFNEQ", [l; r], annot) ->
+      ifcmp loc ["NEQ"] l r annot
+  | Prim (loc, "IFLT", [l; r], annot) ->
+      ifcmp loc ["LT"] l r annot
+  | Prim (loc, "IFGT", [l; r], annot) ->
+      ifcmp loc ["GT"] l r annot
+  | Prim (loc, "IFLE", [l; r], annot) ->
+      ifcmp loc ["LE"] l r annot
+  | Prim (loc, "IFGE", [l; r], annot) ->
+      ifcmp loc ["GE"] l r annot
+  | Prim
+      ( _,
+        ( ( "IFCMPEQ"
+          | "IFCMPNEQ"
+          | "IFCMPLT"
+          | "IFCMPGT"
+          | "IFCMPLE"
+          | "IFCMPGE"
+          | "IFEQ"
+          | "IFNEQ"
+          | "IFLT"
+          | "IFGT"
+          | "IFLE"
+          | "IFGE" ) as str ),
+        args,
+        [] ) ->
+      error (Invalid_arity (str, List.length args, 2))
+  | Prim
+      ( _,
+        ( ( "IFCMPEQ"
+          | "IFCMPNEQ"
+          | "IFCMPLT"
+          | "IFCMPGT"
+          | "IFCMPLE"
+          | "IFCMPGE"
+          | "IFEQ"
+          | "IFNEQ"
+          | "IFLT"
+          | "IFGT"
+          | "IFLE"
+          | "IFGE" ) as str ),
+        [],
+        _ :: _ ) ->
+      error (Unexpected_macro_annotation str)
+  | _ ->
+      ok None
+
+let expand_asserts original =
+  let may_rename loc = function
+    | [] ->
+        Seq (loc, [])
+    | annot ->
+        Seq (loc, [Prim (loc, "RENAME", [], annot)])
+  in
+  let fail_false ?(annot = []) loc =
+    [may_rename loc annot; Seq (loc, [Prim (loc, "FAIL", [], [])])]
+  in
+  let fail_true ?(annot = []) loc =
+    [Seq (loc, [Prim (loc, "FAIL", [], [])]); may_rename loc annot]
+  in
+  match original with
+  | Prim (loc, "ASSERT", [], []) ->
+      ok @@ Some (Seq (loc, [Prim (loc, "IF", fail_false loc, [])]))
+  | Prim (loc, "ASSERT_NONE", [], []) ->
+      ok @@ Some (Seq (loc, [Prim (loc, "IF_NONE", fail_false loc, [])]))
+  | Prim (loc, "ASSERT_SOME", [], annot) ->
+      ok @@ Some (Seq (loc, [Prim (loc, "IF_NONE", fail_true ~annot loc, [])]))
+  | Prim (loc, "ASSERT_LEFT", [], annot) ->
+      ok
+      @@ Some (Seq (loc, [Prim (loc, "IF_LEFT", fail_false ~annot loc, [])]))
+  | Prim (loc, "ASSERT_RIGHT", [], annot) ->
+      ok @@ Some (Seq (loc, [Prim (loc, "IF_LEFT", fail_true ~annot loc, [])]))
+  | Prim
+      ( _,
+        ( ( "ASSERT"
+          | "ASSERT_NONE"
+          | "ASSERT_SOME"
+          | "ASSERT_LEFT"
+          | "ASSERT_RIGHT" ) as str ),
+        args,
+        [] ) ->
+      error (Invalid_arity (str, List.length args, 0))
+  | Prim (_, (("ASSERT" | "ASSERT_NONE") as str), [], _ :: _) ->
+      error (Unexpected_macro_annotation str)
+  | Prim (loc, s, args, annot)
+    when String.(length s > 7 && equal (sub s 0 7) "ASSERT_") -> (
+      ( match args with
+      | [] ->
+          ok ()
+      | _ :: _ ->
+          error (Invalid_arity (s, List.length args, 0)) )
+      >>? fun () ->
+      ( match annot with
+      | _ :: _ ->
+          error (Unexpected_macro_annotation s)
+      | [] ->
+          ok () )
+      >>? fun () ->
+      let remaining = String.(sub s 7 (length s - 7)) in
+      let remaining_prim = Prim (loc, remaining, [], []) in
+      match remaining with
+      | "EQ" | "NEQ" | "LT" | "LE" | "GE" | "GT" ->
+          ok
+          @@ Some
+               (Seq
+                  (loc, [remaining_prim; Prim (loc, "IF", fail_false loc, [])]))
+      | _ -> (
+          expand_compare remaining_prim
+          >|? function
+          | None ->
+              None
+          | Some seq ->
+              Some (Seq (loc, [seq; Prim (loc, "IF", fail_false loc, [])])) ) )
+  | _ ->
+      ok None
+
+let expand_if_some = function
+  | Prim (loc, "IF_SOME", [right; left], annot) ->
+      ok @@ Some (Seq (loc, [Prim (loc, "IF_NONE", [left; right], annot)]))
+  | Prim (_, "IF_SOME", args, _annot) ->
+      error (Invalid_arity ("IF_SOME", List.length args, 2))
+  | _ ->
+      ok @@ None
+
+let expand_if_right = function
+  | Prim (loc, "IF_RIGHT", [right; left], annot) ->
+      ok @@ Some (Seq (loc, [Prim (loc, "IF_LEFT", [left; right], annot)]))
+  | Prim (_, "IF_RIGHT", args, _annot) ->
+      error (Invalid_arity ("IF_RIGHT", List.length args, 2))
+  | _ ->
+      ok @@ None
+
+let expand_fail = function
+  | Prim (loc, "FAIL", [], []) ->
+      ok
+      @@ Some
+           (Seq
+              ( loc,
+                [Prim (loc, "UNIT", [], []); Prim (loc, "FAILWITH", [], [])] ))
+  | _ ->
+      ok @@ None
+
+let expand original =
+  let rec try_expansions = function
+    | [] ->
+        ok @@ original
+    | expander :: expanders -> (
+        expander original
+        >>? function
+        | None -> try_expansions expanders | Some rewritten -> ok rewritten )
+  in
+  try_expansions
+    [ expand_carn;
+      expand_cdrn;
+      expand_caddadr;
+      expand_set_caddadr;
+      expand_map_caddadr;
+      expand_deprecated_dxiiivp;
+      (* expand_paaiair ; *)
+      expand_pappaiir;
+      (* expand_unpaaiair ; *)
+      expand_unpappaiir;
+      expand_deprecated_duuuuup;
+      expand_compare;
+      expand_asserts;
+      expand_if_some;
+      expand_if_right;
+      expand_fail ]
+
+let expand_rec expr =
+  let rec error_map (expanded, errors) f = function
+    | [] ->
+        (List.rev expanded, List.rev errors)
+    | hd :: tl ->
+        let (new_expanded, new_errors) = f hd in
+        error_map
+          (new_expanded :: expanded, List.rev_append new_errors errors)
+          f
+          tl
+  in
+  let error_map = error_map ([], []) in
+  let rec expand_rec expr =
+    match expand expr with
+    | Ok expanded -> (
+      match expanded with
+      | Seq (loc, items) ->
+          let (items, errors) = error_map expand_rec items in
+          (Seq (loc, items), errors)
+      | Prim (loc, name, args, annot) ->
+          let (args, errors) = error_map expand_rec args in
+          (Prim (loc, name, args, annot), errors)
+      | (Int _ | String _ | Bytes _) as atom ->
+          (atom, []) )
+    | Error errors ->
+        (expr, errors)
+  in
+  expand_rec expr
+
+let unexpand_carn_and_cdrn expanded =
+  match expanded with
+  | Seq (loc, [Prim (_, "GET", [Int (locn, n)], annot)]) ->
+      let (half, parity) = Z.ediv_rem n (Z.of_int 2) in
+      if Z.(parity = zero) then
+        Some (Prim (loc, "CDR", [Int (locn, half)], annot))
+      else Some (Prim (loc, "CAR", [Int (locn, half)], annot))
+  | _ ->
+      None
+
+let unexpand_caddadr expanded =
+  let rec rsteps acc = function
+    | [] ->
+        Some acc
+    | Prim (_, "CAR", [], []) :: rest ->
+        rsteps ("A" :: acc) rest
+    | Prim (_, "CDR", [], []) :: rest ->
+        rsteps ("D" :: acc) rest
+    | _ ->
+        None
+  in
+  match expanded with
+  | Seq (loc, (Prim (_, "CAR", [], []) :: _ as nodes))
+  | Seq (loc, (Prim (_, "CDR", [], []) :: _ as nodes)) -> (
+    match rsteps [] nodes with
+    | Some steps ->
+        let name = String.concat "" ("C" :: List.rev ("R" :: steps)) in
+        Some (Prim (loc, name, [], []))
+    | None ->
+        None )
+  | _ ->
+      None
+
+let unexpand_set_caddadr expanded =
+  let rec steps acc annots = function
+    | Seq
+        ( loc,
+          [ Prim (_, "CDR", [], _);
+            Prim (_, "SWAP", [], _);
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "A" :: acc, annots)
+    | Seq
+        ( loc,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "CAR", [], [field_annot]);
+            Prim (_, "DROP", [], []);
+            Prim (_, "CDR", [], _);
+            Prim (_, "SWAP", [], []);
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "A" :: acc, field_annot :: annots)
+    | Seq (loc, [Prim (_, "CAR", [], _); Prim (_, "PAIR", [], _)]) ->
+        Some (loc, "D" :: acc, annots)
+    | Seq
+        ( loc,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "CDR", [], [field_annot]);
+            Prim (_, "DROP", [], []);
+            Prim (_, "CAR", [], _);
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "D" :: acc, field_annot :: annots)
+    | Seq
+        ( _,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "DIP", [Seq (_, [Prim (_, "CAR", [], _); sub])], []);
+            Prim (_, "CDR", [], _);
+            Prim (_, "SWAP", [], []);
+            Prim (_, "PAIR", [], pair_annots) ] ) ->
+        let (_, pair_annots) = extract_field_annots pair_annots in
+        steps ("A" :: acc) (List.rev_append pair_annots annots) sub
+    | Seq
+        ( _,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], _); sub])], []);
+            Prim (_, "CAR", [], _);
+            Prim (_, "PAIR", [], pair_annots) ] ) ->
+        let (_, pair_annots) = extract_field_annots pair_annots in
+        steps ("D" :: acc) (List.rev_append pair_annots annots) sub
+    | _ ->
+        None
+  in
+  match steps [] [] expanded with
+  | Some (loc, steps, annots) ->
+      let name = String.concat "" ("SET_C" :: List.rev ("R" :: steps)) in
+      Some (Prim (loc, name, [], List.rev annots))
+  | None ->
+      None
+
+let unexpand_map_caddadr expanded =
+  let rec steps acc annots = function
+    | Seq
+        ( loc,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "CDR", [], _);
+            Prim (_, "SWAP", [], []);
+            Prim (_, "DIP", [Seq (_, [Prim (_, "CAR", [], []); code])], []);
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "A" :: acc, annots, code)
+    | Seq
+        ( loc,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "CDR", [], _);
+            Prim (_, "SWAP", [], []);
+            Prim
+              ( _,
+                "DIP",
+                [Seq (_, [Prim (_, "CAR", [], [field_annot]); code])],
+                [] );
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "A" :: acc, field_annot :: annots, code)
+    | Seq
+        ( loc,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "CDR", [], []);
+            code;
+            Prim (_, "SWAP", [], []);
+            Prim (_, "CAR", [], _);
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "D" :: acc, annots, code)
+    | Seq
+        ( loc,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "CDR", [], [field_annot]);
+            code;
+            Prim (_, "SWAP", [], []);
+            Prim (_, "CAR", [], _);
+            Prim (_, "PAIR", [], _) ] ) ->
+        Some (loc, "D" :: acc, field_annot :: annots, code)
+    | Seq
+        ( _,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "DIP", [Seq (_, [Prim (_, "CAR", [], _); sub])], []);
+            Prim (_, "CDR", [], _);
+            Prim (_, "SWAP", [], []);
+            Prim (_, "PAIR", [], pair_annots) ] ) ->
+        let (_, pair_annots) = extract_field_annots pair_annots in
+        steps ("A" :: acc) (List.rev_append pair_annots annots) sub
+    | Seq
+        ( _,
+          [ Prim (_, "DUP", [], []);
+            Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], []); sub])], []);
+            Prim (_, "CAR", [], []);
+            Prim (_, "PAIR", [], pair_annots) ] ) ->
+        let (_, pair_annots) = extract_field_annots pair_annots in
+        steps ("D" :: acc) (List.rev_append pair_annots annots) sub
+    | _ ->
+        None
+  in
+  match steps [] [] expanded with
+  | Some (loc, steps, annots, code) ->
+      let name = String.concat "" ("MAP_C" :: List.rev ("R" :: steps)) in
+      Some (Prim (loc, name, [code], List.rev annots))
+  | None ->
+      None
+
+let unexpand_deprecated_dxiiivp expanded =
+  (* transparently turn the old expansion of deprecated [DI...IP] to [DIP n] *)
+  match expanded with
+  | Seq
+      ( loc,
+        [Prim (_, "DIP", [(Seq (_, [Prim (_, "DIP", [_], [])]) as sub)], [])]
+      ) ->
+      let rec count acc = function
+        | Seq (_, [Prim (_, "DIP", [sub], [])]) ->
+            count (acc + 1) sub
+        | sub ->
+            (acc, sub)
+      in
+      let (depth, sub) = count 1 sub in
+      Some (Prim (loc, "DIP", [Int (loc, Z.of_int depth); sub], []))
+  | _ ->
+      None
+
+let unexpand_dupn expanded =
+  match expanded with
+  | Seq
+      ( loc,
+        [ Prim
+            (_, "DIP", [Int (_, np); Seq (_, [Prim (_, "DUP", [], annot)])], []);
+          Prim (_, "DIG", [Int (nloc, ng)], []) ] )
+    when Z.equal np (Z.pred ng) ->
+      Some (Prim (loc, "DUP", [Int (nloc, ng)], annot))
+  | _ ->
+      None
+
+let unexpand_deprecated_duuuuup expanded =
+  (* transparently turn the old expansion of deprecated [DU...UP] to [DUP n] *)
+  let rec expand n = function
+    | Seq (loc, [Prim (nloc, "DUP", [], annot)]) ->
+        if n = 1 then None
+        else Some (Prim (loc, "DUP", [Int (nloc, Z.of_int n)], annot))
+    | Seq (_, [Prim (_, "DIP", [expanded'], []); Prim (_, "SWAP", [], [])]) ->
+        expand (n + 1) expanded'
+    | _ ->
+        None
+  in
+  expand 1 expanded
+
+let rec normalize_pair_item ?(right = false) = function
+  | P (i, a, b) ->
+      P (i, normalize_pair_item a, normalize_pair_item ~right:true b)
+  | A when right ->
+      I
+  | A ->
+      A
+  | I ->
+      I
+
+let unexpand_pappaiir expanded =
+  match expanded with
+  | Seq (_, [Prim (_, "PAIR", [], [])]) ->
+      Some expanded
+  | Seq (loc, (_ :: _ as nodes)) -> (
+      let rec exec stack nodes =
+        match (nodes, stack) with
+        | ([], _) ->
+            stack
+        (* support new expansion using [DIP n] *)
+        | ( Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest,
+            a :: rstack )
+          when Z.to_int n > 1 ->
+            exec
+              ( a
+              :: exec
+                   rstack
+                   [ Prim
+                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
+                   ] )
+              rest
+        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, a :: rstack)
+          when Z.to_int n = 1 ->
+            exec (a :: exec rstack sub) rest
+        | (Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest, [])
+          when Z.to_int n > 1 ->
+            exec
+              ( A
+              :: exec
+                   []
+                   [ Prim
+                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
+                   ] )
+              rest
+        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, [])
+          when Z.to_int n = 1 ->
+            exec (A :: exec [] sub) rest
+        (* support old expansion using [DIP] *)
+        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, a :: rstack) ->
+            exec (a :: exec rstack sub) rest
+        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, []) ->
+            exec (A :: exec [] sub) rest
+        | (Prim (_, "PAIR", [], []) :: rest, a :: b :: rstack) ->
+            exec (P (0, a, b) :: rstack) rest
+        | (Prim (_, "PAIR", [], []) :: rest, [a]) ->
+            exec [P (0, a, I)] rest
+        | (Prim (_, "PAIR", [], []) :: rest, []) ->
+            exec [P (0, A, I)] rest
+        | _ ->
+            raise_notrace Not_a_pair
+      in
+      match exec [] nodes with
+      | [] ->
+          None
+      | res :: _ ->
+          let res = normalize_pair_item res in
+          let name = unparse_pair_item res in
+          Some (Prim (loc, name, [], []))
+      | exception Not_a_pair ->
+          None )
+  | _ ->
+      None
+
+let unexpand_unpappaiir expanded =
+  match expanded with
+  | Seq (loc, (_ :: _ as nodes)) -> (
+      let rec exec stack nodes =
+        match (nodes, stack) with
+        | ([], _) ->
+            stack
+        (* support new expansion using [DIP n] *)
+        | ( Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest,
+            a :: rstack )
+          when Z.to_int n > 1 ->
+            exec
+              ( a
+              :: exec
+                   rstack
+                   [ Prim
+                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
+                   ] )
+              rest
+        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, a :: rstack)
+          when Z.to_int n = 1 ->
+            exec (a :: exec rstack sub) rest
+        | (Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest, [])
+          when Z.to_int n > 1 ->
+            exec
+              ( A
+              :: exec
+                   []
+                   [ Prim
+                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
+                   ] )
+              rest
+        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, [])
+          when Z.to_int n = 1 ->
+            exec (A :: exec [] sub) rest
+        (* support old expansion using [DIP] *)
+        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, a :: rstack) ->
+            exec (a :: exec rstack sub) rest
+        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, []) ->
+            exec (A :: exec [] sub) rest
+        | ( Seq
+              ( _,
+                [ Prim (_, "DUP", [], []);
+                  Prim (_, "CAR", [], []);
+                  Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], [])])], []) ]
+              )
+            :: rest,
+            a :: b :: rstack ) ->
+            exec (P (0, a, b) :: rstack) rest
+        | ( Seq
+              ( _,
+                [ Prim (_, "DUP", [], []);
+                  Prim (_, "CAR", [], []);
+                  Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], [])])], []) ]
+              )
+            :: rest,
+            [a] ) ->
+            exec [P (0, a, I)] rest
+        | ( Seq
+              ( _,
+                [ Prim (_, "DUP", [], []);
+                  Prim (_, "CAR", [], []);
+                  Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], [])])], []) ]
+              )
+            :: rest,
+            [] ) ->
+            exec [P (0, A, I)] rest
+        | _ ->
+            raise_notrace Not_a_pair
+      in
+      match exec [] (List.rev nodes) with
+      | [] ->
+          None
+      | res :: _ ->
+          let res = normalize_pair_item res in
+          let name = "UN" ^ unparse_pair_item res in
+          Some (Prim (loc, name, [], []))
+      | exception Not_a_pair ->
+          None )
+  | _ ->
+      None
+
+let unexpand_compare expanded =
+  match expanded with
+  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "EQ", [], annot)]) ->
+      Some (Prim (loc, "CMPEQ", [], annot))
+  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "NEQ", [], annot)]) ->
+      Some (Prim (loc, "CMPNEQ", [], annot))
+  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "LT", [], annot)]) ->
+      Some (Prim (loc, "CMPLT", [], annot))
+  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "GT", [], annot)]) ->
+      Some (Prim (loc, "CMPGT", [], annot))
+  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "LE", [], annot)]) ->
+      Some (Prim (loc, "CMPLE", [], annot))
+  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "GE", [], annot)]) ->
+      Some (Prim (loc, "CMPGE", [], annot))
+  | Seq
+      ( loc,
+        [ Prim (_, "COMPARE", [], _);
+          Prim (_, "EQ", [], _);
+          Prim (_, "IF", args, annot) ] ) ->
+      Some (Prim (loc, "IFCMPEQ", args, annot))
+  | Seq
+      ( loc,
+        [ Prim (_, "COMPARE", [], _);
+          Prim (_, "NEQ", [], _);
+          Prim (_, "IF", args, annot) ] ) ->
+      Some (Prim (loc, "IFCMPNEQ", args, annot))
+  | Seq
+      ( loc,
+        [ Prim (_, "COMPARE", [], _);
+          Prim (_, "LT", [], _);
+          Prim (_, "IF", args, annot) ] ) ->
+      Some (Prim (loc, "IFCMPLT", args, annot))
+  | Seq
+      ( loc,
+        [ Prim (_, "COMPARE", [], _);
+          Prim (_, "GT", [], _);
+          Prim (_, "IF", args, annot) ] ) ->
+      Some (Prim (loc, "IFCMPGT", args, annot))
+  | Seq
+      ( loc,
+        [ Prim (_, "COMPARE", [], _);
+          Prim (_, "LE", [], _);
+          Prim (_, "IF", args, annot) ] ) ->
+      Some (Prim (loc, "IFCMPLE", args, annot))
+  | Seq
+      ( loc,
+        [ Prim (_, "COMPARE", [], _);
+          Prim (_, "GE", [], _);
+          Prim (_, "IF", args, annot) ] ) ->
+      Some (Prim (loc, "IFCMPGE", args, annot))
+  | Seq (loc, [Prim (_, "EQ", [], _); Prim (_, "IF", args, annot)]) ->
+      Some (Prim (loc, "IFEQ", args, annot))
+  | Seq (loc, [Prim (_, "NEQ", [], _); Prim (_, "IF", args, annot)]) ->
+      Some (Prim (loc, "IFNEQ", args, annot))
+  | Seq (loc, [Prim (_, "LT", [], _); Prim (_, "IF", args, annot)]) ->
+      Some (Prim (loc, "IFLT", args, annot))
+  | Seq (loc, [Prim (_, "GT", [], _); Prim (_, "IF", args, annot)]) ->
+      Some (Prim (loc, "IFGT", args, annot))
+  | Seq (loc, [Prim (_, "LE", [], _); Prim (_, "IF", args, annot)]) ->
+      Some (Prim (loc, "IFLE", args, annot))
+  | Seq (loc, [Prim (_, "GE", [], _); Prim (_, "IF", args, annot)]) ->
+      Some (Prim (loc, "IFGE", args, annot))
+  | _ ->
+      None
+
+let unexpand_asserts expanded =
+  match expanded with
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF",
+              [ Seq (_, []);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT", [], []))
+  | Seq
+      ( loc,
+        [ Seq (_, [Prim (_, "COMPARE", [], []); Prim (_, comparison, [], [])]);
+          Prim
+            ( _,
+              "IF",
+              [ Seq (_, []);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_CMP" ^ comparison, [], []))
+  | Seq
+      ( loc,
+        [ Prim (_, comparison, [], []);
+          Prim
+            ( _,
+              "IF",
+              [ Seq (_, []);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_" ^ comparison, [], []))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_NONE",
+              [ Seq (_, [Prim (_, "RENAME", [], annot)]);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_NONE", [], annot))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_NONE",
+              [ Seq (_, []);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_NONE", [], []))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_NONE",
+              [ Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] );
+                Seq (_, []) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_SOME", [], []))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_NONE",
+              [ Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] );
+                Seq (_, [Prim (_, "RENAME", [], annot)]) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_SOME", [], annot))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_LEFT",
+              [ Seq (_, []);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_LEFT", [], []))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_LEFT",
+              [ Seq (_, [Prim (_, "RENAME", [], annot)]);
+                Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_LEFT", [], annot))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_LEFT",
+              [ Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] );
+                Seq (_, []) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_RIGHT", [], []))
+  | Seq
+      ( loc,
+        [ Prim
+            ( _,
+              "IF_LEFT",
+              [ Seq
+                  ( _,
+                    [ Seq
+                        ( _,
+                          [ Prim (_, "UNIT", [], []);
+                            Prim (_, "FAILWITH", [], []) ] ) ] );
+                Seq (_, [Prim (_, "RENAME", [], annot)]) ],
+              [] ) ] ) ->
+      Some (Prim (loc, "ASSERT_RIGHT", [], annot))
+  | _ ->
+      None
+
+let unexpand_if_some = function
+  | Seq (loc, [Prim (_, "IF_NONE", [left; right], annot)]) ->
+      Some (Prim (loc, "IF_SOME", [right; left], annot))
+  | _ ->
+      None
+
+let unexpand_if_right = function
+  | Seq (loc, [Prim (_, "IF_LEFT", [left; right], annot)]) ->
+      Some (Prim (loc, "IF_RIGHT", [right; left], annot))
+  | _ ->
+      None
+
+let unexpand_fail = function
+  | Seq (loc, [Prim (_, "UNIT", [], []); Prim (_, "FAILWITH", [], [])]) ->
+      Some (Prim (loc, "FAIL", [], []))
+  | _ ->
+      None
+
+let unexpand original =
+  let try_unexpansions unexpanders =
+    match
+      List.fold_left
+        (fun acc f ->
+          match acc with
+          | None ->
+              f original
+          | Some rewritten ->
+              Some rewritten)
+        None
+        unexpanders
+    with
+    | None ->
+        original
+    | Some rewritten ->
+        rewritten
+  in
+  try_unexpansions
+    [ unexpand_asserts;
+      unexpand_carn_and_cdrn;
+      unexpand_caddadr;
+      unexpand_set_caddadr;
+      unexpand_map_caddadr;
+      unexpand_deprecated_dxiiivp;
+      unexpand_pappaiir;
+      unexpand_unpappaiir;
+      unexpand_deprecated_duuuuup;
+      unexpand_dupn;
+      unexpand_compare;
+      unexpand_if_some;
+      unexpand_if_right;
+      unexpand_fail ]
+
+(*
+   If an argument of Prim is a sequence, we do not want to unexpand
+   its root in case the source already contains an expanded macro. In
+   which case unexpansion would remove surrounding braces and generate
+   ill-formed code.
+
+   For example, DIIP { DIP { DUP }; SWAP } is not unexpandable but
+   DIIP {{ DIP { DUP }; SWAP }} (note the double braces) is unexpanded
+   to DIIP { DUUP }.
+
+   unexpand_rec_but_root is the same as unexpand_rec but does not try
+   to unexpand at root *)
+
+let rec unexpand_rec expr = unexpand_rec_but_root (unexpand expr)
+
+and unexpand_rec_but_root = function
+  | Seq (loc, items) ->
+      Seq (loc, List.map unexpand_rec items)
+  | Prim (loc, name, args, annot) ->
+      Prim (loc, name, List.map unexpand_rec_but_root args, annot)
+  | (Int _ | String _ | Bytes _) as atom ->
+      atom
+
+let () =
+  let open Data_encoding in
+  register_error_kind
+    `Permanent
+    ~id:"michelson.macros.unexpected_annotation"
+    ~title:"Unexpected annotation"
+    ~description:
+      "A macro had an annotation, but no annotation was permitted on this \
+       macro."
+    ~pp:(fun ppf -> Format.fprintf ppf "Unexpected annotation on macro %s.")
+    (obj1 (req "macro_name" string))
+    (function Unexpected_macro_annotation str -> Some str | _ -> None)
+    (fun s -> Unexpected_macro_annotation s) ;
+  register_error_kind
+    `Permanent
+    ~id:"michelson.macros.sequence_expected"
+    ~title:"Macro expects a sequence"
+    ~description:"An macro expects a sequence, but a sequence was not provided"
+    ~pp:(fun ppf name ->
+      Format.fprintf
+        ppf
+        "Macro %s expects a sequence, but did not receive one."
+        name)
+    (obj1 (req "macro_name" string))
+    (function Sequence_expected name -> Some name | _ -> None)
+    (fun name -> Sequence_expected name) ;
+  register_error_kind
+    `Permanent
+    ~id:"michelson.macros.bas_arity"
+    ~title:"Wrong number of arguments to macro"
+    ~description:"A wrong number of arguments was provided to a macro"
+    ~pp:(fun ppf (name, got, exp) ->
+      Format.fprintf
+        ppf
+        "Macro %s expects %d arguments, was given %d."
+        name
+        exp
+        got)
+    (obj3
+       (req "macro_name" string)
+       (req "given_number_of_arguments" uint16)
+       (req "expected_number_of_arguments" uint16))
+    (function
+      | Invalid_arity (name, got, exp) -> Some (name, got, exp) | _ -> None)
+    (fun (name, got, exp) -> Invalid_arity (name, got, exp))
diff --git a/vendors/ligo-utils/proto-alpha-utils/michelson_v1_macros.mli b/vendors/ligo-utils/proto-alpha-utils/michelson_v1_macros.mli
new file mode 100644
index 000000000..26f52ddaf
--- /dev/null
+++ b/vendors/ligo-utils/proto-alpha-utils/michelson_v1_macros.mli
@@ -0,0 +1,87 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Tezos_micheline
+open Tezos_base__TzPervasives
+
+type 'l node = ('l, string) Micheline.node
+
+type error += Unexpected_macro_annotation of string
+
+type error += Sequence_expected of string
+
+type error += Invalid_arity of string * int * int
+
+val expand : 'l node -> 'l node tzresult
+
+val expand_rec : 'l node -> 'l node * error list
+
+val expand_caddadr : 'l node -> 'l node option tzresult
+
+val expand_set_caddadr : 'l node -> 'l node option tzresult
+
+val expand_map_caddadr : 'l node -> 'l node option tzresult
+
+val expand_deprecated_dxiiivp : 'l node -> 'l node option tzresult
+
+val expand_pappaiir : 'l node -> 'l node option tzresult
+
+val expand_deprecated_duuuuup : 'l node -> 'l node option tzresult
+
+val expand_compare : 'l node -> 'l node option tzresult
+
+val expand_asserts : 'l node -> 'l node option tzresult
+
+val expand_unpappaiir : 'l node -> 'l node option tzresult
+
+val expand_if_some : 'l node -> 'l node option tzresult
+
+val expand_if_right : 'l node -> 'l node option tzresult
+
+val unexpand : 'l node -> 'l node
+
+val unexpand_rec : 'l node -> 'l node
+
+val unexpand_caddadr : 'l node -> 'l node option
+
+val unexpand_set_caddadr : 'l node -> 'l node option
+
+val unexpand_map_caddadr : 'l node -> 'l node option
+
+val unexpand_deprecated_dxiiivp : 'l node -> 'l node option
+
+val unexpand_pappaiir : 'l node -> 'l node option
+
+val unexpand_deprecated_duuuuup : 'l node -> 'l node option
+
+val unexpand_compare : 'l node -> 'l node option
+
+val unexpand_asserts : 'l node -> 'l node option
+
+val unexpand_unpappaiir : 'l node -> 'l node option
+
+val unexpand_if_some : 'l node -> 'l node option
+
+val unexpand_if_right : 'l node -> 'l node option
diff --git a/vendors/ligo-utils/proto-alpha-utils/michelson_v1_parser.ml b/vendors/ligo-utils/proto-alpha-utils/michelson_v1_parser.ml
new file mode 100644
index 000000000..f41e68515
--- /dev/null
+++ b/vendors/ligo-utils/proto-alpha-utils/michelson_v1_parser.ml
@@ -0,0 +1,131 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Tezos_base__TzPervasives
+
+module Tezos_List = struct
+  let rev_map2 ~when_different_lengths f xs ys =
+    let open List in
+    let rec aux zs xs ys =
+      match (xs, ys) with
+      | ([], []) ->
+          Ok zs
+      | ([], _ :: _) | (_ :: _, []) ->
+          Error when_different_lengths
+      | (x :: xs, y :: ys) ->
+          let z = f x y in
+          (aux [@ocaml.tailcall]) (z :: zs) xs ys
+    in
+    aux [] xs ys
+
+  let map2 ~when_different_lengths f xs ys =
+    rev_map2 ~when_different_lengths f xs ys >|? List.rev
+end
+
+open Tezos_protocol_008_PtEdo2Zk.Protocol
+open Tezos_micheline
+open Micheline_parser
+open Micheline
+
+type parsed = {
+  source : string;
+  unexpanded : string canonical;
+  expanded : Michelson_v1_primitives.prim canonical;
+  expansion_table : (int * (Micheline_parser.location * int list)) list;
+  unexpansion_table : (int * int) list;
+}
+
+let compare_parsed = Stdlib.compare
+
+(* Unexpanded toplevel expression should be a sequence *)
+let expand_all source ast errors =
+  let (unexpanded, loc_table) = extract_locations ast in
+  let (expanded, expansion_errors) =
+    Michelson_v1_macros.expand_rec (root unexpanded)
+  in
+  let (expanded, unexpansion_table) = extract_locations expanded in
+  let expansion_table =
+    let sorted =
+      List.sort (fun (_, a) (_, b) -> Stdlib.compare a b) unexpansion_table
+    in
+    let grouped =
+      let rec group = function
+        | (acc, []) ->
+            acc
+        | ([], (u, e) :: r) ->
+            group ([(e, [u])], r)
+        | (((pe, us) :: racc as acc), (u, e) :: r) ->
+            if e = pe then group ((e, u :: us) :: racc, r)
+            else group ((e, [u]) :: acc, r)
+      in
+      group ([], sorted)
+    in
+    match
+      Tezos_List.map2
+        ~when_different_lengths:()
+        (fun (l, ploc) (l', elocs) ->
+          assert (l = l') ;
+          (l, (ploc, elocs)))
+        (List.sort Stdlib.compare loc_table)
+        (List.sort Stdlib.compare grouped)
+    with
+    | Ok v ->
+        v
+    | Error () ->
+        invalid_arg "Michelson_v1_parser.expand_all"
+  in
+  match
+    Environment.wrap_error (Michelson_v1_primitives.prims_of_strings expanded)
+  with
+  | Ok expanded ->
+      ( {source; unexpanded; expanded; expansion_table; unexpansion_table},
+        errors @ expansion_errors )
+  | Error errs ->
+      ( {
+          source;
+          unexpanded;
+          expanded = Micheline.strip_locations (Seq ((), []));
+          expansion_table;
+          unexpansion_table;
+        },
+        errors @ expansion_errors @ errs )
+
+let parse_toplevel ?check source =
+  let (tokens, lexing_errors) = Micheline_parser.tokenize source in
+  let (asts, parsing_errors) = Micheline_parser.parse_toplevel ?check tokens in
+  let ast =
+    let start = min_point asts and stop = max_point asts in
+    Seq ({start; stop}, asts)
+  in
+  expand_all source ast (lexing_errors @ parsing_errors)
+
+let parse_expression ?check source =
+  let (tokens, lexing_errors) = Micheline_parser.tokenize source in
+  let (ast, parsing_errors) =
+    Micheline_parser.parse_expression ?check tokens
+  in
+  expand_all source ast (lexing_errors @ parsing_errors)
+
+let expand_all ~source ~original = expand_all source original []
diff --git a/vendors/ligo-utils/proto-alpha-utils/michelson_v1_parser.mli b/vendors/ligo-utils/proto-alpha-utils/michelson_v1_parser.mli
new file mode 100644
index 000000000..6a85aaf0a
--- /dev/null
+++ b/vendors/ligo-utils/proto-alpha-utils/michelson_v1_parser.mli
@@ -0,0 +1,55 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Tezos_protocol_008_PtEdo2Zk.Protocol
+open Alpha_context
+open Tezos_micheline
+
+(** The result of parsing and expanding a Michelson V1 script or data. *)
+type parsed = {
+  source : string;  (** The original source code. *)
+  unexpanded : string Micheline.canonical;
+      (** Original expression with macros. *)
+  expanded : Script.expr;  (** Expression with macros fully expanded. *)
+  expansion_table : (int * (Micheline_parser.location * int list)) list;
+      (** Associates unexpanded nodes to their parsing locations and
+        the nodes expanded from it in the expanded expression. *)
+  unexpansion_table : (int * int) list;
+      (** Associates an expanded node to its source in the unexpanded
+        expression. *)
+}
+
+val compare_parsed : parsed -> parsed -> int
+
+val parse_toplevel :
+  ?check:bool -> string -> parsed Micheline_parser.parsing_result
+
+val parse_expression :
+  ?check:bool -> string -> parsed Micheline_parser.parsing_result
+
+val expand_all :
+  source:string ->
+  original:Micheline_parser.node ->
+  parsed Micheline_parser.parsing_result
diff --git a/vendors/ligo-utils/proto-alpha-utils/michelson_v1_printer.ml b/vendors/ligo-utils/proto-alpha-utils/michelson_v1_printer.ml
new file mode 100644
index 000000000..4535d456a
--- /dev/null
+++ b/vendors/ligo-utils/proto-alpha-utils/michelson_v1_printer.ml
@@ -0,0 +1,270 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Tezos_protocol_008_PtEdo2Zk.Protocol
+open Tezos_base__TzPervasives
+open Alpha_context
+open Tezos_micheline
+open Micheline
+open Micheline_printer
+
+let rec assoc ~equal k = function
+  | [] ->
+      None
+  | (kk, v) :: kvs ->
+      if equal k kk then Some v else assoc ~equal k kvs
+
+let hd = function x :: _ -> Some x | [] -> None
+
+let anon = {comment = None}
+
+let print_expr ppf expr =
+  expr |> Michelson_v1_primitives.strings_of_prims
+  |> Micheline.inject_locations (fun _ -> anon)
+  |> print_expr ppf
+
+let print_expr_unwrapped ppf expr =
+  expr |> Michelson_v1_primitives.strings_of_prims
+  |> Micheline.inject_locations (fun _ -> anon)
+  |> print_expr_unwrapped ppf
+
+let print_var_annots ppf = List.iter (Format.fprintf ppf "%s ")
+
+let print_annot_expr_unwrapped ppf (expr, annot) =
+  Format.fprintf ppf "%a%a" print_var_annots annot print_expr_unwrapped expr
+
+let print_stack ppf = function
+  | [] ->
+      Format.fprintf ppf "[]"
+  | more ->
+      Format.fprintf
+        ppf
+        "@[<hov 0>[ %a ]@]"
+        (Format.pp_print_list
+           ~pp_sep:(fun ppf () -> Format.fprintf ppf "@ : ")
+           print_annot_expr_unwrapped)
+        more
+
+let print_execution_trace ppf trace =
+  Format.pp_print_list
+    (fun ppf (loc, gas, stack) ->
+      Format.fprintf
+        ppf
+        "- @[<v 0>location: %d (remaining gas: %a)@,[ @[<v 0>%a ]@]@]"
+        loc
+        Gas.pp
+        gas
+        (Format.pp_print_list (fun ppf (e, annot) ->
+             Format.fprintf
+               ppf
+               "@[<v 0>%a  \t%s@]"
+               print_expr
+               e
+               (match annot with None -> "" | Some a -> a)))
+        stack)
+    ppf
+    trace
+
+let print_big_map_diff ppf lazy_storage_diff =
+  let diff =
+    Contract.Legacy_big_map_diff.of_lazy_storage_diff lazy_storage_diff
+  in
+  let pp_map ppf id =
+    if Compare.Z.(id < Z.zero) then
+      Format.fprintf ppf "temp(%s)" (Z.to_string (Z.neg id))
+    else Format.fprintf ppf "map(%s)" (Z.to_string id)
+  in
+  Format.fprintf
+    ppf
+    "@[<v 0>%a@]"
+    (Format.pp_print_list ~pp_sep:Format.pp_print_space (fun ppf ->
+       function
+       | Contract.Legacy_big_map_diff.Clear id ->
+           Format.fprintf ppf "Clear %a" pp_map id
+       | Contract.Legacy_big_map_diff.Alloc {big_map; key_type; value_type} ->
+           Format.fprintf
+             ppf
+             "New %a of type (big_map %a %a)"
+             pp_map
+             big_map
+             print_expr
+             key_type
+             print_expr
+             value_type
+       | Contract.Legacy_big_map_diff.Copy {src; dst} ->
+           Format.fprintf ppf "Copy %a to %a" pp_map src pp_map dst
+       | Contract.Legacy_big_map_diff.Update {big_map; diff_key; diff_value; _}
+         ->
+           Format.fprintf
+             ppf
+             "%s %a[%a]%a"
+             (match diff_value with None -> "Unset" | Some _ -> "Set")
+             pp_map
+             big_map
+             print_expr
+             diff_key
+             (fun ppf -> function None -> () | Some x ->
+                   Format.fprintf ppf " to %a" print_expr x)
+             diff_value))
+    (diff :> Contract.Legacy_big_map_diff.item list)
+
+let inject_types type_map parsed =
+  let rec inject_expr = function
+    | Seq (loc, items) ->
+        Seq (inject_loc `before loc, List.map inject_expr items)
+    | Prim (loc, name, items, annot) ->
+        Prim (inject_loc `after loc, name, List.map inject_expr items, annot)
+    | Int (loc, value) ->
+        Int (inject_loc `after loc, value)
+    | String (loc, value) ->
+        String (inject_loc `after loc, value)
+    | Bytes (loc, value) ->
+        Bytes (inject_loc `after loc, value)
+  and inject_loc which loc =
+    let comment =
+      let ( >?? ) = Option.bind in
+      assoc
+        ~equal:Int.equal
+        loc
+        parsed.Michelson_v1_parser.expansion_table
+      >?? fun (_, locs) ->
+      let locs = List.sort compare locs in
+      hd locs
+      >?? fun head_loc ->
+      assoc ~equal:Int.equal head_loc type_map
+      >?? fun (bef, aft) ->
+      let stack = match which with `before -> bef | `after -> aft in
+      Some (Format.asprintf "%a" print_stack stack)
+    in
+    {comment}
+  in
+  inject_expr (root parsed.unexpanded)
+
+let unparse ?type_map parse expanded =
+  let source =
+    match type_map with
+    | Some type_map ->
+        let (unexpanded, unexpansion_table) =
+          expanded |> Michelson_v1_primitives.strings_of_prims |> root
+          |> Michelson_v1_macros.unexpand_rec |> Micheline.extract_locations
+        in
+        let rec inject_expr = function
+          | Seq (loc, items) ->
+              Seq (inject_loc `before loc, List.map inject_expr items)
+          | Prim (loc, name, items, annot) ->
+              Prim
+                (inject_loc `after loc, name, List.map inject_expr items, annot)
+          | Int (loc, value) ->
+              Int (inject_loc `after loc, value)
+          | String (loc, value) ->
+              String (inject_loc `after loc, value)
+          | Bytes (loc, value) ->
+              Bytes (inject_loc `after loc, value)
+        and inject_loc which loc =
+          let comment =
+            let ( >?? ) = Option.bind in
+            assoc ~equal:Int.equal loc unexpansion_table
+            >?? fun loc ->
+            assoc ~equal:Int.equal loc type_map
+            >?? fun (bef, aft) ->
+            let stack = match which with `before -> bef | `after -> aft in
+            Some (Format.asprintf "%a" print_stack stack)
+          in
+          {comment}
+        in
+        unexpanded |> root |> inject_expr
+        |> Format.asprintf "%a" Micheline_printer.print_expr
+    | None ->
+        expanded |> Michelson_v1_primitives.strings_of_prims |> root
+        |> Michelson_v1_macros.unexpand_rec |> Micheline.strip_locations
+        |> Micheline_printer.printable (fun n -> n)
+        |> Format.asprintf "%a" Micheline_printer.print_expr
+  in
+  match parse source with
+  | (res, []) ->
+      res
+  | (_, _ :: _) ->
+      Stdlib.failwith "Michelson_v1_printer.unparse"
+
+let unparse_toplevel ?type_map =
+  unparse ?type_map Michelson_v1_parser.parse_toplevel
+
+let unparse_expression = unparse Michelson_v1_parser.parse_expression
+
+let unparse_invalid expanded =
+  let source =
+    expanded |> root |> Michelson_v1_macros.unexpand_rec
+    |> Micheline.strip_locations
+    |> Micheline_printer.printable (fun n -> n)
+    |> Format.asprintf "%a" Micheline_printer.print_expr_unwrapped
+  in
+  fst (Michelson_v1_parser.parse_toplevel source)
+
+let ocaml_constructor_of_prim prim =
+  (* Assuming all the prim constructor prefixes match the
+     [[Michelson_v1_primitives.namespace]]. *)
+  let prefix =
+    Michelson_v1_primitives.(namespace prim |> string_of_namespace)
+  in
+  Format.asprintf "%s_%s" prefix @@ Michelson_v1_primitives.string_of_prim prim
+
+let micheline_string_of_expression ~zero_loc expression =
+  let string_of_list : string list -> string =
+   fun xs -> String.concat "; " xs |> Format.asprintf "[%s]"
+  in
+  let show_loc loc = if zero_loc then 0 else loc in
+  let rec string_of_node = function
+    | Int (loc, i) ->
+        let z =
+          match Z.to_int i with
+          | 0 ->
+              "Z.zero"
+          | 1 ->
+              "Z.one"
+          | i ->
+              Format.asprintf "Z.of_int %d" i
+        in
+        Format.asprintf "Int (%d, %s)" (show_loc loc) z
+    | String (loc, s) ->
+        Format.asprintf "String (%d, \"%s\")" (show_loc loc) s
+    | Bytes (loc, b) ->
+        Format.asprintf
+          "Bytes (%d, Bytes.of_string \"%s\")"
+          (show_loc loc)
+          Bytes.(escaped b |> to_string)
+    | Prim (loc, prim, nodes, annot) ->
+        Format.asprintf
+          "Prim (%d, %s, %s, %s)"
+          (show_loc loc)
+          (ocaml_constructor_of_prim prim)
+          (string_of_list @@ List.map string_of_node nodes)
+          (string_of_list @@ List.map (Format.asprintf "\"%s\"") annot)
+    | Seq (loc, nodes) ->
+        Format.asprintf
+          "Seq (%d, %s)"
+          (show_loc loc)
+          (string_of_list @@ List.map string_of_node nodes)
+  in
+  string_of_node (root expression)
diff --git a/vendors/ligo-utils/proto-alpha-utils/michelson_v1_printer.mli b/vendors/ligo-utils/proto-alpha-utils/michelson_v1_printer.mli
new file mode 100644
index 000000000..334ede78b
--- /dev/null
+++ b/vendors/ligo-utils/proto-alpha-utils/michelson_v1_printer.mli
@@ -0,0 +1,65 @@
+(*****************************************************************************)
+(*                                                                           *)
+(* Open Source License                                                       *)
+(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
+(*                                                                           *)
+(* Permission is hereby granted, free of charge, to any person obtaining a   *)
+(* copy of this software and associated documentation files (the "Software"),*)
+(* to deal in the Software without restriction, including without limitation *)
+(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
+(* and/or sell copies of the Software, and to permit persons to whom the     *)
+(* Software is furnished to do so, subject to the following conditions:      *)
+(*                                                                           *)
+(* The above copyright notice and this permission notice shall be included   *)
+(* in all copies or substantial portions of the Software.                    *)
+(*                                                                           *)
+(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
+(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
+(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
+(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
+(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
+(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
+(* DEALINGS IN THE SOFTWARE.                                                 *)
+(*                                                                           *)
+(*****************************************************************************)
+
+open Tezos_protocol_008_PtEdo2Zk.Protocol
+open Alpha_context
+open Tezos_micheline
+
+val print_expr : Format.formatter -> Script_repr.expr -> unit
+
+val print_expr_unwrapped : Format.formatter -> Script_repr.expr -> unit
+
+val print_execution_trace :
+  Format.formatter ->
+  (Script.location * Gas.t * (Script.expr * string option) list) list ->
+  unit
+
+val print_big_map_diff : Format.formatter -> Lazy_storage.diffs -> unit
+
+(** Insert the type map returned by the typechecker as comments in a
+    printable Micheline AST. *)
+val inject_types :
+  Script_tc_errors.type_map ->
+  Michelson_v1_parser.parsed ->
+  Micheline_printer.node
+
+(** Unexpand the macros and produce the result of parsing an
+    intermediate pretty printed source. Useful when working with
+    contracts extracted from the blockchain and not local files. *)
+val unparse_toplevel :
+  ?type_map:Script_tc_errors.type_map ->
+  Script.expr ->
+  Michelson_v1_parser.parsed
+
+val unparse_expression : Script.expr -> Michelson_v1_parser.parsed
+
+(** Unexpand the macros and produce the result of parsing an
+    intermediate pretty printed source. Works on generic trees,for
+    programs that fail to be converted to a specific script version. *)
+val unparse_invalid : string Micheline.canonical -> Michelson_v1_parser.parsed
+
+val ocaml_constructor_of_prim : Michelson_v1_primitives.prim -> string
+
+val micheline_string_of_expression : zero_loc:bool -> Script.expr -> string
diff --git a/vendors/ligo-utils/proto-alpha-utils/proto-alpha-utils.opam b/vendors/ligo-utils/proto-alpha-utils/proto-alpha-utils.opam
index c304988a7..eef84f420 100644
--- a/vendors/ligo-utils/proto-alpha-utils/proto-alpha-utils.opam
+++ b/vendors/ligo-utils/proto-alpha-utils/proto-alpha-utils.opam
@@ -18,7 +18,7 @@ depends: [
   "cstruct"
   "ezjsonm"
   "hex"
-  "hidapi"
+  # "hidapi"
   "ipaddr"
   "macaddr"
   "irmin"
@@ -42,7 +42,8 @@ depends: [
   "tezos-stdlib-unix"
   "tezos-protocol-environment"
   "tezos-protocol-008-PtEdo2Zk"
-  "tezos-client-008-PtEdo2Zk"
+  "tezos-protocol-008-PtEdo2Zk-parameters"
+  # "tezos-client-008-PtEdo2Zk"
   "tezos-memory-proto-alpha"
   "simple-utils"
   "tezos-utils"
diff --git a/vendors/ligo-utils/proto-alpha-utils/x_memory_proto_alpha.ml b/vendors/ligo-utils/proto-alpha-utils/x_memory_proto_alpha.ml
index 5d96dc097..ccc14c067 100644
--- a/vendors/ligo-utils/proto-alpha-utils/x_memory_proto_alpha.ml
+++ b/vendors/ligo-utils/proto-alpha-utils/x_memory_proto_alpha.ml
@@ -5,7 +5,7 @@ let init_environment = Init_proto_alpha.init_environment
 let dummy_environment = Init_proto_alpha.dummy_environment
 
 
-open Protocol
+open Tezos_protocol_008_PtEdo2Zk.Protocol
 open Script_typed_ir
 open Script_ir_translator
 open Script_interpreter
@@ -58,7 +58,7 @@ let ty_eq (type a b)
 (* should not need lwt *)
 let prims_of_strings michelson =
   let (michelson, errs) =
-    Tezos_client_008_PtEdo2Zk.Michelson_v1_macros.expand_rec michelson in
+    Michelson_v1_macros.expand_rec michelson in
   match errs with
   | _ :: _ ->
     Lwt.return (Error errs)
diff --git a/vendors/ligo-utils/tezos-utils/tezos-utils.opam b/vendors/ligo-utils/tezos-utils/tezos-utils.opam
index ef8aabe3d..b64ca85db 100644
--- a/vendors/ligo-utils/tezos-utils/tezos-utils.opam
+++ b/vendors/ligo-utils/tezos-utils/tezos-utils.opam
@@ -17,7 +17,7 @@ depends: [
   "cstruct"
   "ezjsonm"
   "hex"
-  "hidapi"
+  # "hidapi"
   "irmin"
   "js_of_ocaml"
   "lwt"
-- 
GitLab


From 3eb2140362b807b0d3357bfc01f0afd299fff3e8 Mon Sep 17 00:00:00 2001
From: Ulrik Strid <ulrik.strid@outlook.com>
Date: Wed, 26 May 2021 22:37:45 +0200
Subject: [PATCH 03/12] Fix macos base build, start vendor library

---
 ligo.opam                                     |    1 +
 src/main/main_errors/dune                     |    3 +-
 src/main/main_errors/michelson_v1_macros.ml   | 1543 -----------------
 src/main/main_errors/michelson_v1_macros.mli  |   87 -
 src/main/main_errors/michelson_v1_parser.ml   |  131 --
 src/main/main_errors/michelson_v1_parser.mli  |   55 -
 .../client_utils-008-PtEdo2Zk.opam            |   25 +
 .../client_utils_008_PtEdo2Zk.ml              |    6 +
 .../ligo-utils/client_utils_008_PtEdo2Zk/dune |   19 +
 .../client_utils_008_PtEdo2Zk/dune-project    |    2 +
 .../michelson_v1_error_reporter.ml            |    0
 .../michelson_v1_error_reporter.mli           |    0
 .../michelson_v1_macros.ml                    |    0
 .../michelson_v1_macros.mli                   |    0
 .../michelson_v1_parser.ml                    |    2 -
 .../michelson_v1_parser.mli                   |    2 +-
 .../michelson_v1_printer.ml                   |    1 -
 .../michelson_v1_printer.mli                  |    0
 .../operation_result.ml                       |    0
 .../operation_result.mli                      |    0
 .../ligo_008_PtEdo2Zk_test_helpers/dune       |    4 +-
 .../ligo-008-PtEdo2Zk-test-helpers.opam       |    1 +
 .../michelson_v1_parser.ml                    |  129 --
 .../michelson_v1_parser.mli                   |   55 -
 .../michelson_v1_printer.ml                   |  269 ---
 .../michelson_v1_printer.mli                  |   65 -
 vendors/ligo-utils/proto-alpha-utils/dune     |   32 +-
 .../proto-alpha-utils/michelson_v1_macros.ml  | 1543 -----------------
 .../proto-alpha-utils/michelson_v1_macros.mli |   87 -
 .../proto-alpha-utils/michelson_v1_printer.ml |  270 ---
 .../michelson_v1_printer.mli                  |   65 -
 .../proto-alpha-utils/proto-alpha-utils.opam  |    1 +
 32 files changed, 77 insertions(+), 4321 deletions(-)
 delete mode 100644 src/main/main_errors/michelson_v1_macros.ml
 delete mode 100644 src/main/main_errors/michelson_v1_macros.mli
 delete mode 100644 src/main/main_errors/michelson_v1_parser.ml
 delete mode 100644 src/main/main_errors/michelson_v1_parser.mli
 create mode 100644 vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam
 create mode 100644 vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils_008_PtEdo2Zk.ml
 create mode 100644 vendors/ligo-utils/client_utils_008_PtEdo2Zk/dune
 create mode 100644 vendors/ligo-utils/client_utils_008_PtEdo2Zk/dune-project
 rename {src/main/main_errors => vendors/ligo-utils/client_utils_008_PtEdo2Zk}/michelson_v1_error_reporter.ml (100%)
 rename {src/main/main_errors => vendors/ligo-utils/client_utils_008_PtEdo2Zk}/michelson_v1_error_reporter.mli (100%)
 rename vendors/ligo-utils/{ligo_008_PtEdo2Zk_test_helpers => client_utils_008_PtEdo2Zk}/michelson_v1_macros.ml (100%)
 rename vendors/ligo-utils/{ligo_008_PtEdo2Zk_test_helpers => client_utils_008_PtEdo2Zk}/michelson_v1_macros.mli (100%)
 rename vendors/ligo-utils/{proto-alpha-utils => client_utils_008_PtEdo2Zk}/michelson_v1_parser.ml (99%)
 rename vendors/ligo-utils/{proto-alpha-utils => client_utils_008_PtEdo2Zk}/michelson_v1_parser.mli (98%)
 rename {src/main/main_errors => vendors/ligo-utils/client_utils_008_PtEdo2Zk}/michelson_v1_printer.ml (99%)
 rename {src/main/main_errors => vendors/ligo-utils/client_utils_008_PtEdo2Zk}/michelson_v1_printer.mli (100%)
 rename {src/main/main_errors => vendors/ligo-utils/client_utils_008_PtEdo2Zk}/operation_result.ml (100%)
 rename {src/main/main_errors => vendors/ligo-utils/client_utils_008_PtEdo2Zk}/operation_result.mli (100%)
 delete mode 100644 vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_parser.ml
 delete mode 100644 vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_parser.mli
 delete mode 100644 vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_printer.ml
 delete mode 100644 vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_printer.mli
 delete mode 100644 vendors/ligo-utils/proto-alpha-utils/michelson_v1_macros.ml
 delete mode 100644 vendors/ligo-utils/proto-alpha-utils/michelson_v1_macros.mli
 delete mode 100644 vendors/ligo-utils/proto-alpha-utils/michelson_v1_printer.ml
 delete mode 100644 vendors/ligo-utils/proto-alpha-utils/michelson_v1_printer.mli

diff --git a/ligo.opam b/ligo.opam
index 2c552d33c..b7bdd345e 100644
--- a/ligo.opam
+++ b/ligo.opam
@@ -20,6 +20,7 @@ depends: [
   "ppx_expect"
   "tezos-utils"
   "proto-alpha-utils"
+  "client_utils-008-PtEdo2Zk"
   "ligo-008-PtEdo2Zk-test-helpers"
   "yojson"
   "alcotest" { with-test & >= "1.0" & < "1.1" }
diff --git a/src/main/main_errors/dune b/src/main/main_errors/dune
index 4841083ed..bd1014440 100644
--- a/src/main/main_errors/dune
+++ b/src/main/main_errors/dune
@@ -22,6 +22,7 @@
     self_mini_c
     stacking
     self_michelson
+    client_utils-008-PtEdo2Zk
   )
-  (flags (:standard -w +1..62-4-9-44-40-42-48-30@39@33 -open Simple_utils -open Tezos_utils ))
+  (flags (:standard -w +1..62-4-9-44-40-42-48-30@39@33 -open Simple_utils -open Tezos_utils -open Client_utils_008_PtEdo2Zk))
 )
diff --git a/src/main/main_errors/michelson_v1_macros.ml b/src/main/main_errors/michelson_v1_macros.ml
deleted file mode 100644
index 06100482a..000000000
--- a/src/main/main_errors/michelson_v1_macros.ml
+++ /dev/null
@@ -1,1543 +0,0 @@
-(*****************************************************************************)
-(*                                                                           *)
-(* Open Source License                                                       *)
-(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
-(* Copyright (c) 2019 Nomadic Labs <contact@nomadic-labs.com>                *)
-(*                                                                           *)
-(* Permission is hereby granted, free of charge, to any person obtaining a   *)
-(* copy of this software and associated documentation files (the "Software"),*)
-(* to deal in the Software without restriction, including without limitation *)
-(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
-(* and/or sell copies of the Software, and to permit persons to whom the     *)
-(* Software is furnished to do so, subject to the following conditions:      *)
-(*                                                                           *)
-(* The above copyright notice and this permission notice shall be included   *)
-(* in all copies or substantial portions of the Software.                    *)
-(*                                                                           *)
-(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
-(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
-(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
-(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
-(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
-(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
-(* DEALINGS IN THE SOFTWARE.                                                 *)
-(*                                                                           *)
-(*****************************************************************************)
-
-open Tezos_micheline
-open Micheline
-open Tezos_base__TzPervasives
-module IntMap = Map.Make (Compare.Int)
-
-type 'l node = ('l, string) Micheline.node
-
-type error += Unexpected_macro_annotation of string
-
-type error += Sequence_expected of string
-
-type error += Invalid_arity of string * int * int
-
-let rec check_letters str i j f =
-  i > j || (f str.[i] && check_letters str (i + 1) j f)
-
-let expand_caddadr original =
-  match original with
-  | Prim (loc, str, args, annot) ->
-      let len = String.length str in
-      if
-        len > 3
-        && str.[0] = 'C'
-        && str.[len - 1] = 'R'
-        && check_letters str 1 (len - 2) (function
-               | 'A' | 'D' ->
-                   true
-               | _ ->
-                   false)
-      then
-        ( match args with
-        | [] ->
-            ok ()
-        | _ :: _ ->
-            error (Invalid_arity (str, List.length args, 0)) )
-        >>? fun () ->
-        let path_annot =
-          List.filter (function "@%" | "@%%" -> true | _ -> false) annot
-        in
-        let rec parse i acc =
-          if i = 0 then Seq (loc, acc)
-          else
-            let annot = if i = len - 2 then annot else path_annot in
-            match str.[i] with
-            | 'A' ->
-                parse (i - 1) (Prim (loc, "CAR", [], annot) :: acc)
-            | 'D' ->
-                parse (i - 1) (Prim (loc, "CDR", [], annot) :: acc)
-            | _ ->
-                assert false
-        in
-        ok (Some (parse (len - 2) []))
-      else ok None
-  | _ ->
-      ok None
-
-let expand_carn original =
-  match original with
-  | Prim (loc, "CAR", [Int (loc2, n)], annot) ->
-      ok
-        (Some
-           (Seq
-              ( loc,
-                [ Prim
-                    ( loc,
-                      "GET",
-                      [Int (loc2, Z.(of_int 1 + (n * of_int 2)))],
-                      annot ) ] )))
-  | _ ->
-      ok None
-
-let expand_cdrn original =
-  match original with
-  | Prim (loc, "CDR", [Int (loc2, n)], annot) ->
-      ok
-        (Some
-           (Seq
-              (loc, [Prim (loc, "GET", [Int (loc2, Z.(n * of_int 2))], annot)])))
-  | _ ->
-      ok None
-
-let extract_field_annots annot =
-  List.partition
-    (fun a ->
-      match a.[0] with
-      | '%' ->
-          true
-      | _ ->
-          false
-      | exception Invalid_argument _ ->
-          false)
-    annot
-
-let expand_set_caddadr original =
-  match original with
-  | Prim (loc, str, args, annot) ->
-      let len = String.length str in
-      if
-        len >= 7
-        && String.sub str 0 5 = "SET_C"
-        && str.[len - 1] = 'R'
-        && check_letters str 5 (len - 2) (function
-               | 'A' | 'D' ->
-                   true
-               | _ ->
-                   false)
-      then
-        ( match args with
-        | [] ->
-            ok ()
-        | _ :: _ ->
-            error (Invalid_arity (str, List.length args, 0)) )
-        >>? fun () ->
-        ( match extract_field_annots annot with
-        | ([], annot) ->
-            ok (None, annot)
-        | ([f], annot) ->
-            ok (Some f, annot)
-        | (_, _) ->
-            error (Unexpected_macro_annotation str) )
-        >>? fun (field_annot, annot) ->
-        let rec parse i acc =
-          if i = 4 then acc
-          else
-            let annot = if i = 5 then annot else [] in
-            match str.[i] with
-            | 'A' ->
-                let acc =
-                  Seq
-                    ( loc,
-                      [ Prim (loc, "DUP", [], []);
-                        Prim
-                          ( loc,
-                            "DIP",
-                            [Seq (loc, [Prim (loc, "CAR", [], ["@%%"]); acc])],
-                            [] );
-                        Prim (loc, "CDR", [], ["@%%"]);
-                        Prim (loc, "SWAP", [], []);
-                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
-                in
-                parse (i - 1) acc
-            | 'D' ->
-                let acc =
-                  Seq
-                    ( loc,
-                      [ Prim (loc, "DUP", [], []);
-                        Prim
-                          ( loc,
-                            "DIP",
-                            [Seq (loc, [Prim (loc, "CDR", [], ["@%%"]); acc])],
-                            [] );
-                        Prim (loc, "CAR", [], ["@%%"]);
-                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
-                in
-                parse (i - 1) acc
-            | _ ->
-                assert false
-        in
-        match str.[len - 2] with
-        | 'A' ->
-            let access_check =
-              match field_annot with
-              | None ->
-                  []
-              | Some f ->
-                  [ Prim (loc, "DUP", [], []);
-                    Prim (loc, "CAR", [], [f]);
-                    Prim (loc, "DROP", [], []) ]
-            in
-            let encoding =
-              [Prim (loc, "CDR", [], ["@%%"]); Prim (loc, "SWAP", [], [])]
-            in
-            let pair =
-              [ Prim
-                  ( loc,
-                    "PAIR",
-                    [],
-                    [Option.value field_annot ~default:"%"; "%@"] ) ]
-            in
-            let init = Seq (loc, access_check @ encoding @ pair) in
-            ok (Some (parse (len - 3) init))
-        | 'D' ->
-            let access_check =
-              match field_annot with
-              | None ->
-                  []
-              | Some f ->
-                  [ Prim (loc, "DUP", [], []);
-                    Prim (loc, "CDR", [], [f]);
-                    Prim (loc, "DROP", [], []) ]
-            in
-            let encoding = [Prim (loc, "CAR", [], ["@%%"])] in
-            let pair =
-              [ Prim
-                  ( loc,
-                    "PAIR",
-                    [],
-                    ["%@"; Option.value field_annot ~default:"%"] ) ]
-            in
-            let init = Seq (loc, access_check @ encoding @ pair) in
-            ok (Some (parse (len - 3) init))
-        | _ ->
-            assert false
-      else ok None
-  | _ ->
-      ok None
-
-let expand_map_caddadr original =
-  match original with
-  | Prim (loc, str, args, annot) ->
-      let len = String.length str in
-      if
-        len >= 7
-        && String.sub str 0 5 = "MAP_C"
-        && str.[len - 1] = 'R'
-        && check_letters str 5 (len - 2) (function
-               | 'A' | 'D' ->
-                   true
-               | _ ->
-                   false)
-      then
-        ( match args with
-        | [(Seq _ as code)] ->
-            ok code
-        | [_] ->
-            error (Sequence_expected str)
-        | [] | _ :: _ :: _ ->
-            error (Invalid_arity (str, List.length args, 1)) )
-        >>? fun code ->
-        ( match extract_field_annots annot with
-        | ([], annot) ->
-            ok (None, annot)
-        | ([f], annot) ->
-            ok (Some f, annot)
-        | (_, _) ->
-            error (Unexpected_macro_annotation str) )
-        >>? fun (field_annot, annot) ->
-        let rec parse i acc =
-          if i = 4 then acc
-          else
-            let annot = if i = 5 then annot else [] in
-            match str.[i] with
-            | 'A' ->
-                let acc =
-                  Seq
-                    ( loc,
-                      [ Prim (loc, "DUP", [], []);
-                        Prim
-                          ( loc,
-                            "DIP",
-                            [Seq (loc, [Prim (loc, "CAR", [], ["@%%"]); acc])],
-                            [] );
-                        Prim (loc, "CDR", [], ["@%%"]);
-                        Prim (loc, "SWAP", [], []);
-                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
-                in
-                parse (i - 1) acc
-            | 'D' ->
-                let acc =
-                  Seq
-                    ( loc,
-                      [ Prim (loc, "DUP", [], []);
-                        Prim
-                          ( loc,
-                            "DIP",
-                            [Seq (loc, [Prim (loc, "CDR", [], ["@%%"]); acc])],
-                            [] );
-                        Prim (loc, "CAR", [], ["@%%"]);
-                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
-                in
-                parse (i - 1) acc
-            | _ ->
-                assert false
-        in
-        let cr_annot =
-          match field_annot with
-          | None ->
-              []
-          | Some f ->
-              ["@" ^ String.sub f 1 (String.length f - 1)]
-        in
-        match str.[len - 2] with
-        | 'A' ->
-            let init =
-              Seq
-                ( loc,
-                  [ Prim (loc, "DUP", [], []);
-                    Prim (loc, "CDR", [], ["@%%"]);
-                    Prim
-                      ( loc,
-                        "DIP",
-                        [Seq (loc, [Prim (loc, "CAR", [], cr_annot); code])],
-                        [] );
-                    Prim (loc, "SWAP", [], []);
-                    Prim
-                      ( loc,
-                        "PAIR",
-                        [],
-                        [Option.value field_annot ~default:"%"; "%@"] ) ] )
-            in
-            ok (Some (parse (len - 3) init))
-        | 'D' ->
-            let init =
-              Seq
-                ( loc,
-                  [ Prim (loc, "DUP", [], []);
-                    Prim (loc, "CDR", [], cr_annot);
-                    code;
-                    Prim (loc, "SWAP", [], []);
-                    Prim (loc, "CAR", [], ["@%%"]);
-                    Prim
-                      ( loc,
-                        "PAIR",
-                        [],
-                        ["%@"; Option.value field_annot ~default:"%"] ) ] )
-            in
-            ok (Some (parse (len - 3) init))
-        | _ ->
-            assert false
-      else ok None
-  | _ ->
-      ok None
-
-exception Not_a_roman
-
-let decimal_of_roman roman =
-  (* http://rosettacode.org/wiki/Roman_numerals/Decode#OCaml *)
-  let arabic = ref 0 in
-  let lastval = ref 0 in
-  for i = String.length roman - 1 downto 0 do
-    let n =
-      match roman.[i] with
-      | 'M' ->
-          1000
-      | 'D' ->
-          500
-      | 'C' ->
-          100
-      | 'L' ->
-          50
-      | 'X' ->
-          10
-      | 'V' ->
-          5
-      | 'I' ->
-          1
-      | _ ->
-          raise_notrace Not_a_roman
-    in
-    if Compare.Int.(n < !lastval) then arabic := !arabic - n
-    else arabic := !arabic + n ;
-    lastval := n
-  done ;
-  !arabic
-
-let dip ~loc ?(annot = []) depth instr =
-  assert (depth >= 0) ;
-  if depth = 1 then Prim (loc, "DIP", [instr], annot)
-  else Prim (loc, "DIP", [Int (loc, Z.of_int depth); instr], annot)
-
-let expand_deprecated_dxiiivp original =
-  (* transparently expands deprecated macro [DI...IP] to instruction [DIP n] *)
-  match original with
-  | Prim (loc, str, args, annot) ->
-      let len = String.length str in
-      if len > 3 && str.[0] = 'D' && str.[len - 1] = 'P' then
-        try
-          let depth = decimal_of_roman (String.sub str 1 (len - 2)) in
-          match args with
-          | [(Seq (_, _) as arg)] ->
-              ok @@ Some (dip ~loc ~annot depth arg)
-          | [_] ->
-              error (Sequence_expected str)
-          | [] | _ :: _ :: _ ->
-              error (Invalid_arity (str, List.length args, 1))
-        with Not_a_roman -> ok None
-      else ok None
-  | _ ->
-      ok None
-
-exception Not_a_pair
-
-type pair_item = A | I | P of int * pair_item * pair_item
-
-let parse_pair_substr str ~len start =
-  let rec parse ?left i =
-    if i = len - 1 then raise_notrace Not_a_pair
-    else if str.[i] = 'P' then
-      let (next_i, l) = parse ~left:true (i + 1) in
-      let (next_i, r) = parse ~left:false next_i in
-      (next_i, P (i, l, r))
-    else if str.[i] = 'A' && left = Some true then (i + 1, A)
-    else if str.[i] = 'I' && left <> Some true then (i + 1, I)
-    else raise_notrace Not_a_pair
-  in
-  let (last, ast) = parse start in
-  if last <> len - 1 then raise_notrace Not_a_pair else ast
-
-let unparse_pair_item ast =
-  let rec unparse ast acc =
-    match ast with
-    | P (_, l, r) ->
-        unparse r (unparse l ("P" :: acc))
-    | A ->
-        "A" :: acc
-    | I ->
-        "I" :: acc
-  in
-  List.rev ("R" :: unparse ast []) |> String.concat ""
-
-let pappaiir_annots_pos ast annot =
-  let rec find_annots_pos p_pos ast annots acc =
-    match (ast, annots) with
-    | (_, []) ->
-        (annots, acc)
-    | (P (i, left, right), _) ->
-        let (annots, acc) = find_annots_pos i left annots acc in
-        find_annots_pos i right annots acc
-    | (A, a :: annots) ->
-        let pos =
-          match IntMap.find p_pos acc with
-          | None ->
-              ([a], [])
-          | Some (_, cdr) ->
-              ([a], cdr)
-        in
-        (annots, IntMap.add p_pos pos acc)
-    | (I, a :: annots) ->
-        let pos =
-          match IntMap.find p_pos acc with
-          | None ->
-              ([], [a])
-          | Some (car, _) ->
-              (car, [a])
-        in
-        (annots, IntMap.add p_pos pos acc)
-  in
-  snd (find_annots_pos 0 ast annot IntMap.empty)
-
-let expand_pappaiir original =
-  match original with
-  | Prim (loc, str, args, annot) ->
-      let len = String.length str in
-      if
-        len > 4
-        && str.[0] = 'P'
-        && str.[len - 1] = 'R'
-        && check_letters str 1 (len - 2) (function
-               | 'P' | 'A' | 'I' ->
-                   true
-               | _ ->
-                   false)
-      then
-        try
-          let (field_annots, annot) = extract_field_annots annot in
-          let ast = parse_pair_substr str ~len 0 in
-          let field_annots_pos = pappaiir_annots_pos ast field_annots in
-          let rec parse p (depth, acc) =
-            match p with
-            | P (i, left, right) ->
-                let annot =
-                  match (i, IntMap.find i field_annots_pos) with
-                  | (0, None) ->
-                      annot
-                  | (_, None) ->
-                      []
-                  | (0, Some ([], cdr_annot)) ->
-                      ("%" :: cdr_annot) @ annot
-                  | (_, Some ([], cdr_annot)) ->
-                      "%" :: cdr_annot
-                  | (0, Some (car_annot, cdr_annot)) ->
-                      car_annot @ cdr_annot @ annot
-                  | (_, Some (car_annot, cdr_annot)) ->
-                      car_annot @ cdr_annot
-                in
-                let acc =
-                  if depth = 0 then Prim (loc, "PAIR", [], annot) :: acc
-                  else
-                    dip ~loc depth (Seq (loc, [Prim (loc, "PAIR", [], annot)]))
-                    :: acc
-                in
-                (depth, acc) |> parse left |> parse right
-            | A | I ->
-                (depth + 1, acc)
-          in
-          let (_, expanded) = parse ast (0, []) in
-          ( match args with
-          | [] ->
-              ok ()
-          | _ :: _ ->
-              error (Invalid_arity (str, List.length args, 0)) )
-          >>? fun () -> ok (Some (Seq (loc, expanded)))
-        with Not_a_pair -> ok None
-      else ok None
-  | _ ->
-      ok None
-
-let expand_unpappaiir original =
-  match original with
-  | Prim (loc, str, args, _annot) ->
-      let len = String.length str in
-      if
-        len > 6
-        && String.sub str 0 3 = "UNP"
-        && str.[len - 1] = 'R'
-        && check_letters str 3 (len - 2) (function
-               | 'P' | 'A' | 'I' ->
-                   true
-               | _ ->
-                   false)
-      then
-        try
-          let unpair = Prim (loc, "UNPAIR", [], []) in
-          let ast = parse_pair_substr str ~len 2 in
-          let rec parse p (depth, acc) =
-            match p with
-            | P (_i, left, right) ->
-                let acc =
-                  if depth = 0 then unpair :: acc
-                  else dip ~loc depth (Seq (loc, [unpair])) :: acc
-                in
-                (depth, acc) |> parse left |> parse right
-            | A | I ->
-                (depth + 1, acc)
-          in
-          let (_, rev_expanded) = parse ast (0, []) in
-          let expanded = Seq (loc, List.rev rev_expanded) in
-          ( match args with
-          | [] ->
-              ok ()
-          | _ :: _ ->
-              error (Invalid_arity (str, List.length args, 0)) )
-          >>? fun () -> ok (Some expanded)
-        with Not_a_pair -> ok None
-      else ok None
-  | _ ->
-      ok None
-
-exception Not_a_dup
-
-let expand_deprecated_duuuuup original =
-  (* transparently expands deprecated macro [DU...UP] to [{ DUP n }] *)
-  match original with
-  | Prim (loc, str, args, annot) ->
-      let len = String.length str in
-      if
-        len > 3
-        && str.[0] = 'D'
-        && str.[len - 1] = 'P'
-        && check_letters str 1 (len - 2) (( = ) 'U')
-      then
-        ( match args with
-        | [] ->
-            ok ()
-        | _ :: _ ->
-            error (Invalid_arity (str, List.length args, 0)) )
-        >>? fun () ->
-        try
-          let rec parse i =
-            if i = 1 then
-              Prim (loc, "DUP", [Int (loc, Z.of_int (len - 2))], annot)
-            else if str.[i] = 'U' then parse (i - 1)
-            else raise_notrace Not_a_dup
-          in
-          ok (Some (parse (len - 2)))
-        with Not_a_dup -> ok None
-      else ok None
-  | _ ->
-      ok None
-
-let expand_compare original =
-  let cmp loc is annot =
-    let is =
-      match List.rev_map (fun i -> Prim (loc, i, [], [])) is with
-      | Prim (loc, i, args, _) :: r ->
-          List.rev (Prim (loc, i, args, annot) :: r)
-      | is ->
-          List.rev is
-    in
-    ok (Some (Seq (loc, is)))
-  in
-  let ifcmp loc is l r annot =
-    let is =
-      List.map (fun i -> Prim (loc, i, [], [])) is
-      @ [Prim (loc, "IF", [l; r], annot)]
-    in
-    ok (Some (Seq (loc, is)))
-  in
-  match original with
-  | Prim (loc, "CMPEQ", [], annot) ->
-      cmp loc ["COMPARE"; "EQ"] annot
-  | Prim (loc, "CMPNEQ", [], annot) ->
-      cmp loc ["COMPARE"; "NEQ"] annot
-  | Prim (loc, "CMPLT", [], annot) ->
-      cmp loc ["COMPARE"; "LT"] annot
-  | Prim (loc, "CMPGT", [], annot) ->
-      cmp loc ["COMPARE"; "GT"] annot
-  | Prim (loc, "CMPLE", [], annot) ->
-      cmp loc ["COMPARE"; "LE"] annot
-  | Prim (loc, "CMPGE", [], annot) ->
-      cmp loc ["COMPARE"; "GE"] annot
-  | Prim
-      ( _,
-        (("CMPEQ" | "CMPNEQ" | "CMPLT" | "CMPGT" | "CMPLE" | "CMPGE") as str),
-        args,
-        [] ) ->
-      error (Invalid_arity (str, List.length args, 0))
-  | Prim (loc, "IFCMPEQ", [l; r], annot) ->
-      ifcmp loc ["COMPARE"; "EQ"] l r annot
-  | Prim (loc, "IFCMPNEQ", [l; r], annot) ->
-      ifcmp loc ["COMPARE"; "NEQ"] l r annot
-  | Prim (loc, "IFCMPLT", [l; r], annot) ->
-      ifcmp loc ["COMPARE"; "LT"] l r annot
-  | Prim (loc, "IFCMPGT", [l; r], annot) ->
-      ifcmp loc ["COMPARE"; "GT"] l r annot
-  | Prim (loc, "IFCMPLE", [l; r], annot) ->
-      ifcmp loc ["COMPARE"; "LE"] l r annot
-  | Prim (loc, "IFCMPGE", [l; r], annot) ->
-      ifcmp loc ["COMPARE"; "GE"] l r annot
-  | Prim (loc, "IFEQ", [l; r], annot) ->
-      ifcmp loc ["EQ"] l r annot
-  | Prim (loc, "IFNEQ", [l; r], annot) ->
-      ifcmp loc ["NEQ"] l r annot
-  | Prim (loc, "IFLT", [l; r], annot) ->
-      ifcmp loc ["LT"] l r annot
-  | Prim (loc, "IFGT", [l; r], annot) ->
-      ifcmp loc ["GT"] l r annot
-  | Prim (loc, "IFLE", [l; r], annot) ->
-      ifcmp loc ["LE"] l r annot
-  | Prim (loc, "IFGE", [l; r], annot) ->
-      ifcmp loc ["GE"] l r annot
-  | Prim
-      ( _,
-        ( ( "IFCMPEQ"
-          | "IFCMPNEQ"
-          | "IFCMPLT"
-          | "IFCMPGT"
-          | "IFCMPLE"
-          | "IFCMPGE"
-          | "IFEQ"
-          | "IFNEQ"
-          | "IFLT"
-          | "IFGT"
-          | "IFLE"
-          | "IFGE" ) as str ),
-        args,
-        [] ) ->
-      error (Invalid_arity (str, List.length args, 2))
-  | Prim
-      ( _,
-        ( ( "IFCMPEQ"
-          | "IFCMPNEQ"
-          | "IFCMPLT"
-          | "IFCMPGT"
-          | "IFCMPLE"
-          | "IFCMPGE"
-          | "IFEQ"
-          | "IFNEQ"
-          | "IFLT"
-          | "IFGT"
-          | "IFLE"
-          | "IFGE" ) as str ),
-        [],
-        _ :: _ ) ->
-      error (Unexpected_macro_annotation str)
-  | _ ->
-      ok None
-
-let expand_asserts original =
-  let may_rename loc = function
-    | [] ->
-        Seq (loc, [])
-    | annot ->
-        Seq (loc, [Prim (loc, "RENAME", [], annot)])
-  in
-  let fail_false ?(annot = []) loc =
-    [may_rename loc annot; Seq (loc, [Prim (loc, "FAIL", [], [])])]
-  in
-  let fail_true ?(annot = []) loc =
-    [Seq (loc, [Prim (loc, "FAIL", [], [])]); may_rename loc annot]
-  in
-  match original with
-  | Prim (loc, "ASSERT", [], []) ->
-      ok @@ Some (Seq (loc, [Prim (loc, "IF", fail_false loc, [])]))
-  | Prim (loc, "ASSERT_NONE", [], []) ->
-      ok @@ Some (Seq (loc, [Prim (loc, "IF_NONE", fail_false loc, [])]))
-  | Prim (loc, "ASSERT_SOME", [], annot) ->
-      ok @@ Some (Seq (loc, [Prim (loc, "IF_NONE", fail_true ~annot loc, [])]))
-  | Prim (loc, "ASSERT_LEFT", [], annot) ->
-      ok
-      @@ Some (Seq (loc, [Prim (loc, "IF_LEFT", fail_false ~annot loc, [])]))
-  | Prim (loc, "ASSERT_RIGHT", [], annot) ->
-      ok @@ Some (Seq (loc, [Prim (loc, "IF_LEFT", fail_true ~annot loc, [])]))
-  | Prim
-      ( _,
-        ( ( "ASSERT"
-          | "ASSERT_NONE"
-          | "ASSERT_SOME"
-          | "ASSERT_LEFT"
-          | "ASSERT_RIGHT" ) as str ),
-        args,
-        [] ) ->
-      error (Invalid_arity (str, List.length args, 0))
-  | Prim (_, (("ASSERT" | "ASSERT_NONE") as str), [], _ :: _) ->
-      error (Unexpected_macro_annotation str)
-  | Prim (loc, s, args, annot)
-    when String.(length s > 7 && equal (sub s 0 7) "ASSERT_") -> (
-      ( match args with
-      | [] ->
-          ok ()
-      | _ :: _ ->
-          error (Invalid_arity (s, List.length args, 0)) )
-      >>? fun () ->
-      ( match annot with
-      | _ :: _ ->
-          error (Unexpected_macro_annotation s)
-      | [] ->
-          ok () )
-      >>? fun () ->
-      let remaining = String.(sub s 7 (length s - 7)) in
-      let remaining_prim = Prim (loc, remaining, [], []) in
-      match remaining with
-      | "EQ" | "NEQ" | "LT" | "LE" | "GE" | "GT" ->
-          ok
-          @@ Some
-               (Seq
-                  (loc, [remaining_prim; Prim (loc, "IF", fail_false loc, [])]))
-      | _ -> (
-          expand_compare remaining_prim
-          >|? function
-          | None ->
-              None
-          | Some seq ->
-              Some (Seq (loc, [seq; Prim (loc, "IF", fail_false loc, [])])) ) )
-  | _ ->
-      ok None
-
-let expand_if_some = function
-  | Prim (loc, "IF_SOME", [right; left], annot) ->
-      ok @@ Some (Seq (loc, [Prim (loc, "IF_NONE", [left; right], annot)]))
-  | Prim (_, "IF_SOME", args, _annot) ->
-      error (Invalid_arity ("IF_SOME", List.length args, 2))
-  | _ ->
-      ok @@ None
-
-let expand_if_right = function
-  | Prim (loc, "IF_RIGHT", [right; left], annot) ->
-      ok @@ Some (Seq (loc, [Prim (loc, "IF_LEFT", [left; right], annot)]))
-  | Prim (_, "IF_RIGHT", args, _annot) ->
-      error (Invalid_arity ("IF_RIGHT", List.length args, 2))
-  | _ ->
-      ok @@ None
-
-let expand_fail = function
-  | Prim (loc, "FAIL", [], []) ->
-      ok
-      @@ Some
-           (Seq
-              ( loc,
-                [Prim (loc, "UNIT", [], []); Prim (loc, "FAILWITH", [], [])] ))
-  | _ ->
-      ok @@ None
-
-let expand original =
-  let rec try_expansions = function
-    | [] ->
-        ok @@ original
-    | expander :: expanders -> (
-        expander original
-        >>? function
-        | None -> try_expansions expanders | Some rewritten -> ok rewritten )
-  in
-  try_expansions
-    [ expand_carn;
-      expand_cdrn;
-      expand_caddadr;
-      expand_set_caddadr;
-      expand_map_caddadr;
-      expand_deprecated_dxiiivp;
-      (* expand_paaiair ; *)
-      expand_pappaiir;
-      (* expand_unpaaiair ; *)
-      expand_unpappaiir;
-      expand_deprecated_duuuuup;
-      expand_compare;
-      expand_asserts;
-      expand_if_some;
-      expand_if_right;
-      expand_fail ]
-
-let expand_rec expr =
-  let rec error_map (expanded, errors) f = function
-    | [] ->
-        (List.rev expanded, List.rev errors)
-    | hd :: tl ->
-        let (new_expanded, new_errors) = f hd in
-        error_map
-          (new_expanded :: expanded, List.rev_append new_errors errors)
-          f
-          tl
-  in
-  let error_map = error_map ([], []) in
-  let rec expand_rec expr =
-    match expand expr with
-    | Ok expanded -> (
-      match expanded with
-      | Seq (loc, items) ->
-          let (items, errors) = error_map expand_rec items in
-          (Seq (loc, items), errors)
-      | Prim (loc, name, args, annot) ->
-          let (args, errors) = error_map expand_rec args in
-          (Prim (loc, name, args, annot), errors)
-      | (Int _ | String _ | Bytes _) as atom ->
-          (atom, []) )
-    | Error errors ->
-        (expr, errors)
-  in
-  expand_rec expr
-
-let unexpand_carn_and_cdrn expanded =
-  match expanded with
-  | Seq (loc, [Prim (_, "GET", [Int (locn, n)], annot)]) ->
-      let (half, parity) = Z.ediv_rem n (Z.of_int 2) in
-      if Z.(parity = zero) then
-        Some (Prim (loc, "CDR", [Int (locn, half)], annot))
-      else Some (Prim (loc, "CAR", [Int (locn, half)], annot))
-  | _ ->
-      None
-
-let unexpand_caddadr expanded =
-  let rec rsteps acc = function
-    | [] ->
-        Some acc
-    | Prim (_, "CAR", [], []) :: rest ->
-        rsteps ("A" :: acc) rest
-    | Prim (_, "CDR", [], []) :: rest ->
-        rsteps ("D" :: acc) rest
-    | _ ->
-        None
-  in
-  match expanded with
-  | Seq (loc, (Prim (_, "CAR", [], []) :: _ as nodes))
-  | Seq (loc, (Prim (_, "CDR", [], []) :: _ as nodes)) -> (
-    match rsteps [] nodes with
-    | Some steps ->
-        let name = String.concat "" ("C" :: List.rev ("R" :: steps)) in
-        Some (Prim (loc, name, [], []))
-    | None ->
-        None )
-  | _ ->
-      None
-
-let unexpand_set_caddadr expanded =
-  let rec steps acc annots = function
-    | Seq
-        ( loc,
-          [ Prim (_, "CDR", [], _);
-            Prim (_, "SWAP", [], _);
-            Prim (_, "PAIR", [], _) ] ) ->
-        Some (loc, "A" :: acc, annots)
-    | Seq
-        ( loc,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "CAR", [], [field_annot]);
-            Prim (_, "DROP", [], []);
-            Prim (_, "CDR", [], _);
-            Prim (_, "SWAP", [], []);
-            Prim (_, "PAIR", [], _) ] ) ->
-        Some (loc, "A" :: acc, field_annot :: annots)
-    | Seq (loc, [Prim (_, "CAR", [], _); Prim (_, "PAIR", [], _)]) ->
-        Some (loc, "D" :: acc, annots)
-    | Seq
-        ( loc,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "CDR", [], [field_annot]);
-            Prim (_, "DROP", [], []);
-            Prim (_, "CAR", [], _);
-            Prim (_, "PAIR", [], _) ] ) ->
-        Some (loc, "D" :: acc, field_annot :: annots)
-    | Seq
-        ( _,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "DIP", [Seq (_, [Prim (_, "CAR", [], _); sub])], []);
-            Prim (_, "CDR", [], _);
-            Prim (_, "SWAP", [], []);
-            Prim (_, "PAIR", [], pair_annots) ] ) ->
-        let (_, pair_annots) = extract_field_annots pair_annots in
-        steps ("A" :: acc) (List.rev_append pair_annots annots) sub
-    | Seq
-        ( _,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], _); sub])], []);
-            Prim (_, "CAR", [], _);
-            Prim (_, "PAIR", [], pair_annots) ] ) ->
-        let (_, pair_annots) = extract_field_annots pair_annots in
-        steps ("D" :: acc) (List.rev_append pair_annots annots) sub
-    | _ ->
-        None
-  in
-  match steps [] [] expanded with
-  | Some (loc, steps, annots) ->
-      let name = String.concat "" ("SET_C" :: List.rev ("R" :: steps)) in
-      Some (Prim (loc, name, [], List.rev annots))
-  | None ->
-      None
-
-let unexpand_map_caddadr expanded =
-  let rec steps acc annots = function
-    | Seq
-        ( loc,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "CDR", [], _);
-            Prim (_, "SWAP", [], []);
-            Prim (_, "DIP", [Seq (_, [Prim (_, "CAR", [], []); code])], []);
-            Prim (_, "PAIR", [], _) ] ) ->
-        Some (loc, "A" :: acc, annots, code)
-    | Seq
-        ( loc,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "CDR", [], _);
-            Prim (_, "SWAP", [], []);
-            Prim
-              ( _,
-                "DIP",
-                [Seq (_, [Prim (_, "CAR", [], [field_annot]); code])],
-                [] );
-            Prim (_, "PAIR", [], _) ] ) ->
-        Some (loc, "A" :: acc, field_annot :: annots, code)
-    | Seq
-        ( loc,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "CDR", [], []);
-            code;
-            Prim (_, "SWAP", [], []);
-            Prim (_, "CAR", [], _);
-            Prim (_, "PAIR", [], _) ] ) ->
-        Some (loc, "D" :: acc, annots, code)
-    | Seq
-        ( loc,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "CDR", [], [field_annot]);
-            code;
-            Prim (_, "SWAP", [], []);
-            Prim (_, "CAR", [], _);
-            Prim (_, "PAIR", [], _) ] ) ->
-        Some (loc, "D" :: acc, field_annot :: annots, code)
-    | Seq
-        ( _,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "DIP", [Seq (_, [Prim (_, "CAR", [], _); sub])], []);
-            Prim (_, "CDR", [], _);
-            Prim (_, "SWAP", [], []);
-            Prim (_, "PAIR", [], pair_annots) ] ) ->
-        let (_, pair_annots) = extract_field_annots pair_annots in
-        steps ("A" :: acc) (List.rev_append pair_annots annots) sub
-    | Seq
-        ( _,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], []); sub])], []);
-            Prim (_, "CAR", [], []);
-            Prim (_, "PAIR", [], pair_annots) ] ) ->
-        let (_, pair_annots) = extract_field_annots pair_annots in
-        steps ("D" :: acc) (List.rev_append pair_annots annots) sub
-    | _ ->
-        None
-  in
-  match steps [] [] expanded with
-  | Some (loc, steps, annots, code) ->
-      let name = String.concat "" ("MAP_C" :: List.rev ("R" :: steps)) in
-      Some (Prim (loc, name, [code], List.rev annots))
-  | None ->
-      None
-
-let unexpand_deprecated_dxiiivp expanded =
-  (* transparently turn the old expansion of deprecated [DI...IP] to [DIP n] *)
-  match expanded with
-  | Seq
-      ( loc,
-        [Prim (_, "DIP", [(Seq (_, [Prim (_, "DIP", [_], [])]) as sub)], [])]
-      ) ->
-      let rec count acc = function
-        | Seq (_, [Prim (_, "DIP", [sub], [])]) ->
-            count (acc + 1) sub
-        | sub ->
-            (acc, sub)
-      in
-      let (depth, sub) = count 1 sub in
-      Some (Prim (loc, "DIP", [Int (loc, Z.of_int depth); sub], []))
-  | _ ->
-      None
-
-let unexpand_dupn expanded =
-  match expanded with
-  | Seq
-      ( loc,
-        [ Prim
-            (_, "DIP", [Int (_, np); Seq (_, [Prim (_, "DUP", [], annot)])], []);
-          Prim (_, "DIG", [Int (nloc, ng)], []) ] )
-    when Z.equal np (Z.pred ng) ->
-      Some (Prim (loc, "DUP", [Int (nloc, ng)], annot))
-  | _ ->
-      None
-
-let unexpand_deprecated_duuuuup expanded =
-  (* transparently turn the old expansion of deprecated [DU...UP] to [DUP n] *)
-  let rec expand n = function
-    | Seq (loc, [Prim (nloc, "DUP", [], annot)]) ->
-        if n = 1 then None
-        else Some (Prim (loc, "DUP", [Int (nloc, Z.of_int n)], annot))
-    | Seq (_, [Prim (_, "DIP", [expanded'], []); Prim (_, "SWAP", [], [])]) ->
-        expand (n + 1) expanded'
-    | _ ->
-        None
-  in
-  expand 1 expanded
-
-let rec normalize_pair_item ?(right = false) = function
-  | P (i, a, b) ->
-      P (i, normalize_pair_item a, normalize_pair_item ~right:true b)
-  | A when right ->
-      I
-  | A ->
-      A
-  | I ->
-      I
-
-let unexpand_pappaiir expanded =
-  match expanded with
-  | Seq (_, [Prim (_, "PAIR", [], [])]) ->
-      Some expanded
-  | Seq (loc, (_ :: _ as nodes)) -> (
-      let rec exec stack nodes =
-        match (nodes, stack) with
-        | ([], _) ->
-            stack
-        (* support new expansion using [DIP n] *)
-        | ( Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest,
-            a :: rstack )
-          when Z.to_int n > 1 ->
-            exec
-              ( a
-              :: exec
-                   rstack
-                   [ Prim
-                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
-                   ] )
-              rest
-        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, a :: rstack)
-          when Z.to_int n = 1 ->
-            exec (a :: exec rstack sub) rest
-        | (Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest, [])
-          when Z.to_int n > 1 ->
-            exec
-              ( A
-              :: exec
-                   []
-                   [ Prim
-                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
-                   ] )
-              rest
-        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, [])
-          when Z.to_int n = 1 ->
-            exec (A :: exec [] sub) rest
-        (* support old expansion using [DIP] *)
-        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, a :: rstack) ->
-            exec (a :: exec rstack sub) rest
-        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, []) ->
-            exec (A :: exec [] sub) rest
-        | (Prim (_, "PAIR", [], []) :: rest, a :: b :: rstack) ->
-            exec (P (0, a, b) :: rstack) rest
-        | (Prim (_, "PAIR", [], []) :: rest, [a]) ->
-            exec [P (0, a, I)] rest
-        | (Prim (_, "PAIR", [], []) :: rest, []) ->
-            exec [P (0, A, I)] rest
-        | _ ->
-            raise_notrace Not_a_pair
-      in
-      match exec [] nodes with
-      | [] ->
-          None
-      | res :: _ ->
-          let res = normalize_pair_item res in
-          let name = unparse_pair_item res in
-          Some (Prim (loc, name, [], []))
-      | exception Not_a_pair ->
-          None )
-  | _ ->
-      None
-
-let unexpand_unpappaiir expanded =
-  match expanded with
-  | Seq (loc, (_ :: _ as nodes)) -> (
-      let rec exec stack nodes =
-        match (nodes, stack) with
-        | ([], _) ->
-            stack
-        (* support new expansion using [DIP n] *)
-        | ( Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest,
-            a :: rstack )
-          when Z.to_int n > 1 ->
-            exec
-              ( a
-              :: exec
-                   rstack
-                   [ Prim
-                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
-                   ] )
-              rest
-        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, a :: rstack)
-          when Z.to_int n = 1 ->
-            exec (a :: exec rstack sub) rest
-        | (Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest, [])
-          when Z.to_int n > 1 ->
-            exec
-              ( A
-              :: exec
-                   []
-                   [ Prim
-                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
-                   ] )
-              rest
-        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, [])
-          when Z.to_int n = 1 ->
-            exec (A :: exec [] sub) rest
-        (* support old expansion using [DIP] *)
-        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, a :: rstack) ->
-            exec (a :: exec rstack sub) rest
-        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, []) ->
-            exec (A :: exec [] sub) rest
-        | ( Seq
-              ( _,
-                [ Prim (_, "DUP", [], []);
-                  Prim (_, "CAR", [], []);
-                  Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], [])])], []) ]
-              )
-            :: rest,
-            a :: b :: rstack ) ->
-            exec (P (0, a, b) :: rstack) rest
-        | ( Seq
-              ( _,
-                [ Prim (_, "DUP", [], []);
-                  Prim (_, "CAR", [], []);
-                  Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], [])])], []) ]
-              )
-            :: rest,
-            [a] ) ->
-            exec [P (0, a, I)] rest
-        | ( Seq
-              ( _,
-                [ Prim (_, "DUP", [], []);
-                  Prim (_, "CAR", [], []);
-                  Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], [])])], []) ]
-              )
-            :: rest,
-            [] ) ->
-            exec [P (0, A, I)] rest
-        | _ ->
-            raise_notrace Not_a_pair
-      in
-      match exec [] (List.rev nodes) with
-      | [] ->
-          None
-      | res :: _ ->
-          let res = normalize_pair_item res in
-          let name = "UN" ^ unparse_pair_item res in
-          Some (Prim (loc, name, [], []))
-      | exception Not_a_pair ->
-          None )
-  | _ ->
-      None
-
-let unexpand_compare expanded =
-  match expanded with
-  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "EQ", [], annot)]) ->
-      Some (Prim (loc, "CMPEQ", [], annot))
-  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "NEQ", [], annot)]) ->
-      Some (Prim (loc, "CMPNEQ", [], annot))
-  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "LT", [], annot)]) ->
-      Some (Prim (loc, "CMPLT", [], annot))
-  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "GT", [], annot)]) ->
-      Some (Prim (loc, "CMPGT", [], annot))
-  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "LE", [], annot)]) ->
-      Some (Prim (loc, "CMPLE", [], annot))
-  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "GE", [], annot)]) ->
-      Some (Prim (loc, "CMPGE", [], annot))
-  | Seq
-      ( loc,
-        [ Prim (_, "COMPARE", [], _);
-          Prim (_, "EQ", [], _);
-          Prim (_, "IF", args, annot) ] ) ->
-      Some (Prim (loc, "IFCMPEQ", args, annot))
-  | Seq
-      ( loc,
-        [ Prim (_, "COMPARE", [], _);
-          Prim (_, "NEQ", [], _);
-          Prim (_, "IF", args, annot) ] ) ->
-      Some (Prim (loc, "IFCMPNEQ", args, annot))
-  | Seq
-      ( loc,
-        [ Prim (_, "COMPARE", [], _);
-          Prim (_, "LT", [], _);
-          Prim (_, "IF", args, annot) ] ) ->
-      Some (Prim (loc, "IFCMPLT", args, annot))
-  | Seq
-      ( loc,
-        [ Prim (_, "COMPARE", [], _);
-          Prim (_, "GT", [], _);
-          Prim (_, "IF", args, annot) ] ) ->
-      Some (Prim (loc, "IFCMPGT", args, annot))
-  | Seq
-      ( loc,
-        [ Prim (_, "COMPARE", [], _);
-          Prim (_, "LE", [], _);
-          Prim (_, "IF", args, annot) ] ) ->
-      Some (Prim (loc, "IFCMPLE", args, annot))
-  | Seq
-      ( loc,
-        [ Prim (_, "COMPARE", [], _);
-          Prim (_, "GE", [], _);
-          Prim (_, "IF", args, annot) ] ) ->
-      Some (Prim (loc, "IFCMPGE", args, annot))
-  | Seq (loc, [Prim (_, "EQ", [], _); Prim (_, "IF", args, annot)]) ->
-      Some (Prim (loc, "IFEQ", args, annot))
-  | Seq (loc, [Prim (_, "NEQ", [], _); Prim (_, "IF", args, annot)]) ->
-      Some (Prim (loc, "IFNEQ", args, annot))
-  | Seq (loc, [Prim (_, "LT", [], _); Prim (_, "IF", args, annot)]) ->
-      Some (Prim (loc, "IFLT", args, annot))
-  | Seq (loc, [Prim (_, "GT", [], _); Prim (_, "IF", args, annot)]) ->
-      Some (Prim (loc, "IFGT", args, annot))
-  | Seq (loc, [Prim (_, "LE", [], _); Prim (_, "IF", args, annot)]) ->
-      Some (Prim (loc, "IFLE", args, annot))
-  | Seq (loc, [Prim (_, "GE", [], _); Prim (_, "IF", args, annot)]) ->
-      Some (Prim (loc, "IFGE", args, annot))
-  | _ ->
-      None
-
-let unexpand_asserts expanded =
-  match expanded with
-  | Seq
-      ( loc,
-        [ Prim
-            ( _,
-              "IF",
-              [ Seq (_, []);
-                Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT", [], []))
-  | Seq
-      ( loc,
-        [ Seq (_, [Prim (_, "COMPARE", [], []); Prim (_, comparison, [], [])]);
-          Prim
-            ( _,
-              "IF",
-              [ Seq (_, []);
-                Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_CMP" ^ comparison, [], []))
-  | Seq
-      ( loc,
-        [ Prim (_, comparison, [], []);
-          Prim
-            ( _,
-              "IF",
-              [ Seq (_, []);
-                Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_" ^ comparison, [], []))
-  | Seq
-      ( loc,
-        [ Prim
-            ( _,
-              "IF_NONE",
-              [ Seq (_, [Prim (_, "RENAME", [], annot)]);
-                Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_NONE", [], annot))
-  | Seq
-      ( loc,
-        [ Prim
-            ( _,
-              "IF_NONE",
-              [ Seq (_, []);
-                Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_NONE", [], []))
-  | Seq
-      ( loc,
-        [ Prim
-            ( _,
-              "IF_NONE",
-              [ Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] );
-                Seq (_, []) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_SOME", [], []))
-  | Seq
-      ( loc,
-        [ Prim
-            ( _,
-              "IF_NONE",
-              [ Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] );
-                Seq (_, [Prim (_, "RENAME", [], annot)]) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_SOME", [], annot))
-  | Seq
-      ( loc,
-        [ Prim
-            ( _,
-              "IF_LEFT",
-              [ Seq (_, []);
-                Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_LEFT", [], []))
-  | Seq
-      ( loc,
-        [ Prim
-            ( _,
-              "IF_LEFT",
-              [ Seq (_, [Prim (_, "RENAME", [], annot)]);
-                Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_LEFT", [], annot))
-  | Seq
-      ( loc,
-        [ Prim
-            ( _,
-              "IF_LEFT",
-              [ Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] );
-                Seq (_, []) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_RIGHT", [], []))
-  | Seq
-      ( loc,
-        [ Prim
-            ( _,
-              "IF_LEFT",
-              [ Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] );
-                Seq (_, [Prim (_, "RENAME", [], annot)]) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_RIGHT", [], annot))
-  | _ ->
-      None
-
-let unexpand_if_some = function
-  | Seq (loc, [Prim (_, "IF_NONE", [left; right], annot)]) ->
-      Some (Prim (loc, "IF_SOME", [right; left], annot))
-  | _ ->
-      None
-
-let unexpand_if_right = function
-  | Seq (loc, [Prim (_, "IF_LEFT", [left; right], annot)]) ->
-      Some (Prim (loc, "IF_RIGHT", [right; left], annot))
-  | _ ->
-      None
-
-let unexpand_fail = function
-  | Seq (loc, [Prim (_, "UNIT", [], []); Prim (_, "FAILWITH", [], [])]) ->
-      Some (Prim (loc, "FAIL", [], []))
-  | _ ->
-      None
-
-let unexpand original =
-  let try_unexpansions unexpanders =
-    match
-      List.fold_left
-        (fun acc f ->
-          match acc with
-          | None ->
-              f original
-          | Some rewritten ->
-              Some rewritten)
-        None
-        unexpanders
-    with
-    | None ->
-        original
-    | Some rewritten ->
-        rewritten
-  in
-  try_unexpansions
-    [ unexpand_asserts;
-      unexpand_carn_and_cdrn;
-      unexpand_caddadr;
-      unexpand_set_caddadr;
-      unexpand_map_caddadr;
-      unexpand_deprecated_dxiiivp;
-      unexpand_pappaiir;
-      unexpand_unpappaiir;
-      unexpand_deprecated_duuuuup;
-      unexpand_dupn;
-      unexpand_compare;
-      unexpand_if_some;
-      unexpand_if_right;
-      unexpand_fail ]
-
-(*
-   If an argument of Prim is a sequence, we do not want to unexpand
-   its root in case the source already contains an expanded macro. In
-   which case unexpansion would remove surrounding braces and generate
-   ill-formed code.
-
-   For example, DIIP { DIP { DUP }; SWAP } is not unexpandable but
-   DIIP {{ DIP { DUP }; SWAP }} (note the double braces) is unexpanded
-   to DIIP { DUUP }.
-
-   unexpand_rec_but_root is the same as unexpand_rec but does not try
-   to unexpand at root *)
-
-let rec unexpand_rec expr = unexpand_rec_but_root (unexpand expr)
-
-and unexpand_rec_but_root = function
-  | Seq (loc, items) ->
-      Seq (loc, List.map unexpand_rec items)
-  | Prim (loc, name, args, annot) ->
-      Prim (loc, name, List.map unexpand_rec_but_root args, annot)
-  | (Int _ | String _ | Bytes _) as atom ->
-      atom
-
-let () =
-  let open Data_encoding in
-  register_error_kind
-    `Permanent
-    ~id:"michelson.macros.unexpected_annotation"
-    ~title:"Unexpected annotation"
-    ~description:
-      "A macro had an annotation, but no annotation was permitted on this \
-       macro."
-    ~pp:(fun ppf -> Format.fprintf ppf "Unexpected annotation on macro %s.")
-    (obj1 (req "macro_name" string))
-    (function Unexpected_macro_annotation str -> Some str | _ -> None)
-    (fun s -> Unexpected_macro_annotation s) ;
-  register_error_kind
-    `Permanent
-    ~id:"michelson.macros.sequence_expected"
-    ~title:"Macro expects a sequence"
-    ~description:"An macro expects a sequence, but a sequence was not provided"
-    ~pp:(fun ppf name ->
-      Format.fprintf
-        ppf
-        "Macro %s expects a sequence, but did not receive one."
-        name)
-    (obj1 (req "macro_name" string))
-    (function Sequence_expected name -> Some name | _ -> None)
-    (fun name -> Sequence_expected name) ;
-  register_error_kind
-    `Permanent
-    ~id:"michelson.macros.bas_arity"
-    ~title:"Wrong number of arguments to macro"
-    ~description:"A wrong number of arguments was provided to a macro"
-    ~pp:(fun ppf (name, got, exp) ->
-      Format.fprintf
-        ppf
-        "Macro %s expects %d arguments, was given %d."
-        name
-        exp
-        got)
-    (obj3
-       (req "macro_name" string)
-       (req "given_number_of_arguments" uint16)
-       (req "expected_number_of_arguments" uint16))
-    (function
-      | Invalid_arity (name, got, exp) -> Some (name, got, exp) | _ -> None)
-    (fun (name, got, exp) -> Invalid_arity (name, got, exp))
diff --git a/src/main/main_errors/michelson_v1_macros.mli b/src/main/main_errors/michelson_v1_macros.mli
deleted file mode 100644
index 26f52ddaf..000000000
--- a/src/main/main_errors/michelson_v1_macros.mli
+++ /dev/null
@@ -1,87 +0,0 @@
-(*****************************************************************************)
-(*                                                                           *)
-(* Open Source License                                                       *)
-(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
-(*                                                                           *)
-(* Permission is hereby granted, free of charge, to any person obtaining a   *)
-(* copy of this software and associated documentation files (the "Software"),*)
-(* to deal in the Software without restriction, including without limitation *)
-(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
-(* and/or sell copies of the Software, and to permit persons to whom the     *)
-(* Software is furnished to do so, subject to the following conditions:      *)
-(*                                                                           *)
-(* The above copyright notice and this permission notice shall be included   *)
-(* in all copies or substantial portions of the Software.                    *)
-(*                                                                           *)
-(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
-(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
-(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
-(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
-(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
-(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
-(* DEALINGS IN THE SOFTWARE.                                                 *)
-(*                                                                           *)
-(*****************************************************************************)
-
-open Tezos_micheline
-open Tezos_base__TzPervasives
-
-type 'l node = ('l, string) Micheline.node
-
-type error += Unexpected_macro_annotation of string
-
-type error += Sequence_expected of string
-
-type error += Invalid_arity of string * int * int
-
-val expand : 'l node -> 'l node tzresult
-
-val expand_rec : 'l node -> 'l node * error list
-
-val expand_caddadr : 'l node -> 'l node option tzresult
-
-val expand_set_caddadr : 'l node -> 'l node option tzresult
-
-val expand_map_caddadr : 'l node -> 'l node option tzresult
-
-val expand_deprecated_dxiiivp : 'l node -> 'l node option tzresult
-
-val expand_pappaiir : 'l node -> 'l node option tzresult
-
-val expand_deprecated_duuuuup : 'l node -> 'l node option tzresult
-
-val expand_compare : 'l node -> 'l node option tzresult
-
-val expand_asserts : 'l node -> 'l node option tzresult
-
-val expand_unpappaiir : 'l node -> 'l node option tzresult
-
-val expand_if_some : 'l node -> 'l node option tzresult
-
-val expand_if_right : 'l node -> 'l node option tzresult
-
-val unexpand : 'l node -> 'l node
-
-val unexpand_rec : 'l node -> 'l node
-
-val unexpand_caddadr : 'l node -> 'l node option
-
-val unexpand_set_caddadr : 'l node -> 'l node option
-
-val unexpand_map_caddadr : 'l node -> 'l node option
-
-val unexpand_deprecated_dxiiivp : 'l node -> 'l node option
-
-val unexpand_pappaiir : 'l node -> 'l node option
-
-val unexpand_deprecated_duuuuup : 'l node -> 'l node option
-
-val unexpand_compare : 'l node -> 'l node option
-
-val unexpand_asserts : 'l node -> 'l node option
-
-val unexpand_unpappaiir : 'l node -> 'l node option
-
-val unexpand_if_some : 'l node -> 'l node option
-
-val unexpand_if_right : 'l node -> 'l node option
diff --git a/src/main/main_errors/michelson_v1_parser.ml b/src/main/main_errors/michelson_v1_parser.ml
deleted file mode 100644
index f41e68515..000000000
--- a/src/main/main_errors/michelson_v1_parser.ml
+++ /dev/null
@@ -1,131 +0,0 @@
-(*****************************************************************************)
-(*                                                                           *)
-(* Open Source License                                                       *)
-(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
-(*                                                                           *)
-(* Permission is hereby granted, free of charge, to any person obtaining a   *)
-(* copy of this software and associated documentation files (the "Software"),*)
-(* to deal in the Software without restriction, including without limitation *)
-(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
-(* and/or sell copies of the Software, and to permit persons to whom the     *)
-(* Software is furnished to do so, subject to the following conditions:      *)
-(*                                                                           *)
-(* The above copyright notice and this permission notice shall be included   *)
-(* in all copies or substantial portions of the Software.                    *)
-(*                                                                           *)
-(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
-(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
-(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
-(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
-(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
-(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
-(* DEALINGS IN THE SOFTWARE.                                                 *)
-(*                                                                           *)
-(*****************************************************************************)
-
-open Tezos_base__TzPervasives
-
-module Tezos_List = struct
-  let rev_map2 ~when_different_lengths f xs ys =
-    let open List in
-    let rec aux zs xs ys =
-      match (xs, ys) with
-      | ([], []) ->
-          Ok zs
-      | ([], _ :: _) | (_ :: _, []) ->
-          Error when_different_lengths
-      | (x :: xs, y :: ys) ->
-          let z = f x y in
-          (aux [@ocaml.tailcall]) (z :: zs) xs ys
-    in
-    aux [] xs ys
-
-  let map2 ~when_different_lengths f xs ys =
-    rev_map2 ~when_different_lengths f xs ys >|? List.rev
-end
-
-open Tezos_protocol_008_PtEdo2Zk.Protocol
-open Tezos_micheline
-open Micheline_parser
-open Micheline
-
-type parsed = {
-  source : string;
-  unexpanded : string canonical;
-  expanded : Michelson_v1_primitives.prim canonical;
-  expansion_table : (int * (Micheline_parser.location * int list)) list;
-  unexpansion_table : (int * int) list;
-}
-
-let compare_parsed = Stdlib.compare
-
-(* Unexpanded toplevel expression should be a sequence *)
-let expand_all source ast errors =
-  let (unexpanded, loc_table) = extract_locations ast in
-  let (expanded, expansion_errors) =
-    Michelson_v1_macros.expand_rec (root unexpanded)
-  in
-  let (expanded, unexpansion_table) = extract_locations expanded in
-  let expansion_table =
-    let sorted =
-      List.sort (fun (_, a) (_, b) -> Stdlib.compare a b) unexpansion_table
-    in
-    let grouped =
-      let rec group = function
-        | (acc, []) ->
-            acc
-        | ([], (u, e) :: r) ->
-            group ([(e, [u])], r)
-        | (((pe, us) :: racc as acc), (u, e) :: r) ->
-            if e = pe then group ((e, u :: us) :: racc, r)
-            else group ((e, [u]) :: acc, r)
-      in
-      group ([], sorted)
-    in
-    match
-      Tezos_List.map2
-        ~when_different_lengths:()
-        (fun (l, ploc) (l', elocs) ->
-          assert (l = l') ;
-          (l, (ploc, elocs)))
-        (List.sort Stdlib.compare loc_table)
-        (List.sort Stdlib.compare grouped)
-    with
-    | Ok v ->
-        v
-    | Error () ->
-        invalid_arg "Michelson_v1_parser.expand_all"
-  in
-  match
-    Environment.wrap_error (Michelson_v1_primitives.prims_of_strings expanded)
-  with
-  | Ok expanded ->
-      ( {source; unexpanded; expanded; expansion_table; unexpansion_table},
-        errors @ expansion_errors )
-  | Error errs ->
-      ( {
-          source;
-          unexpanded;
-          expanded = Micheline.strip_locations (Seq ((), []));
-          expansion_table;
-          unexpansion_table;
-        },
-        errors @ expansion_errors @ errs )
-
-let parse_toplevel ?check source =
-  let (tokens, lexing_errors) = Micheline_parser.tokenize source in
-  let (asts, parsing_errors) = Micheline_parser.parse_toplevel ?check tokens in
-  let ast =
-    let start = min_point asts and stop = max_point asts in
-    Seq ({start; stop}, asts)
-  in
-  expand_all source ast (lexing_errors @ parsing_errors)
-
-let parse_expression ?check source =
-  let (tokens, lexing_errors) = Micheline_parser.tokenize source in
-  let (ast, parsing_errors) =
-    Micheline_parser.parse_expression ?check tokens
-  in
-  expand_all source ast (lexing_errors @ parsing_errors)
-
-let expand_all ~source ~original = expand_all source original []
diff --git a/src/main/main_errors/michelson_v1_parser.mli b/src/main/main_errors/michelson_v1_parser.mli
deleted file mode 100644
index 6a85aaf0a..000000000
--- a/src/main/main_errors/michelson_v1_parser.mli
+++ /dev/null
@@ -1,55 +0,0 @@
-(*****************************************************************************)
-(*                                                                           *)
-(* Open Source License                                                       *)
-(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
-(*                                                                           *)
-(* Permission is hereby granted, free of charge, to any person obtaining a   *)
-(* copy of this software and associated documentation files (the "Software"),*)
-(* to deal in the Software without restriction, including without limitation *)
-(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
-(* and/or sell copies of the Software, and to permit persons to whom the     *)
-(* Software is furnished to do so, subject to the following conditions:      *)
-(*                                                                           *)
-(* The above copyright notice and this permission notice shall be included   *)
-(* in all copies or substantial portions of the Software.                    *)
-(*                                                                           *)
-(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
-(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
-(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
-(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
-(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
-(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
-(* DEALINGS IN THE SOFTWARE.                                                 *)
-(*                                                                           *)
-(*****************************************************************************)
-
-open Tezos_protocol_008_PtEdo2Zk.Protocol
-open Alpha_context
-open Tezos_micheline
-
-(** The result of parsing and expanding a Michelson V1 script or data. *)
-type parsed = {
-  source : string;  (** The original source code. *)
-  unexpanded : string Micheline.canonical;
-      (** Original expression with macros. *)
-  expanded : Script.expr;  (** Expression with macros fully expanded. *)
-  expansion_table : (int * (Micheline_parser.location * int list)) list;
-      (** Associates unexpanded nodes to their parsing locations and
-        the nodes expanded from it in the expanded expression. *)
-  unexpansion_table : (int * int) list;
-      (** Associates an expanded node to its source in the unexpanded
-        expression. *)
-}
-
-val compare_parsed : parsed -> parsed -> int
-
-val parse_toplevel :
-  ?check:bool -> string -> parsed Micheline_parser.parsing_result
-
-val parse_expression :
-  ?check:bool -> string -> parsed Micheline_parser.parsing_result
-
-val expand_all :
-  source:string ->
-  original:Micheline_parser.node ->
-  parsed Micheline_parser.parsing_result
diff --git a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam
new file mode 100644
index 000000000..672138279
--- /dev/null
+++ b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam
@@ -0,0 +1,25 @@
+opam-version: "2.0"
+maintainer: "contact@tezos.com"
+authors: [ "Tezos devteam" ]
+homepage: "https://www.tezos.com/"
+bug-reports: "https://gitlab.com/tezos/tezos/issues"
+dev-repo: "git+https://gitlab.com/tezos/tezos.git"
+license: "MIT"
+depends: [
+  "dune" { >= "2.0" }
+  "tezos-base"
+  "tezos-utils"
+  "tezos-stdlib-unix"
+  "tezos-shell-services"
+  "tezos-protocol-environment"
+  "tezos-protocol-008-PtEdo2Zk"
+  "tezos-protocol-008-PtEdo2Zk-parameters"
+  "tezos-memory-proto-alpha"
+  # "tezos-client-008-PtEdo2Zk"
+  "alcotest-lwt" {with-test}
+]
+build: [
+  ["dune" "build" "-p" name "-j" jobs]
+  ["dune" "runtest" "-p" name "-j" jobs] {with-test}
+]
+synopsis: "Slim version of tezos client"
diff --git a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils_008_PtEdo2Zk.ml b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils_008_PtEdo2Zk.ml
new file mode 100644
index 000000000..20242c058
--- /dev/null
+++ b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils_008_PtEdo2Zk.ml
@@ -0,0 +1,6 @@
+module Michelson_v1_macros = Michelson_v1_macros
+
+module Michelson_v1_parser = Michelson_v1_parser
+
+module Michelson_v1_printer = Michelson_v1_printer
+
diff --git a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/dune b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/dune
new file mode 100644
index 000000000..e481f0f97
--- /dev/null
+++ b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/dune
@@ -0,0 +1,19 @@
+; This library is vendored bits and pieces of the tezos client to reduce footprint
+
+(library
+ (name client_utils_008_PtEdo2Zk)
+ (public_name client_utils-008-PtEdo2Zk)
+ (libraries
+  tezos-base
+  tezos-stdlib-unix
+  tezos-protocol-008-PtEdo2Zk
+  tezos-protocol-008-PtEdo2Zk-parameters
+  tezos-protocol-environment
+  tezos-memory-proto-alpha
+  data-encoding
+  simple-utils
+  tezos-utils
+  tezos-shell-services
+  tezos-error-monad)
+ (flags
+  (:standard -open Simple_utils -open Tezos_base__TzPervasives)))
diff --git a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/dune-project b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/dune-project
new file mode 100644
index 000000000..49f2cf7a6
--- /dev/null
+++ b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/dune-project
@@ -0,0 +1,2 @@
+(lang dune 1.11)
+(name client_utils-008-PtEdo2Zk)
diff --git a/src/main/main_errors/michelson_v1_error_reporter.ml b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_error_reporter.ml
similarity index 100%
rename from src/main/main_errors/michelson_v1_error_reporter.ml
rename to vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_error_reporter.ml
diff --git a/src/main/main_errors/michelson_v1_error_reporter.mli b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_error_reporter.mli
similarity index 100%
rename from src/main/main_errors/michelson_v1_error_reporter.mli
rename to vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_error_reporter.mli
diff --git a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_macros.ml b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_macros.ml
similarity index 100%
rename from vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_macros.ml
rename to vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_macros.ml
diff --git a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_macros.mli b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_macros.mli
similarity index 100%
rename from vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_macros.mli
rename to vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_macros.mli
diff --git a/vendors/ligo-utils/proto-alpha-utils/michelson_v1_parser.ml b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_parser.ml
similarity index 99%
rename from vendors/ligo-utils/proto-alpha-utils/michelson_v1_parser.ml
rename to vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_parser.ml
index f41e68515..d6e80b0c4 100644
--- a/vendors/ligo-utils/proto-alpha-utils/michelson_v1_parser.ml
+++ b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_parser.ml
@@ -23,8 +23,6 @@
 (*                                                                           *)
 (*****************************************************************************)
 
-open Tezos_base__TzPervasives
-
 module Tezos_List = struct
   let rev_map2 ~when_different_lengths f xs ys =
     let open List in
diff --git a/vendors/ligo-utils/proto-alpha-utils/michelson_v1_parser.mli b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_parser.mli
similarity index 98%
rename from vendors/ligo-utils/proto-alpha-utils/michelson_v1_parser.mli
rename to vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_parser.mli
index 6a85aaf0a..0c184fff7 100644
--- a/vendors/ligo-utils/proto-alpha-utils/michelson_v1_parser.mli
+++ b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_parser.mli
@@ -24,7 +24,7 @@
 (*****************************************************************************)
 
 open Tezos_protocol_008_PtEdo2Zk.Protocol
-open Alpha_context
+open Memory_proto_alpha.Protocol.Alpha_context
 open Tezos_micheline
 
 (** The result of parsing and expanding a Michelson V1 script or data. *)
diff --git a/src/main/main_errors/michelson_v1_printer.ml b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_printer.ml
similarity index 99%
rename from src/main/main_errors/michelson_v1_printer.ml
rename to vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_printer.ml
index 4535d456a..7110b82ff 100644
--- a/src/main/main_errors/michelson_v1_printer.ml
+++ b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_printer.ml
@@ -24,7 +24,6 @@
 (*****************************************************************************)
 
 open Tezos_protocol_008_PtEdo2Zk.Protocol
-open Tezos_base__TzPervasives
 open Alpha_context
 open Tezos_micheline
 open Micheline
diff --git a/src/main/main_errors/michelson_v1_printer.mli b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_printer.mli
similarity index 100%
rename from src/main/main_errors/michelson_v1_printer.mli
rename to vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_printer.mli
diff --git a/src/main/main_errors/operation_result.ml b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/operation_result.ml
similarity index 100%
rename from src/main/main_errors/operation_result.ml
rename to vendors/ligo-utils/client_utils_008_PtEdo2Zk/operation_result.ml
diff --git a/src/main/main_errors/operation_result.mli b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/operation_result.mli
similarity index 100%
rename from src/main/main_errors/operation_result.mli
rename to vendors/ligo-utils/client_utils_008_PtEdo2Zk/operation_result.mli
diff --git a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/dune b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/dune
index 768fdd99e..13fe4c0da 100644
--- a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/dune
+++ b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/dune
@@ -9,6 +9,7 @@
             tezos-protocol-008-PtEdo2Zk
             tezos-protocol-008-PtEdo2Zk-parameters
             tezos-error-monad
+            client_utils-008-PtEdo2Zk
             ;tezos-client-008-PtEdo2Zk
  )
  (flags (:standard -open Tezos_base__TzPervasives
@@ -16,5 +17,6 @@
                    -open Tezos_stdlib_unix
                    -open Tezos_protocol_008_PtEdo2Zk
                    ;-open Tezos_client_008_PtEdo2Zk
+                   -open Client_utils_008_PtEdo2Zk
                    -open Tezos_protocol_environment_008_PtEdo2Zk
-                   -open Tezos_shell_services)))
\ No newline at end of file
+                   -open Tezos_shell_services)))
diff --git a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/ligo-008-PtEdo2Zk-test-helpers.opam b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/ligo-008-PtEdo2Zk-test-helpers.opam
index 2e9913076..48c767a00 100644
--- a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/ligo-008-PtEdo2Zk-test-helpers.opam
+++ b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/ligo-008-PtEdo2Zk-test-helpers.opam
@@ -13,6 +13,7 @@ depends: [
   "tezos-protocol-environment"
   "tezos-protocol-008-PtEdo2Zk"
   "tezos-protocol-008-PtEdo2Zk-parameters"
+  "client_utils-008-PtEdo2Zk"
   # "tezos-client-008-PtEdo2Zk"
   "alcotest-lwt"
 ]
diff --git a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_parser.ml b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_parser.ml
deleted file mode 100644
index a74caa039..000000000
--- a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_parser.ml
+++ /dev/null
@@ -1,129 +0,0 @@
-(*****************************************************************************)
-(*                                                                           *)
-(* Open Source License                                                       *)
-(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
-(*                                                                           *)
-(* Permission is hereby granted, free of charge, to any person obtaining a   *)
-(* copy of this software and associated documentation files (the "Software"),*)
-(* to deal in the Software without restriction, including without limitation *)
-(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
-(* and/or sell copies of the Software, and to permit persons to whom the     *)
-(* Software is furnished to do so, subject to the following conditions:      *)
-(*                                                                           *)
-(* The above copyright notice and this permission notice shall be included   *)
-(* in all copies or substantial portions of the Software.                    *)
-(*                                                                           *)
-(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
-(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
-(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
-(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
-(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
-(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
-(* DEALINGS IN THE SOFTWARE.                                                 *)
-(*                                                                           *)
-(*****************************************************************************)
-
-module Tezos_List = struct
-  let rev_map2 ~when_different_lengths f xs ys =
-    let open List in
-    let rec aux zs xs ys =
-      match (xs, ys) with
-      | ([], []) ->
-          Ok zs
-      | ([], _ :: _) | (_ :: _, []) ->
-          Error when_different_lengths
-      | (x :: xs, y :: ys) ->
-          let z = f x y in
-          (aux [@ocaml.tailcall]) (z :: zs) xs ys
-    in
-    aux [] xs ys
-
-  let map2 ~when_different_lengths f xs ys =
-    rev_map2 ~when_different_lengths f xs ys >|? List.rev
-end
-
-open Protocol
-open Tezos_micheline
-open Micheline_parser
-open Micheline
-
-type parsed = {
-  source : string;
-  unexpanded : string canonical;
-  expanded : Michelson_v1_primitives.prim canonical;
-  expansion_table : (int * (Micheline_parser.location * int list)) list;
-  unexpansion_table : (int * int) list;
-}
-
-let compare_parsed = Stdlib.compare
-
-(* Unexpanded toplevel expression should be a sequence *)
-let expand_all source ast errors =
-  let (unexpanded, loc_table) = extract_locations ast in
-  let (expanded, expansion_errors) =
-    Michelson_v1_macros.expand_rec (root unexpanded)
-  in
-  let (expanded, unexpansion_table) = extract_locations expanded in
-  let expansion_table =
-    let sorted =
-      List.sort (fun (_, a) (_, b) -> Stdlib.compare a b) unexpansion_table
-    in
-    let grouped =
-      let rec group = function
-        | (acc, []) ->
-            acc
-        | ([], (u, e) :: r) ->
-            group ([(e, [u])], r)
-        | (((pe, us) :: racc as acc), (u, e) :: r) ->
-            if e = pe then group ((e, u :: us) :: racc, r)
-            else group ((e, [u]) :: acc, r)
-      in
-      group ([], sorted)
-    in
-    match
-      Tezos_List.map2
-        ~when_different_lengths:()
-        (fun (l, ploc) (l', elocs) ->
-          assert (l = l') ;
-          (l, (ploc, elocs)))
-        (List.sort Stdlib.compare loc_table)
-        (List.sort Stdlib.compare grouped)
-    with
-    | Ok v ->
-        v
-    | Error () ->
-        invalid_arg "Michelson_v1_parser.expand_all"
-  in
-  match
-    Environment.wrap_error (Michelson_v1_primitives.prims_of_strings expanded)
-  with
-  | Ok expanded ->
-      ( {source; unexpanded; expanded; expansion_table; unexpansion_table},
-        errors @ expansion_errors )
-  | Error errs ->
-      ( {
-          source;
-          unexpanded;
-          expanded = Micheline.strip_locations (Seq ((), []));
-          expansion_table;
-          unexpansion_table;
-        },
-        errors @ expansion_errors @ errs )
-
-let parse_toplevel ?check source =
-  let (tokens, lexing_errors) = Micheline_parser.tokenize source in
-  let (asts, parsing_errors) = Micheline_parser.parse_toplevel ?check tokens in
-  let ast =
-    let start = min_point asts and stop = max_point asts in
-    Seq ({start; stop}, asts)
-  in
-  expand_all source ast (lexing_errors @ parsing_errors)
-
-let parse_expression ?check source =
-  let (tokens, lexing_errors) = Micheline_parser.tokenize source in
-  let (ast, parsing_errors) =
-    Micheline_parser.parse_expression ?check tokens
-  in
-  expand_all source ast (lexing_errors @ parsing_errors)
-
-let expand_all ~source ~original = expand_all source original []
diff --git a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_parser.mli b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_parser.mli
deleted file mode 100644
index 6aa296767..000000000
--- a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_parser.mli
+++ /dev/null
@@ -1,55 +0,0 @@
-(*****************************************************************************)
-(*                                                                           *)
-(* Open Source License                                                       *)
-(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
-(*                                                                           *)
-(* Permission is hereby granted, free of charge, to any person obtaining a   *)
-(* copy of this software and associated documentation files (the "Software"),*)
-(* to deal in the Software without restriction, including without limitation *)
-(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
-(* and/or sell copies of the Software, and to permit persons to whom the     *)
-(* Software is furnished to do so, subject to the following conditions:      *)
-(*                                                                           *)
-(* The above copyright notice and this permission notice shall be included   *)
-(* in all copies or substantial portions of the Software.                    *)
-(*                                                                           *)
-(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
-(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
-(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
-(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
-(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
-(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
-(* DEALINGS IN THE SOFTWARE.                                                 *)
-(*                                                                           *)
-(*****************************************************************************)
-
-open Protocol
-open Alpha_context
-open Tezos_micheline
-
-(** The result of parsing and expanding a Michelson V1 script or data. *)
-type parsed = {
-  source : string;  (** The original source code. *)
-  unexpanded : string Micheline.canonical;
-      (** Original expression with macros. *)
-  expanded : Script.expr;  (** Expression with macros fully expanded. *)
-  expansion_table : (int * (Micheline_parser.location * int list)) list;
-      (** Associates unexpanded nodes to their parsing locations and
-        the nodes expanded from it in the expanded expression. *)
-  unexpansion_table : (int * int) list;
-      (** Associates an expanded node to its source in the unexpanded
-        expression. *)
-}
-
-val compare_parsed : parsed -> parsed -> int
-
-val parse_toplevel :
-  ?check:bool -> string -> parsed Micheline_parser.parsing_result
-
-val parse_expression :
-  ?check:bool -> string -> parsed Micheline_parser.parsing_result
-
-val expand_all :
-  source:string ->
-  original:Micheline_parser.node ->
-  parsed Micheline_parser.parsing_result
diff --git a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_printer.ml b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_printer.ml
deleted file mode 100644
index 702bbb802..000000000
--- a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_printer.ml
+++ /dev/null
@@ -1,269 +0,0 @@
-(*****************************************************************************)
-(*                                                                           *)
-(* Open Source License                                                       *)
-(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
-(*                                                                           *)
-(* Permission is hereby granted, free of charge, to any person obtaining a   *)
-(* copy of this software and associated documentation files (the "Software"),*)
-(* to deal in the Software without restriction, including without limitation *)
-(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
-(* and/or sell copies of the Software, and to permit persons to whom the     *)
-(* Software is furnished to do so, subject to the following conditions:      *)
-(*                                                                           *)
-(* The above copyright notice and this permission notice shall be included   *)
-(* in all copies or substantial portions of the Software.                    *)
-(*                                                                           *)
-(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
-(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
-(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
-(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
-(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
-(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
-(* DEALINGS IN THE SOFTWARE.                                                 *)
-(*                                                                           *)
-(*****************************************************************************)
-
-open Protocol
-open Alpha_context
-open Tezos_micheline
-open Micheline
-open Micheline_printer
-
-let rec assoc ~equal k = function
-  | [] ->
-      None
-  | (kk, v) :: kvs ->
-      if equal k kk then Some v else assoc ~equal k kvs
-
-let hd = function x :: _ -> Some x | [] -> None
-
-let anon = {comment = None}
-
-let print_expr ppf expr =
-  expr |> Michelson_v1_primitives.strings_of_prims
-  |> Micheline.inject_locations (fun _ -> anon)
-  |> print_expr ppf
-
-let print_expr_unwrapped ppf expr =
-  expr |> Michelson_v1_primitives.strings_of_prims
-  |> Micheline.inject_locations (fun _ -> anon)
-  |> print_expr_unwrapped ppf
-
-let print_var_annots ppf = List.iter (Format.fprintf ppf "%s ")
-
-let print_annot_expr_unwrapped ppf (expr, annot) =
-  Format.fprintf ppf "%a%a" print_var_annots annot print_expr_unwrapped expr
-
-let print_stack ppf = function
-  | [] ->
-      Format.fprintf ppf "[]"
-  | more ->
-      Format.fprintf
-        ppf
-        "@[<hov 0>[ %a ]@]"
-        (Format.pp_print_list
-           ~pp_sep:(fun ppf () -> Format.fprintf ppf "@ : ")
-           print_annot_expr_unwrapped)
-        more
-
-let print_execution_trace ppf trace =
-  Format.pp_print_list
-    (fun ppf (loc, gas, stack) ->
-      Format.fprintf
-        ppf
-        "- @[<v 0>location: %d (remaining gas: %a)@,[ @[<v 0>%a ]@]@]"
-        loc
-        Gas.pp
-        gas
-        (Format.pp_print_list (fun ppf (e, annot) ->
-             Format.fprintf
-               ppf
-               "@[<v 0>%a  \t%s@]"
-               print_expr
-               e
-               (match annot with None -> "" | Some a -> a)))
-        stack)
-    ppf
-    trace
-
-let print_big_map_diff ppf lazy_storage_diff =
-  let diff =
-    Contract.Legacy_big_map_diff.of_lazy_storage_diff lazy_storage_diff
-  in
-  let pp_map ppf id =
-    if Compare.Z.(id < Z.zero) then
-      Format.fprintf ppf "temp(%s)" (Z.to_string (Z.neg id))
-    else Format.fprintf ppf "map(%s)" (Z.to_string id)
-  in
-  Format.fprintf
-    ppf
-    "@[<v 0>%a@]"
-    (Format.pp_print_list ~pp_sep:Format.pp_print_space (fun ppf ->
-       function
-       | Contract.Legacy_big_map_diff.Clear id ->
-           Format.fprintf ppf "Clear %a" pp_map id
-       | Contract.Legacy_big_map_diff.Alloc {big_map; key_type; value_type} ->
-           Format.fprintf
-             ppf
-             "New %a of type (big_map %a %a)"
-             pp_map
-             big_map
-             print_expr
-             key_type
-             print_expr
-             value_type
-       | Contract.Legacy_big_map_diff.Copy {src; dst} ->
-           Format.fprintf ppf "Copy %a to %a" pp_map src pp_map dst
-       | Contract.Legacy_big_map_diff.Update {big_map; diff_key; diff_value; _}
-         ->
-           Format.fprintf
-             ppf
-             "%s %a[%a]%a"
-             (match diff_value with None -> "Unset" | Some _ -> "Set")
-             pp_map
-             big_map
-             print_expr
-             diff_key
-             (fun ppf -> function None -> () | Some x ->
-                   Format.fprintf ppf " to %a" print_expr x)
-             diff_value))
-    (diff :> Contract.Legacy_big_map_diff.item list)
-
-let inject_types type_map parsed =
-  let rec inject_expr = function
-    | Seq (loc, items) ->
-        Seq (inject_loc `before loc, List.map inject_expr items)
-    | Prim (loc, name, items, annot) ->
-        Prim (inject_loc `after loc, name, List.map inject_expr items, annot)
-    | Int (loc, value) ->
-        Int (inject_loc `after loc, value)
-    | String (loc, value) ->
-        String (inject_loc `after loc, value)
-    | Bytes (loc, value) ->
-        Bytes (inject_loc `after loc, value)
-  and inject_loc which loc =
-    let comment =
-      let ( >?? ) = Option.bind in
-      assoc
-        ~equal:Int.equal
-        loc
-        parsed.Michelson_v1_parser.expansion_table
-      >?? fun (_, locs) ->
-      let locs = List.sort compare locs in
-      hd locs
-      >?? fun head_loc ->
-      assoc ~equal:Int.equal head_loc type_map
-      >?? fun (bef, aft) ->
-      let stack = match which with `before -> bef | `after -> aft in
-      Some (Format.asprintf "%a" print_stack stack)
-    in
-    {comment}
-  in
-  inject_expr (root parsed.unexpanded)
-
-let unparse ?type_map parse expanded =
-  let source =
-    match type_map with
-    | Some type_map ->
-        let (unexpanded, unexpansion_table) =
-          expanded |> Michelson_v1_primitives.strings_of_prims |> root
-          |> Michelson_v1_macros.unexpand_rec |> Micheline.extract_locations
-        in
-        let rec inject_expr = function
-          | Seq (loc, items) ->
-              Seq (inject_loc `before loc, List.map inject_expr items)
-          | Prim (loc, name, items, annot) ->
-              Prim
-                (inject_loc `after loc, name, List.map inject_expr items, annot)
-          | Int (loc, value) ->
-              Int (inject_loc `after loc, value)
-          | String (loc, value) ->
-              String (inject_loc `after loc, value)
-          | Bytes (loc, value) ->
-              Bytes (inject_loc `after loc, value)
-        and inject_loc which loc =
-          let comment =
-            let ( >?? ) = Option.bind in
-            assoc ~equal:Int.equal loc unexpansion_table
-            >?? fun loc ->
-            assoc ~equal:Int.equal loc type_map
-            >?? fun (bef, aft) ->
-            let stack = match which with `before -> bef | `after -> aft in
-            Some (Format.asprintf "%a" print_stack stack)
-          in
-          {comment}
-        in
-        unexpanded |> root |> inject_expr
-        |> Format.asprintf "%a" Micheline_printer.print_expr
-    | None ->
-        expanded |> Michelson_v1_primitives.strings_of_prims |> root
-        |> Michelson_v1_macros.unexpand_rec |> Micheline.strip_locations
-        |> Micheline_printer.printable (fun n -> n)
-        |> Format.asprintf "%a" Micheline_printer.print_expr
-  in
-  match parse source with
-  | (res, []) ->
-      res
-  | (_, _ :: _) ->
-      Stdlib.failwith "Michelson_v1_printer.unparse"
-
-let unparse_toplevel ?type_map =
-  unparse ?type_map Michelson_v1_parser.parse_toplevel
-
-let unparse_expression = unparse Michelson_v1_parser.parse_expression
-
-let unparse_invalid expanded =
-  let source =
-    expanded |> root |> Michelson_v1_macros.unexpand_rec
-    |> Micheline.strip_locations
-    |> Micheline_printer.printable (fun n -> n)
-    |> Format.asprintf "%a" Micheline_printer.print_expr_unwrapped
-  in
-  fst (Michelson_v1_parser.parse_toplevel source)
-
-let ocaml_constructor_of_prim prim =
-  (* Assuming all the prim constructor prefixes match the
-     [[Michelson_v1_primitives.namespace]]. *)
-  let prefix =
-    Michelson_v1_primitives.(namespace prim |> string_of_namespace)
-  in
-  Format.asprintf "%s_%s" prefix @@ Michelson_v1_primitives.string_of_prim prim
-
-let micheline_string_of_expression ~zero_loc expression =
-  let string_of_list : string list -> string =
-   fun xs -> String.concat "; " xs |> Format.asprintf "[%s]"
-  in
-  let show_loc loc = if zero_loc then 0 else loc in
-  let rec string_of_node = function
-    | Int (loc, i) ->
-        let z =
-          match Z.to_int i with
-          | 0 ->
-              "Z.zero"
-          | 1 ->
-              "Z.one"
-          | i ->
-              Format.asprintf "Z.of_int %d" i
-        in
-        Format.asprintf "Int (%d, %s)" (show_loc loc) z
-    | String (loc, s) ->
-        Format.asprintf "String (%d, \"%s\")" (show_loc loc) s
-    | Bytes (loc, b) ->
-        Format.asprintf
-          "Bytes (%d, Bytes.of_string \"%s\")"
-          (show_loc loc)
-          Bytes.(escaped b |> to_string)
-    | Prim (loc, prim, nodes, annot) ->
-        Format.asprintf
-          "Prim (%d, %s, %s, %s)"
-          (show_loc loc)
-          (ocaml_constructor_of_prim prim)
-          (string_of_list @@ List.map string_of_node nodes)
-          (string_of_list @@ List.map (Format.asprintf "\"%s\"") annot)
-    | Seq (loc, nodes) ->
-        Format.asprintf
-          "Seq (%d, %s)"
-          (show_loc loc)
-          (string_of_list @@ List.map string_of_node nodes)
-  in
-  string_of_node (root expression)
diff --git a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_printer.mli b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_printer.mli
deleted file mode 100644
index 07cb29ae8..000000000
--- a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/michelson_v1_printer.mli
+++ /dev/null
@@ -1,65 +0,0 @@
-(*****************************************************************************)
-(*                                                                           *)
-(* Open Source License                                                       *)
-(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
-(*                                                                           *)
-(* Permission is hereby granted, free of charge, to any person obtaining a   *)
-(* copy of this software and associated documentation files (the "Software"),*)
-(* to deal in the Software without restriction, including without limitation *)
-(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
-(* and/or sell copies of the Software, and to permit persons to whom the     *)
-(* Software is furnished to do so, subject to the following conditions:      *)
-(*                                                                           *)
-(* The above copyright notice and this permission notice shall be included   *)
-(* in all copies or substantial portions of the Software.                    *)
-(*                                                                           *)
-(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
-(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
-(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
-(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
-(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
-(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
-(* DEALINGS IN THE SOFTWARE.                                                 *)
-(*                                                                           *)
-(*****************************************************************************)
-
-open Protocol
-open Alpha_context
-open Tezos_micheline
-
-val print_expr : Format.formatter -> Script_repr.expr -> unit
-
-val print_expr_unwrapped : Format.formatter -> Script_repr.expr -> unit
-
-val print_execution_trace :
-  Format.formatter ->
-  (Script.location * Gas.t * (Script.expr * string option) list) list ->
-  unit
-
-val print_big_map_diff : Format.formatter -> Lazy_storage.diffs -> unit
-
-(** Insert the type map returned by the typechecker as comments in a
-    printable Micheline AST. *)
-val inject_types :
-  Script_tc_errors.type_map ->
-  Michelson_v1_parser.parsed ->
-  Micheline_printer.node
-
-(** Unexpand the macros and produce the result of parsing an
-    intermediate pretty printed source. Useful when working with
-    contracts extracted from the blockchain and not local files. *)
-val unparse_toplevel :
-  ?type_map:Script_tc_errors.type_map ->
-  Script.expr ->
-  Michelson_v1_parser.parsed
-
-val unparse_expression : Script.expr -> Michelson_v1_parser.parsed
-
-(** Unexpand the macros and produce the result of parsing an
-    intermediate pretty printed source. Works on generic trees,for
-    programs that fail to be converted to a specific script version. *)
-val unparse_invalid : string Micheline.canonical -> Michelson_v1_parser.parsed
-
-val ocaml_constructor_of_prim : Michelson_v1_primitives.prim -> string
-
-val micheline_string_of_expression : zero_loc:bool -> Script.expr -> string
diff --git a/vendors/ligo-utils/proto-alpha-utils/dune b/vendors/ligo-utils/proto-alpha-utils/dune
index 1323bd20e..2cf189b77 100644
--- a/vendors/ligo-utils/proto-alpha-utils/dune
+++ b/vendors/ligo-utils/proto-alpha-utils/dune
@@ -1,17 +1,17 @@
 (library
-  (name proto_alpha_utils)
-  (public_name proto-alpha-utils)
-  (libraries
-    tezos-base
-    tezos-stdlib-unix
-    tezos-protocol-008-PtEdo2Zk
-    tezos-protocol-008-PtEdo2Zk-parameters
-    tezos-protocol-environment
-    ;tezos-client-008-PtEdo2Zk
-    tezos-memory-proto-alpha
-    data-encoding
-    simple-utils
-    tezos-utils
-  )
- (flags (:standard -open Simple_utils))
-)
+ (name proto_alpha_utils)
+ (public_name proto-alpha-utils)
+ (libraries
+  tezos-base
+  tezos-stdlib-unix
+  tezos-protocol-008-PtEdo2Zk
+  tezos-protocol-008-PtEdo2Zk-parameters
+  tezos-protocol-environment
+  ;tezos-client-008-PtEdo2Zk
+  tezos-memory-proto-alpha
+  client_utils-008-PtEdo2Zk
+  data-encoding
+  simple-utils
+  tezos-utils)
+ (flags
+  (:standard -open Simple_utils -open Client_utils_008_PtEdo2Zk)))
diff --git a/vendors/ligo-utils/proto-alpha-utils/michelson_v1_macros.ml b/vendors/ligo-utils/proto-alpha-utils/michelson_v1_macros.ml
deleted file mode 100644
index 06100482a..000000000
--- a/vendors/ligo-utils/proto-alpha-utils/michelson_v1_macros.ml
+++ /dev/null
@@ -1,1543 +0,0 @@
-(*****************************************************************************)
-(*                                                                           *)
-(* Open Source License                                                       *)
-(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
-(* Copyright (c) 2019 Nomadic Labs <contact@nomadic-labs.com>                *)
-(*                                                                           *)
-(* Permission is hereby granted, free of charge, to any person obtaining a   *)
-(* copy of this software and associated documentation files (the "Software"),*)
-(* to deal in the Software without restriction, including without limitation *)
-(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
-(* and/or sell copies of the Software, and to permit persons to whom the     *)
-(* Software is furnished to do so, subject to the following conditions:      *)
-(*                                                                           *)
-(* The above copyright notice and this permission notice shall be included   *)
-(* in all copies or substantial portions of the Software.                    *)
-(*                                                                           *)
-(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
-(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
-(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
-(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
-(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
-(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
-(* DEALINGS IN THE SOFTWARE.                                                 *)
-(*                                                                           *)
-(*****************************************************************************)
-
-open Tezos_micheline
-open Micheline
-open Tezos_base__TzPervasives
-module IntMap = Map.Make (Compare.Int)
-
-type 'l node = ('l, string) Micheline.node
-
-type error += Unexpected_macro_annotation of string
-
-type error += Sequence_expected of string
-
-type error += Invalid_arity of string * int * int
-
-let rec check_letters str i j f =
-  i > j || (f str.[i] && check_letters str (i + 1) j f)
-
-let expand_caddadr original =
-  match original with
-  | Prim (loc, str, args, annot) ->
-      let len = String.length str in
-      if
-        len > 3
-        && str.[0] = 'C'
-        && str.[len - 1] = 'R'
-        && check_letters str 1 (len - 2) (function
-               | 'A' | 'D' ->
-                   true
-               | _ ->
-                   false)
-      then
-        ( match args with
-        | [] ->
-            ok ()
-        | _ :: _ ->
-            error (Invalid_arity (str, List.length args, 0)) )
-        >>? fun () ->
-        let path_annot =
-          List.filter (function "@%" | "@%%" -> true | _ -> false) annot
-        in
-        let rec parse i acc =
-          if i = 0 then Seq (loc, acc)
-          else
-            let annot = if i = len - 2 then annot else path_annot in
-            match str.[i] with
-            | 'A' ->
-                parse (i - 1) (Prim (loc, "CAR", [], annot) :: acc)
-            | 'D' ->
-                parse (i - 1) (Prim (loc, "CDR", [], annot) :: acc)
-            | _ ->
-                assert false
-        in
-        ok (Some (parse (len - 2) []))
-      else ok None
-  | _ ->
-      ok None
-
-let expand_carn original =
-  match original with
-  | Prim (loc, "CAR", [Int (loc2, n)], annot) ->
-      ok
-        (Some
-           (Seq
-              ( loc,
-                [ Prim
-                    ( loc,
-                      "GET",
-                      [Int (loc2, Z.(of_int 1 + (n * of_int 2)))],
-                      annot ) ] )))
-  | _ ->
-      ok None
-
-let expand_cdrn original =
-  match original with
-  | Prim (loc, "CDR", [Int (loc2, n)], annot) ->
-      ok
-        (Some
-           (Seq
-              (loc, [Prim (loc, "GET", [Int (loc2, Z.(n * of_int 2))], annot)])))
-  | _ ->
-      ok None
-
-let extract_field_annots annot =
-  List.partition
-    (fun a ->
-      match a.[0] with
-      | '%' ->
-          true
-      | _ ->
-          false
-      | exception Invalid_argument _ ->
-          false)
-    annot
-
-let expand_set_caddadr original =
-  match original with
-  | Prim (loc, str, args, annot) ->
-      let len = String.length str in
-      if
-        len >= 7
-        && String.sub str 0 5 = "SET_C"
-        && str.[len - 1] = 'R'
-        && check_letters str 5 (len - 2) (function
-               | 'A' | 'D' ->
-                   true
-               | _ ->
-                   false)
-      then
-        ( match args with
-        | [] ->
-            ok ()
-        | _ :: _ ->
-            error (Invalid_arity (str, List.length args, 0)) )
-        >>? fun () ->
-        ( match extract_field_annots annot with
-        | ([], annot) ->
-            ok (None, annot)
-        | ([f], annot) ->
-            ok (Some f, annot)
-        | (_, _) ->
-            error (Unexpected_macro_annotation str) )
-        >>? fun (field_annot, annot) ->
-        let rec parse i acc =
-          if i = 4 then acc
-          else
-            let annot = if i = 5 then annot else [] in
-            match str.[i] with
-            | 'A' ->
-                let acc =
-                  Seq
-                    ( loc,
-                      [ Prim (loc, "DUP", [], []);
-                        Prim
-                          ( loc,
-                            "DIP",
-                            [Seq (loc, [Prim (loc, "CAR", [], ["@%%"]); acc])],
-                            [] );
-                        Prim (loc, "CDR", [], ["@%%"]);
-                        Prim (loc, "SWAP", [], []);
-                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
-                in
-                parse (i - 1) acc
-            | 'D' ->
-                let acc =
-                  Seq
-                    ( loc,
-                      [ Prim (loc, "DUP", [], []);
-                        Prim
-                          ( loc,
-                            "DIP",
-                            [Seq (loc, [Prim (loc, "CDR", [], ["@%%"]); acc])],
-                            [] );
-                        Prim (loc, "CAR", [], ["@%%"]);
-                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
-                in
-                parse (i - 1) acc
-            | _ ->
-                assert false
-        in
-        match str.[len - 2] with
-        | 'A' ->
-            let access_check =
-              match field_annot with
-              | None ->
-                  []
-              | Some f ->
-                  [ Prim (loc, "DUP", [], []);
-                    Prim (loc, "CAR", [], [f]);
-                    Prim (loc, "DROP", [], []) ]
-            in
-            let encoding =
-              [Prim (loc, "CDR", [], ["@%%"]); Prim (loc, "SWAP", [], [])]
-            in
-            let pair =
-              [ Prim
-                  ( loc,
-                    "PAIR",
-                    [],
-                    [Option.value field_annot ~default:"%"; "%@"] ) ]
-            in
-            let init = Seq (loc, access_check @ encoding @ pair) in
-            ok (Some (parse (len - 3) init))
-        | 'D' ->
-            let access_check =
-              match field_annot with
-              | None ->
-                  []
-              | Some f ->
-                  [ Prim (loc, "DUP", [], []);
-                    Prim (loc, "CDR", [], [f]);
-                    Prim (loc, "DROP", [], []) ]
-            in
-            let encoding = [Prim (loc, "CAR", [], ["@%%"])] in
-            let pair =
-              [ Prim
-                  ( loc,
-                    "PAIR",
-                    [],
-                    ["%@"; Option.value field_annot ~default:"%"] ) ]
-            in
-            let init = Seq (loc, access_check @ encoding @ pair) in
-            ok (Some (parse (len - 3) init))
-        | _ ->
-            assert false
-      else ok None
-  | _ ->
-      ok None
-
-let expand_map_caddadr original =
-  match original with
-  | Prim (loc, str, args, annot) ->
-      let len = String.length str in
-      if
-        len >= 7
-        && String.sub str 0 5 = "MAP_C"
-        && str.[len - 1] = 'R'
-        && check_letters str 5 (len - 2) (function
-               | 'A' | 'D' ->
-                   true
-               | _ ->
-                   false)
-      then
-        ( match args with
-        | [(Seq _ as code)] ->
-            ok code
-        | [_] ->
-            error (Sequence_expected str)
-        | [] | _ :: _ :: _ ->
-            error (Invalid_arity (str, List.length args, 1)) )
-        >>? fun code ->
-        ( match extract_field_annots annot with
-        | ([], annot) ->
-            ok (None, annot)
-        | ([f], annot) ->
-            ok (Some f, annot)
-        | (_, _) ->
-            error (Unexpected_macro_annotation str) )
-        >>? fun (field_annot, annot) ->
-        let rec parse i acc =
-          if i = 4 then acc
-          else
-            let annot = if i = 5 then annot else [] in
-            match str.[i] with
-            | 'A' ->
-                let acc =
-                  Seq
-                    ( loc,
-                      [ Prim (loc, "DUP", [], []);
-                        Prim
-                          ( loc,
-                            "DIP",
-                            [Seq (loc, [Prim (loc, "CAR", [], ["@%%"]); acc])],
-                            [] );
-                        Prim (loc, "CDR", [], ["@%%"]);
-                        Prim (loc, "SWAP", [], []);
-                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
-                in
-                parse (i - 1) acc
-            | 'D' ->
-                let acc =
-                  Seq
-                    ( loc,
-                      [ Prim (loc, "DUP", [], []);
-                        Prim
-                          ( loc,
-                            "DIP",
-                            [Seq (loc, [Prim (loc, "CDR", [], ["@%%"]); acc])],
-                            [] );
-                        Prim (loc, "CAR", [], ["@%%"]);
-                        Prim (loc, "PAIR", [], "%@" :: "%@" :: annot) ] )
-                in
-                parse (i - 1) acc
-            | _ ->
-                assert false
-        in
-        let cr_annot =
-          match field_annot with
-          | None ->
-              []
-          | Some f ->
-              ["@" ^ String.sub f 1 (String.length f - 1)]
-        in
-        match str.[len - 2] with
-        | 'A' ->
-            let init =
-              Seq
-                ( loc,
-                  [ Prim (loc, "DUP", [], []);
-                    Prim (loc, "CDR", [], ["@%%"]);
-                    Prim
-                      ( loc,
-                        "DIP",
-                        [Seq (loc, [Prim (loc, "CAR", [], cr_annot); code])],
-                        [] );
-                    Prim (loc, "SWAP", [], []);
-                    Prim
-                      ( loc,
-                        "PAIR",
-                        [],
-                        [Option.value field_annot ~default:"%"; "%@"] ) ] )
-            in
-            ok (Some (parse (len - 3) init))
-        | 'D' ->
-            let init =
-              Seq
-                ( loc,
-                  [ Prim (loc, "DUP", [], []);
-                    Prim (loc, "CDR", [], cr_annot);
-                    code;
-                    Prim (loc, "SWAP", [], []);
-                    Prim (loc, "CAR", [], ["@%%"]);
-                    Prim
-                      ( loc,
-                        "PAIR",
-                        [],
-                        ["%@"; Option.value field_annot ~default:"%"] ) ] )
-            in
-            ok (Some (parse (len - 3) init))
-        | _ ->
-            assert false
-      else ok None
-  | _ ->
-      ok None
-
-exception Not_a_roman
-
-let decimal_of_roman roman =
-  (* http://rosettacode.org/wiki/Roman_numerals/Decode#OCaml *)
-  let arabic = ref 0 in
-  let lastval = ref 0 in
-  for i = String.length roman - 1 downto 0 do
-    let n =
-      match roman.[i] with
-      | 'M' ->
-          1000
-      | 'D' ->
-          500
-      | 'C' ->
-          100
-      | 'L' ->
-          50
-      | 'X' ->
-          10
-      | 'V' ->
-          5
-      | 'I' ->
-          1
-      | _ ->
-          raise_notrace Not_a_roman
-    in
-    if Compare.Int.(n < !lastval) then arabic := !arabic - n
-    else arabic := !arabic + n ;
-    lastval := n
-  done ;
-  !arabic
-
-let dip ~loc ?(annot = []) depth instr =
-  assert (depth >= 0) ;
-  if depth = 1 then Prim (loc, "DIP", [instr], annot)
-  else Prim (loc, "DIP", [Int (loc, Z.of_int depth); instr], annot)
-
-let expand_deprecated_dxiiivp original =
-  (* transparently expands deprecated macro [DI...IP] to instruction [DIP n] *)
-  match original with
-  | Prim (loc, str, args, annot) ->
-      let len = String.length str in
-      if len > 3 && str.[0] = 'D' && str.[len - 1] = 'P' then
-        try
-          let depth = decimal_of_roman (String.sub str 1 (len - 2)) in
-          match args with
-          | [(Seq (_, _) as arg)] ->
-              ok @@ Some (dip ~loc ~annot depth arg)
-          | [_] ->
-              error (Sequence_expected str)
-          | [] | _ :: _ :: _ ->
-              error (Invalid_arity (str, List.length args, 1))
-        with Not_a_roman -> ok None
-      else ok None
-  | _ ->
-      ok None
-
-exception Not_a_pair
-
-type pair_item = A | I | P of int * pair_item * pair_item
-
-let parse_pair_substr str ~len start =
-  let rec parse ?left i =
-    if i = len - 1 then raise_notrace Not_a_pair
-    else if str.[i] = 'P' then
-      let (next_i, l) = parse ~left:true (i + 1) in
-      let (next_i, r) = parse ~left:false next_i in
-      (next_i, P (i, l, r))
-    else if str.[i] = 'A' && left = Some true then (i + 1, A)
-    else if str.[i] = 'I' && left <> Some true then (i + 1, I)
-    else raise_notrace Not_a_pair
-  in
-  let (last, ast) = parse start in
-  if last <> len - 1 then raise_notrace Not_a_pair else ast
-
-let unparse_pair_item ast =
-  let rec unparse ast acc =
-    match ast with
-    | P (_, l, r) ->
-        unparse r (unparse l ("P" :: acc))
-    | A ->
-        "A" :: acc
-    | I ->
-        "I" :: acc
-  in
-  List.rev ("R" :: unparse ast []) |> String.concat ""
-
-let pappaiir_annots_pos ast annot =
-  let rec find_annots_pos p_pos ast annots acc =
-    match (ast, annots) with
-    | (_, []) ->
-        (annots, acc)
-    | (P (i, left, right), _) ->
-        let (annots, acc) = find_annots_pos i left annots acc in
-        find_annots_pos i right annots acc
-    | (A, a :: annots) ->
-        let pos =
-          match IntMap.find p_pos acc with
-          | None ->
-              ([a], [])
-          | Some (_, cdr) ->
-              ([a], cdr)
-        in
-        (annots, IntMap.add p_pos pos acc)
-    | (I, a :: annots) ->
-        let pos =
-          match IntMap.find p_pos acc with
-          | None ->
-              ([], [a])
-          | Some (car, _) ->
-              (car, [a])
-        in
-        (annots, IntMap.add p_pos pos acc)
-  in
-  snd (find_annots_pos 0 ast annot IntMap.empty)
-
-let expand_pappaiir original =
-  match original with
-  | Prim (loc, str, args, annot) ->
-      let len = String.length str in
-      if
-        len > 4
-        && str.[0] = 'P'
-        && str.[len - 1] = 'R'
-        && check_letters str 1 (len - 2) (function
-               | 'P' | 'A' | 'I' ->
-                   true
-               | _ ->
-                   false)
-      then
-        try
-          let (field_annots, annot) = extract_field_annots annot in
-          let ast = parse_pair_substr str ~len 0 in
-          let field_annots_pos = pappaiir_annots_pos ast field_annots in
-          let rec parse p (depth, acc) =
-            match p with
-            | P (i, left, right) ->
-                let annot =
-                  match (i, IntMap.find i field_annots_pos) with
-                  | (0, None) ->
-                      annot
-                  | (_, None) ->
-                      []
-                  | (0, Some ([], cdr_annot)) ->
-                      ("%" :: cdr_annot) @ annot
-                  | (_, Some ([], cdr_annot)) ->
-                      "%" :: cdr_annot
-                  | (0, Some (car_annot, cdr_annot)) ->
-                      car_annot @ cdr_annot @ annot
-                  | (_, Some (car_annot, cdr_annot)) ->
-                      car_annot @ cdr_annot
-                in
-                let acc =
-                  if depth = 0 then Prim (loc, "PAIR", [], annot) :: acc
-                  else
-                    dip ~loc depth (Seq (loc, [Prim (loc, "PAIR", [], annot)]))
-                    :: acc
-                in
-                (depth, acc) |> parse left |> parse right
-            | A | I ->
-                (depth + 1, acc)
-          in
-          let (_, expanded) = parse ast (0, []) in
-          ( match args with
-          | [] ->
-              ok ()
-          | _ :: _ ->
-              error (Invalid_arity (str, List.length args, 0)) )
-          >>? fun () -> ok (Some (Seq (loc, expanded)))
-        with Not_a_pair -> ok None
-      else ok None
-  | _ ->
-      ok None
-
-let expand_unpappaiir original =
-  match original with
-  | Prim (loc, str, args, _annot) ->
-      let len = String.length str in
-      if
-        len > 6
-        && String.sub str 0 3 = "UNP"
-        && str.[len - 1] = 'R'
-        && check_letters str 3 (len - 2) (function
-               | 'P' | 'A' | 'I' ->
-                   true
-               | _ ->
-                   false)
-      then
-        try
-          let unpair = Prim (loc, "UNPAIR", [], []) in
-          let ast = parse_pair_substr str ~len 2 in
-          let rec parse p (depth, acc) =
-            match p with
-            | P (_i, left, right) ->
-                let acc =
-                  if depth = 0 then unpair :: acc
-                  else dip ~loc depth (Seq (loc, [unpair])) :: acc
-                in
-                (depth, acc) |> parse left |> parse right
-            | A | I ->
-                (depth + 1, acc)
-          in
-          let (_, rev_expanded) = parse ast (0, []) in
-          let expanded = Seq (loc, List.rev rev_expanded) in
-          ( match args with
-          | [] ->
-              ok ()
-          | _ :: _ ->
-              error (Invalid_arity (str, List.length args, 0)) )
-          >>? fun () -> ok (Some expanded)
-        with Not_a_pair -> ok None
-      else ok None
-  | _ ->
-      ok None
-
-exception Not_a_dup
-
-let expand_deprecated_duuuuup original =
-  (* transparently expands deprecated macro [DU...UP] to [{ DUP n }] *)
-  match original with
-  | Prim (loc, str, args, annot) ->
-      let len = String.length str in
-      if
-        len > 3
-        && str.[0] = 'D'
-        && str.[len - 1] = 'P'
-        && check_letters str 1 (len - 2) (( = ) 'U')
-      then
-        ( match args with
-        | [] ->
-            ok ()
-        | _ :: _ ->
-            error (Invalid_arity (str, List.length args, 0)) )
-        >>? fun () ->
-        try
-          let rec parse i =
-            if i = 1 then
-              Prim (loc, "DUP", [Int (loc, Z.of_int (len - 2))], annot)
-            else if str.[i] = 'U' then parse (i - 1)
-            else raise_notrace Not_a_dup
-          in
-          ok (Some (parse (len - 2)))
-        with Not_a_dup -> ok None
-      else ok None
-  | _ ->
-      ok None
-
-let expand_compare original =
-  let cmp loc is annot =
-    let is =
-      match List.rev_map (fun i -> Prim (loc, i, [], [])) is with
-      | Prim (loc, i, args, _) :: r ->
-          List.rev (Prim (loc, i, args, annot) :: r)
-      | is ->
-          List.rev is
-    in
-    ok (Some (Seq (loc, is)))
-  in
-  let ifcmp loc is l r annot =
-    let is =
-      List.map (fun i -> Prim (loc, i, [], [])) is
-      @ [Prim (loc, "IF", [l; r], annot)]
-    in
-    ok (Some (Seq (loc, is)))
-  in
-  match original with
-  | Prim (loc, "CMPEQ", [], annot) ->
-      cmp loc ["COMPARE"; "EQ"] annot
-  | Prim (loc, "CMPNEQ", [], annot) ->
-      cmp loc ["COMPARE"; "NEQ"] annot
-  | Prim (loc, "CMPLT", [], annot) ->
-      cmp loc ["COMPARE"; "LT"] annot
-  | Prim (loc, "CMPGT", [], annot) ->
-      cmp loc ["COMPARE"; "GT"] annot
-  | Prim (loc, "CMPLE", [], annot) ->
-      cmp loc ["COMPARE"; "LE"] annot
-  | Prim (loc, "CMPGE", [], annot) ->
-      cmp loc ["COMPARE"; "GE"] annot
-  | Prim
-      ( _,
-        (("CMPEQ" | "CMPNEQ" | "CMPLT" | "CMPGT" | "CMPLE" | "CMPGE") as str),
-        args,
-        [] ) ->
-      error (Invalid_arity (str, List.length args, 0))
-  | Prim (loc, "IFCMPEQ", [l; r], annot) ->
-      ifcmp loc ["COMPARE"; "EQ"] l r annot
-  | Prim (loc, "IFCMPNEQ", [l; r], annot) ->
-      ifcmp loc ["COMPARE"; "NEQ"] l r annot
-  | Prim (loc, "IFCMPLT", [l; r], annot) ->
-      ifcmp loc ["COMPARE"; "LT"] l r annot
-  | Prim (loc, "IFCMPGT", [l; r], annot) ->
-      ifcmp loc ["COMPARE"; "GT"] l r annot
-  | Prim (loc, "IFCMPLE", [l; r], annot) ->
-      ifcmp loc ["COMPARE"; "LE"] l r annot
-  | Prim (loc, "IFCMPGE", [l; r], annot) ->
-      ifcmp loc ["COMPARE"; "GE"] l r annot
-  | Prim (loc, "IFEQ", [l; r], annot) ->
-      ifcmp loc ["EQ"] l r annot
-  | Prim (loc, "IFNEQ", [l; r], annot) ->
-      ifcmp loc ["NEQ"] l r annot
-  | Prim (loc, "IFLT", [l; r], annot) ->
-      ifcmp loc ["LT"] l r annot
-  | Prim (loc, "IFGT", [l; r], annot) ->
-      ifcmp loc ["GT"] l r annot
-  | Prim (loc, "IFLE", [l; r], annot) ->
-      ifcmp loc ["LE"] l r annot
-  | Prim (loc, "IFGE", [l; r], annot) ->
-      ifcmp loc ["GE"] l r annot
-  | Prim
-      ( _,
-        ( ( "IFCMPEQ"
-          | "IFCMPNEQ"
-          | "IFCMPLT"
-          | "IFCMPGT"
-          | "IFCMPLE"
-          | "IFCMPGE"
-          | "IFEQ"
-          | "IFNEQ"
-          | "IFLT"
-          | "IFGT"
-          | "IFLE"
-          | "IFGE" ) as str ),
-        args,
-        [] ) ->
-      error (Invalid_arity (str, List.length args, 2))
-  | Prim
-      ( _,
-        ( ( "IFCMPEQ"
-          | "IFCMPNEQ"
-          | "IFCMPLT"
-          | "IFCMPGT"
-          | "IFCMPLE"
-          | "IFCMPGE"
-          | "IFEQ"
-          | "IFNEQ"
-          | "IFLT"
-          | "IFGT"
-          | "IFLE"
-          | "IFGE" ) as str ),
-        [],
-        _ :: _ ) ->
-      error (Unexpected_macro_annotation str)
-  | _ ->
-      ok None
-
-let expand_asserts original =
-  let may_rename loc = function
-    | [] ->
-        Seq (loc, [])
-    | annot ->
-        Seq (loc, [Prim (loc, "RENAME", [], annot)])
-  in
-  let fail_false ?(annot = []) loc =
-    [may_rename loc annot; Seq (loc, [Prim (loc, "FAIL", [], [])])]
-  in
-  let fail_true ?(annot = []) loc =
-    [Seq (loc, [Prim (loc, "FAIL", [], [])]); may_rename loc annot]
-  in
-  match original with
-  | Prim (loc, "ASSERT", [], []) ->
-      ok @@ Some (Seq (loc, [Prim (loc, "IF", fail_false loc, [])]))
-  | Prim (loc, "ASSERT_NONE", [], []) ->
-      ok @@ Some (Seq (loc, [Prim (loc, "IF_NONE", fail_false loc, [])]))
-  | Prim (loc, "ASSERT_SOME", [], annot) ->
-      ok @@ Some (Seq (loc, [Prim (loc, "IF_NONE", fail_true ~annot loc, [])]))
-  | Prim (loc, "ASSERT_LEFT", [], annot) ->
-      ok
-      @@ Some (Seq (loc, [Prim (loc, "IF_LEFT", fail_false ~annot loc, [])]))
-  | Prim (loc, "ASSERT_RIGHT", [], annot) ->
-      ok @@ Some (Seq (loc, [Prim (loc, "IF_LEFT", fail_true ~annot loc, [])]))
-  | Prim
-      ( _,
-        ( ( "ASSERT"
-          | "ASSERT_NONE"
-          | "ASSERT_SOME"
-          | "ASSERT_LEFT"
-          | "ASSERT_RIGHT" ) as str ),
-        args,
-        [] ) ->
-      error (Invalid_arity (str, List.length args, 0))
-  | Prim (_, (("ASSERT" | "ASSERT_NONE") as str), [], _ :: _) ->
-      error (Unexpected_macro_annotation str)
-  | Prim (loc, s, args, annot)
-    when String.(length s > 7 && equal (sub s 0 7) "ASSERT_") -> (
-      ( match args with
-      | [] ->
-          ok ()
-      | _ :: _ ->
-          error (Invalid_arity (s, List.length args, 0)) )
-      >>? fun () ->
-      ( match annot with
-      | _ :: _ ->
-          error (Unexpected_macro_annotation s)
-      | [] ->
-          ok () )
-      >>? fun () ->
-      let remaining = String.(sub s 7 (length s - 7)) in
-      let remaining_prim = Prim (loc, remaining, [], []) in
-      match remaining with
-      | "EQ" | "NEQ" | "LT" | "LE" | "GE" | "GT" ->
-          ok
-          @@ Some
-               (Seq
-                  (loc, [remaining_prim; Prim (loc, "IF", fail_false loc, [])]))
-      | _ -> (
-          expand_compare remaining_prim
-          >|? function
-          | None ->
-              None
-          | Some seq ->
-              Some (Seq (loc, [seq; Prim (loc, "IF", fail_false loc, [])])) ) )
-  | _ ->
-      ok None
-
-let expand_if_some = function
-  | Prim (loc, "IF_SOME", [right; left], annot) ->
-      ok @@ Some (Seq (loc, [Prim (loc, "IF_NONE", [left; right], annot)]))
-  | Prim (_, "IF_SOME", args, _annot) ->
-      error (Invalid_arity ("IF_SOME", List.length args, 2))
-  | _ ->
-      ok @@ None
-
-let expand_if_right = function
-  | Prim (loc, "IF_RIGHT", [right; left], annot) ->
-      ok @@ Some (Seq (loc, [Prim (loc, "IF_LEFT", [left; right], annot)]))
-  | Prim (_, "IF_RIGHT", args, _annot) ->
-      error (Invalid_arity ("IF_RIGHT", List.length args, 2))
-  | _ ->
-      ok @@ None
-
-let expand_fail = function
-  | Prim (loc, "FAIL", [], []) ->
-      ok
-      @@ Some
-           (Seq
-              ( loc,
-                [Prim (loc, "UNIT", [], []); Prim (loc, "FAILWITH", [], [])] ))
-  | _ ->
-      ok @@ None
-
-let expand original =
-  let rec try_expansions = function
-    | [] ->
-        ok @@ original
-    | expander :: expanders -> (
-        expander original
-        >>? function
-        | None -> try_expansions expanders | Some rewritten -> ok rewritten )
-  in
-  try_expansions
-    [ expand_carn;
-      expand_cdrn;
-      expand_caddadr;
-      expand_set_caddadr;
-      expand_map_caddadr;
-      expand_deprecated_dxiiivp;
-      (* expand_paaiair ; *)
-      expand_pappaiir;
-      (* expand_unpaaiair ; *)
-      expand_unpappaiir;
-      expand_deprecated_duuuuup;
-      expand_compare;
-      expand_asserts;
-      expand_if_some;
-      expand_if_right;
-      expand_fail ]
-
-let expand_rec expr =
-  let rec error_map (expanded, errors) f = function
-    | [] ->
-        (List.rev expanded, List.rev errors)
-    | hd :: tl ->
-        let (new_expanded, new_errors) = f hd in
-        error_map
-          (new_expanded :: expanded, List.rev_append new_errors errors)
-          f
-          tl
-  in
-  let error_map = error_map ([], []) in
-  let rec expand_rec expr =
-    match expand expr with
-    | Ok expanded -> (
-      match expanded with
-      | Seq (loc, items) ->
-          let (items, errors) = error_map expand_rec items in
-          (Seq (loc, items), errors)
-      | Prim (loc, name, args, annot) ->
-          let (args, errors) = error_map expand_rec args in
-          (Prim (loc, name, args, annot), errors)
-      | (Int _ | String _ | Bytes _) as atom ->
-          (atom, []) )
-    | Error errors ->
-        (expr, errors)
-  in
-  expand_rec expr
-
-let unexpand_carn_and_cdrn expanded =
-  match expanded with
-  | Seq (loc, [Prim (_, "GET", [Int (locn, n)], annot)]) ->
-      let (half, parity) = Z.ediv_rem n (Z.of_int 2) in
-      if Z.(parity = zero) then
-        Some (Prim (loc, "CDR", [Int (locn, half)], annot))
-      else Some (Prim (loc, "CAR", [Int (locn, half)], annot))
-  | _ ->
-      None
-
-let unexpand_caddadr expanded =
-  let rec rsteps acc = function
-    | [] ->
-        Some acc
-    | Prim (_, "CAR", [], []) :: rest ->
-        rsteps ("A" :: acc) rest
-    | Prim (_, "CDR", [], []) :: rest ->
-        rsteps ("D" :: acc) rest
-    | _ ->
-        None
-  in
-  match expanded with
-  | Seq (loc, (Prim (_, "CAR", [], []) :: _ as nodes))
-  | Seq (loc, (Prim (_, "CDR", [], []) :: _ as nodes)) -> (
-    match rsteps [] nodes with
-    | Some steps ->
-        let name = String.concat "" ("C" :: List.rev ("R" :: steps)) in
-        Some (Prim (loc, name, [], []))
-    | None ->
-        None )
-  | _ ->
-      None
-
-let unexpand_set_caddadr expanded =
-  let rec steps acc annots = function
-    | Seq
-        ( loc,
-          [ Prim (_, "CDR", [], _);
-            Prim (_, "SWAP", [], _);
-            Prim (_, "PAIR", [], _) ] ) ->
-        Some (loc, "A" :: acc, annots)
-    | Seq
-        ( loc,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "CAR", [], [field_annot]);
-            Prim (_, "DROP", [], []);
-            Prim (_, "CDR", [], _);
-            Prim (_, "SWAP", [], []);
-            Prim (_, "PAIR", [], _) ] ) ->
-        Some (loc, "A" :: acc, field_annot :: annots)
-    | Seq (loc, [Prim (_, "CAR", [], _); Prim (_, "PAIR", [], _)]) ->
-        Some (loc, "D" :: acc, annots)
-    | Seq
-        ( loc,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "CDR", [], [field_annot]);
-            Prim (_, "DROP", [], []);
-            Prim (_, "CAR", [], _);
-            Prim (_, "PAIR", [], _) ] ) ->
-        Some (loc, "D" :: acc, field_annot :: annots)
-    | Seq
-        ( _,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "DIP", [Seq (_, [Prim (_, "CAR", [], _); sub])], []);
-            Prim (_, "CDR", [], _);
-            Prim (_, "SWAP", [], []);
-            Prim (_, "PAIR", [], pair_annots) ] ) ->
-        let (_, pair_annots) = extract_field_annots pair_annots in
-        steps ("A" :: acc) (List.rev_append pair_annots annots) sub
-    | Seq
-        ( _,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], _); sub])], []);
-            Prim (_, "CAR", [], _);
-            Prim (_, "PAIR", [], pair_annots) ] ) ->
-        let (_, pair_annots) = extract_field_annots pair_annots in
-        steps ("D" :: acc) (List.rev_append pair_annots annots) sub
-    | _ ->
-        None
-  in
-  match steps [] [] expanded with
-  | Some (loc, steps, annots) ->
-      let name = String.concat "" ("SET_C" :: List.rev ("R" :: steps)) in
-      Some (Prim (loc, name, [], List.rev annots))
-  | None ->
-      None
-
-let unexpand_map_caddadr expanded =
-  let rec steps acc annots = function
-    | Seq
-        ( loc,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "CDR", [], _);
-            Prim (_, "SWAP", [], []);
-            Prim (_, "DIP", [Seq (_, [Prim (_, "CAR", [], []); code])], []);
-            Prim (_, "PAIR", [], _) ] ) ->
-        Some (loc, "A" :: acc, annots, code)
-    | Seq
-        ( loc,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "CDR", [], _);
-            Prim (_, "SWAP", [], []);
-            Prim
-              ( _,
-                "DIP",
-                [Seq (_, [Prim (_, "CAR", [], [field_annot]); code])],
-                [] );
-            Prim (_, "PAIR", [], _) ] ) ->
-        Some (loc, "A" :: acc, field_annot :: annots, code)
-    | Seq
-        ( loc,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "CDR", [], []);
-            code;
-            Prim (_, "SWAP", [], []);
-            Prim (_, "CAR", [], _);
-            Prim (_, "PAIR", [], _) ] ) ->
-        Some (loc, "D" :: acc, annots, code)
-    | Seq
-        ( loc,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "CDR", [], [field_annot]);
-            code;
-            Prim (_, "SWAP", [], []);
-            Prim (_, "CAR", [], _);
-            Prim (_, "PAIR", [], _) ] ) ->
-        Some (loc, "D" :: acc, field_annot :: annots, code)
-    | Seq
-        ( _,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "DIP", [Seq (_, [Prim (_, "CAR", [], _); sub])], []);
-            Prim (_, "CDR", [], _);
-            Prim (_, "SWAP", [], []);
-            Prim (_, "PAIR", [], pair_annots) ] ) ->
-        let (_, pair_annots) = extract_field_annots pair_annots in
-        steps ("A" :: acc) (List.rev_append pair_annots annots) sub
-    | Seq
-        ( _,
-          [ Prim (_, "DUP", [], []);
-            Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], []); sub])], []);
-            Prim (_, "CAR", [], []);
-            Prim (_, "PAIR", [], pair_annots) ] ) ->
-        let (_, pair_annots) = extract_field_annots pair_annots in
-        steps ("D" :: acc) (List.rev_append pair_annots annots) sub
-    | _ ->
-        None
-  in
-  match steps [] [] expanded with
-  | Some (loc, steps, annots, code) ->
-      let name = String.concat "" ("MAP_C" :: List.rev ("R" :: steps)) in
-      Some (Prim (loc, name, [code], List.rev annots))
-  | None ->
-      None
-
-let unexpand_deprecated_dxiiivp expanded =
-  (* transparently turn the old expansion of deprecated [DI...IP] to [DIP n] *)
-  match expanded with
-  | Seq
-      ( loc,
-        [Prim (_, "DIP", [(Seq (_, [Prim (_, "DIP", [_], [])]) as sub)], [])]
-      ) ->
-      let rec count acc = function
-        | Seq (_, [Prim (_, "DIP", [sub], [])]) ->
-            count (acc + 1) sub
-        | sub ->
-            (acc, sub)
-      in
-      let (depth, sub) = count 1 sub in
-      Some (Prim (loc, "DIP", [Int (loc, Z.of_int depth); sub], []))
-  | _ ->
-      None
-
-let unexpand_dupn expanded =
-  match expanded with
-  | Seq
-      ( loc,
-        [ Prim
-            (_, "DIP", [Int (_, np); Seq (_, [Prim (_, "DUP", [], annot)])], []);
-          Prim (_, "DIG", [Int (nloc, ng)], []) ] )
-    when Z.equal np (Z.pred ng) ->
-      Some (Prim (loc, "DUP", [Int (nloc, ng)], annot))
-  | _ ->
-      None
-
-let unexpand_deprecated_duuuuup expanded =
-  (* transparently turn the old expansion of deprecated [DU...UP] to [DUP n] *)
-  let rec expand n = function
-    | Seq (loc, [Prim (nloc, "DUP", [], annot)]) ->
-        if n = 1 then None
-        else Some (Prim (loc, "DUP", [Int (nloc, Z.of_int n)], annot))
-    | Seq (_, [Prim (_, "DIP", [expanded'], []); Prim (_, "SWAP", [], [])]) ->
-        expand (n + 1) expanded'
-    | _ ->
-        None
-  in
-  expand 1 expanded
-
-let rec normalize_pair_item ?(right = false) = function
-  | P (i, a, b) ->
-      P (i, normalize_pair_item a, normalize_pair_item ~right:true b)
-  | A when right ->
-      I
-  | A ->
-      A
-  | I ->
-      I
-
-let unexpand_pappaiir expanded =
-  match expanded with
-  | Seq (_, [Prim (_, "PAIR", [], [])]) ->
-      Some expanded
-  | Seq (loc, (_ :: _ as nodes)) -> (
-      let rec exec stack nodes =
-        match (nodes, stack) with
-        | ([], _) ->
-            stack
-        (* support new expansion using [DIP n] *)
-        | ( Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest,
-            a :: rstack )
-          when Z.to_int n > 1 ->
-            exec
-              ( a
-              :: exec
-                   rstack
-                   [ Prim
-                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
-                   ] )
-              rest
-        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, a :: rstack)
-          when Z.to_int n = 1 ->
-            exec (a :: exec rstack sub) rest
-        | (Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest, [])
-          when Z.to_int n > 1 ->
-            exec
-              ( A
-              :: exec
-                   []
-                   [ Prim
-                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
-                   ] )
-              rest
-        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, [])
-          when Z.to_int n = 1 ->
-            exec (A :: exec [] sub) rest
-        (* support old expansion using [DIP] *)
-        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, a :: rstack) ->
-            exec (a :: exec rstack sub) rest
-        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, []) ->
-            exec (A :: exec [] sub) rest
-        | (Prim (_, "PAIR", [], []) :: rest, a :: b :: rstack) ->
-            exec (P (0, a, b) :: rstack) rest
-        | (Prim (_, "PAIR", [], []) :: rest, [a]) ->
-            exec [P (0, a, I)] rest
-        | (Prim (_, "PAIR", [], []) :: rest, []) ->
-            exec [P (0, A, I)] rest
-        | _ ->
-            raise_notrace Not_a_pair
-      in
-      match exec [] nodes with
-      | [] ->
-          None
-      | res :: _ ->
-          let res = normalize_pair_item res in
-          let name = unparse_pair_item res in
-          Some (Prim (loc, name, [], []))
-      | exception Not_a_pair ->
-          None )
-  | _ ->
-      None
-
-let unexpand_unpappaiir expanded =
-  match expanded with
-  | Seq (loc, (_ :: _ as nodes)) -> (
-      let rec exec stack nodes =
-        match (nodes, stack) with
-        | ([], _) ->
-            stack
-        (* support new expansion using [DIP n] *)
-        | ( Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest,
-            a :: rstack )
-          when Z.to_int n > 1 ->
-            exec
-              ( a
-              :: exec
-                   rstack
-                   [ Prim
-                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
-                   ] )
-              rest
-        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, a :: rstack)
-          when Z.to_int n = 1 ->
-            exec (a :: exec rstack sub) rest
-        | (Prim (ploc, "DIP", [Int (loc, n); Seq (sloc, sub)], []) :: rest, [])
-          when Z.to_int n > 1 ->
-            exec
-              ( A
-              :: exec
-                   []
-                   [ Prim
-                       (ploc, "DIP", [Int (loc, Z.pred n); Seq (sloc, sub)], [])
-                   ] )
-              rest
-        | (Prim (_, "DIP", [Int (_, n); Seq (_, sub)], []) :: rest, [])
-          when Z.to_int n = 1 ->
-            exec (A :: exec [] sub) rest
-        (* support old expansion using [DIP] *)
-        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, a :: rstack) ->
-            exec (a :: exec rstack sub) rest
-        | (Prim (_, "DIP", [Seq (_, sub)], []) :: rest, []) ->
-            exec (A :: exec [] sub) rest
-        | ( Seq
-              ( _,
-                [ Prim (_, "DUP", [], []);
-                  Prim (_, "CAR", [], []);
-                  Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], [])])], []) ]
-              )
-            :: rest,
-            a :: b :: rstack ) ->
-            exec (P (0, a, b) :: rstack) rest
-        | ( Seq
-              ( _,
-                [ Prim (_, "DUP", [], []);
-                  Prim (_, "CAR", [], []);
-                  Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], [])])], []) ]
-              )
-            :: rest,
-            [a] ) ->
-            exec [P (0, a, I)] rest
-        | ( Seq
-              ( _,
-                [ Prim (_, "DUP", [], []);
-                  Prim (_, "CAR", [], []);
-                  Prim (_, "DIP", [Seq (_, [Prim (_, "CDR", [], [])])], []) ]
-              )
-            :: rest,
-            [] ) ->
-            exec [P (0, A, I)] rest
-        | _ ->
-            raise_notrace Not_a_pair
-      in
-      match exec [] (List.rev nodes) with
-      | [] ->
-          None
-      | res :: _ ->
-          let res = normalize_pair_item res in
-          let name = "UN" ^ unparse_pair_item res in
-          Some (Prim (loc, name, [], []))
-      | exception Not_a_pair ->
-          None )
-  | _ ->
-      None
-
-let unexpand_compare expanded =
-  match expanded with
-  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "EQ", [], annot)]) ->
-      Some (Prim (loc, "CMPEQ", [], annot))
-  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "NEQ", [], annot)]) ->
-      Some (Prim (loc, "CMPNEQ", [], annot))
-  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "LT", [], annot)]) ->
-      Some (Prim (loc, "CMPLT", [], annot))
-  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "GT", [], annot)]) ->
-      Some (Prim (loc, "CMPGT", [], annot))
-  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "LE", [], annot)]) ->
-      Some (Prim (loc, "CMPLE", [], annot))
-  | Seq (loc, [Prim (_, "COMPARE", [], _); Prim (_, "GE", [], annot)]) ->
-      Some (Prim (loc, "CMPGE", [], annot))
-  | Seq
-      ( loc,
-        [ Prim (_, "COMPARE", [], _);
-          Prim (_, "EQ", [], _);
-          Prim (_, "IF", args, annot) ] ) ->
-      Some (Prim (loc, "IFCMPEQ", args, annot))
-  | Seq
-      ( loc,
-        [ Prim (_, "COMPARE", [], _);
-          Prim (_, "NEQ", [], _);
-          Prim (_, "IF", args, annot) ] ) ->
-      Some (Prim (loc, "IFCMPNEQ", args, annot))
-  | Seq
-      ( loc,
-        [ Prim (_, "COMPARE", [], _);
-          Prim (_, "LT", [], _);
-          Prim (_, "IF", args, annot) ] ) ->
-      Some (Prim (loc, "IFCMPLT", args, annot))
-  | Seq
-      ( loc,
-        [ Prim (_, "COMPARE", [], _);
-          Prim (_, "GT", [], _);
-          Prim (_, "IF", args, annot) ] ) ->
-      Some (Prim (loc, "IFCMPGT", args, annot))
-  | Seq
-      ( loc,
-        [ Prim (_, "COMPARE", [], _);
-          Prim (_, "LE", [], _);
-          Prim (_, "IF", args, annot) ] ) ->
-      Some (Prim (loc, "IFCMPLE", args, annot))
-  | Seq
-      ( loc,
-        [ Prim (_, "COMPARE", [], _);
-          Prim (_, "GE", [], _);
-          Prim (_, "IF", args, annot) ] ) ->
-      Some (Prim (loc, "IFCMPGE", args, annot))
-  | Seq (loc, [Prim (_, "EQ", [], _); Prim (_, "IF", args, annot)]) ->
-      Some (Prim (loc, "IFEQ", args, annot))
-  | Seq (loc, [Prim (_, "NEQ", [], _); Prim (_, "IF", args, annot)]) ->
-      Some (Prim (loc, "IFNEQ", args, annot))
-  | Seq (loc, [Prim (_, "LT", [], _); Prim (_, "IF", args, annot)]) ->
-      Some (Prim (loc, "IFLT", args, annot))
-  | Seq (loc, [Prim (_, "GT", [], _); Prim (_, "IF", args, annot)]) ->
-      Some (Prim (loc, "IFGT", args, annot))
-  | Seq (loc, [Prim (_, "LE", [], _); Prim (_, "IF", args, annot)]) ->
-      Some (Prim (loc, "IFLE", args, annot))
-  | Seq (loc, [Prim (_, "GE", [], _); Prim (_, "IF", args, annot)]) ->
-      Some (Prim (loc, "IFGE", args, annot))
-  | _ ->
-      None
-
-let unexpand_asserts expanded =
-  match expanded with
-  | Seq
-      ( loc,
-        [ Prim
-            ( _,
-              "IF",
-              [ Seq (_, []);
-                Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT", [], []))
-  | Seq
-      ( loc,
-        [ Seq (_, [Prim (_, "COMPARE", [], []); Prim (_, comparison, [], [])]);
-          Prim
-            ( _,
-              "IF",
-              [ Seq (_, []);
-                Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_CMP" ^ comparison, [], []))
-  | Seq
-      ( loc,
-        [ Prim (_, comparison, [], []);
-          Prim
-            ( _,
-              "IF",
-              [ Seq (_, []);
-                Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_" ^ comparison, [], []))
-  | Seq
-      ( loc,
-        [ Prim
-            ( _,
-              "IF_NONE",
-              [ Seq (_, [Prim (_, "RENAME", [], annot)]);
-                Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_NONE", [], annot))
-  | Seq
-      ( loc,
-        [ Prim
-            ( _,
-              "IF_NONE",
-              [ Seq (_, []);
-                Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_NONE", [], []))
-  | Seq
-      ( loc,
-        [ Prim
-            ( _,
-              "IF_NONE",
-              [ Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] );
-                Seq (_, []) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_SOME", [], []))
-  | Seq
-      ( loc,
-        [ Prim
-            ( _,
-              "IF_NONE",
-              [ Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] );
-                Seq (_, [Prim (_, "RENAME", [], annot)]) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_SOME", [], annot))
-  | Seq
-      ( loc,
-        [ Prim
-            ( _,
-              "IF_LEFT",
-              [ Seq (_, []);
-                Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_LEFT", [], []))
-  | Seq
-      ( loc,
-        [ Prim
-            ( _,
-              "IF_LEFT",
-              [ Seq (_, [Prim (_, "RENAME", [], annot)]);
-                Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] ) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_LEFT", [], annot))
-  | Seq
-      ( loc,
-        [ Prim
-            ( _,
-              "IF_LEFT",
-              [ Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] );
-                Seq (_, []) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_RIGHT", [], []))
-  | Seq
-      ( loc,
-        [ Prim
-            ( _,
-              "IF_LEFT",
-              [ Seq
-                  ( _,
-                    [ Seq
-                        ( _,
-                          [ Prim (_, "UNIT", [], []);
-                            Prim (_, "FAILWITH", [], []) ] ) ] );
-                Seq (_, [Prim (_, "RENAME", [], annot)]) ],
-              [] ) ] ) ->
-      Some (Prim (loc, "ASSERT_RIGHT", [], annot))
-  | _ ->
-      None
-
-let unexpand_if_some = function
-  | Seq (loc, [Prim (_, "IF_NONE", [left; right], annot)]) ->
-      Some (Prim (loc, "IF_SOME", [right; left], annot))
-  | _ ->
-      None
-
-let unexpand_if_right = function
-  | Seq (loc, [Prim (_, "IF_LEFT", [left; right], annot)]) ->
-      Some (Prim (loc, "IF_RIGHT", [right; left], annot))
-  | _ ->
-      None
-
-let unexpand_fail = function
-  | Seq (loc, [Prim (_, "UNIT", [], []); Prim (_, "FAILWITH", [], [])]) ->
-      Some (Prim (loc, "FAIL", [], []))
-  | _ ->
-      None
-
-let unexpand original =
-  let try_unexpansions unexpanders =
-    match
-      List.fold_left
-        (fun acc f ->
-          match acc with
-          | None ->
-              f original
-          | Some rewritten ->
-              Some rewritten)
-        None
-        unexpanders
-    with
-    | None ->
-        original
-    | Some rewritten ->
-        rewritten
-  in
-  try_unexpansions
-    [ unexpand_asserts;
-      unexpand_carn_and_cdrn;
-      unexpand_caddadr;
-      unexpand_set_caddadr;
-      unexpand_map_caddadr;
-      unexpand_deprecated_dxiiivp;
-      unexpand_pappaiir;
-      unexpand_unpappaiir;
-      unexpand_deprecated_duuuuup;
-      unexpand_dupn;
-      unexpand_compare;
-      unexpand_if_some;
-      unexpand_if_right;
-      unexpand_fail ]
-
-(*
-   If an argument of Prim is a sequence, we do not want to unexpand
-   its root in case the source already contains an expanded macro. In
-   which case unexpansion would remove surrounding braces and generate
-   ill-formed code.
-
-   For example, DIIP { DIP { DUP }; SWAP } is not unexpandable but
-   DIIP {{ DIP { DUP }; SWAP }} (note the double braces) is unexpanded
-   to DIIP { DUUP }.
-
-   unexpand_rec_but_root is the same as unexpand_rec but does not try
-   to unexpand at root *)
-
-let rec unexpand_rec expr = unexpand_rec_but_root (unexpand expr)
-
-and unexpand_rec_but_root = function
-  | Seq (loc, items) ->
-      Seq (loc, List.map unexpand_rec items)
-  | Prim (loc, name, args, annot) ->
-      Prim (loc, name, List.map unexpand_rec_but_root args, annot)
-  | (Int _ | String _ | Bytes _) as atom ->
-      atom
-
-let () =
-  let open Data_encoding in
-  register_error_kind
-    `Permanent
-    ~id:"michelson.macros.unexpected_annotation"
-    ~title:"Unexpected annotation"
-    ~description:
-      "A macro had an annotation, but no annotation was permitted on this \
-       macro."
-    ~pp:(fun ppf -> Format.fprintf ppf "Unexpected annotation on macro %s.")
-    (obj1 (req "macro_name" string))
-    (function Unexpected_macro_annotation str -> Some str | _ -> None)
-    (fun s -> Unexpected_macro_annotation s) ;
-  register_error_kind
-    `Permanent
-    ~id:"michelson.macros.sequence_expected"
-    ~title:"Macro expects a sequence"
-    ~description:"An macro expects a sequence, but a sequence was not provided"
-    ~pp:(fun ppf name ->
-      Format.fprintf
-        ppf
-        "Macro %s expects a sequence, but did not receive one."
-        name)
-    (obj1 (req "macro_name" string))
-    (function Sequence_expected name -> Some name | _ -> None)
-    (fun name -> Sequence_expected name) ;
-  register_error_kind
-    `Permanent
-    ~id:"michelson.macros.bas_arity"
-    ~title:"Wrong number of arguments to macro"
-    ~description:"A wrong number of arguments was provided to a macro"
-    ~pp:(fun ppf (name, got, exp) ->
-      Format.fprintf
-        ppf
-        "Macro %s expects %d arguments, was given %d."
-        name
-        exp
-        got)
-    (obj3
-       (req "macro_name" string)
-       (req "given_number_of_arguments" uint16)
-       (req "expected_number_of_arguments" uint16))
-    (function
-      | Invalid_arity (name, got, exp) -> Some (name, got, exp) | _ -> None)
-    (fun (name, got, exp) -> Invalid_arity (name, got, exp))
diff --git a/vendors/ligo-utils/proto-alpha-utils/michelson_v1_macros.mli b/vendors/ligo-utils/proto-alpha-utils/michelson_v1_macros.mli
deleted file mode 100644
index 26f52ddaf..000000000
--- a/vendors/ligo-utils/proto-alpha-utils/michelson_v1_macros.mli
+++ /dev/null
@@ -1,87 +0,0 @@
-(*****************************************************************************)
-(*                                                                           *)
-(* Open Source License                                                       *)
-(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
-(*                                                                           *)
-(* Permission is hereby granted, free of charge, to any person obtaining a   *)
-(* copy of this software and associated documentation files (the "Software"),*)
-(* to deal in the Software without restriction, including without limitation *)
-(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
-(* and/or sell copies of the Software, and to permit persons to whom the     *)
-(* Software is furnished to do so, subject to the following conditions:      *)
-(*                                                                           *)
-(* The above copyright notice and this permission notice shall be included   *)
-(* in all copies or substantial portions of the Software.                    *)
-(*                                                                           *)
-(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
-(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
-(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
-(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
-(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
-(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
-(* DEALINGS IN THE SOFTWARE.                                                 *)
-(*                                                                           *)
-(*****************************************************************************)
-
-open Tezos_micheline
-open Tezos_base__TzPervasives
-
-type 'l node = ('l, string) Micheline.node
-
-type error += Unexpected_macro_annotation of string
-
-type error += Sequence_expected of string
-
-type error += Invalid_arity of string * int * int
-
-val expand : 'l node -> 'l node tzresult
-
-val expand_rec : 'l node -> 'l node * error list
-
-val expand_caddadr : 'l node -> 'l node option tzresult
-
-val expand_set_caddadr : 'l node -> 'l node option tzresult
-
-val expand_map_caddadr : 'l node -> 'l node option tzresult
-
-val expand_deprecated_dxiiivp : 'l node -> 'l node option tzresult
-
-val expand_pappaiir : 'l node -> 'l node option tzresult
-
-val expand_deprecated_duuuuup : 'l node -> 'l node option tzresult
-
-val expand_compare : 'l node -> 'l node option tzresult
-
-val expand_asserts : 'l node -> 'l node option tzresult
-
-val expand_unpappaiir : 'l node -> 'l node option tzresult
-
-val expand_if_some : 'l node -> 'l node option tzresult
-
-val expand_if_right : 'l node -> 'l node option tzresult
-
-val unexpand : 'l node -> 'l node
-
-val unexpand_rec : 'l node -> 'l node
-
-val unexpand_caddadr : 'l node -> 'l node option
-
-val unexpand_set_caddadr : 'l node -> 'l node option
-
-val unexpand_map_caddadr : 'l node -> 'l node option
-
-val unexpand_deprecated_dxiiivp : 'l node -> 'l node option
-
-val unexpand_pappaiir : 'l node -> 'l node option
-
-val unexpand_deprecated_duuuuup : 'l node -> 'l node option
-
-val unexpand_compare : 'l node -> 'l node option
-
-val unexpand_asserts : 'l node -> 'l node option
-
-val unexpand_unpappaiir : 'l node -> 'l node option
-
-val unexpand_if_some : 'l node -> 'l node option
-
-val unexpand_if_right : 'l node -> 'l node option
diff --git a/vendors/ligo-utils/proto-alpha-utils/michelson_v1_printer.ml b/vendors/ligo-utils/proto-alpha-utils/michelson_v1_printer.ml
deleted file mode 100644
index 4535d456a..000000000
--- a/vendors/ligo-utils/proto-alpha-utils/michelson_v1_printer.ml
+++ /dev/null
@@ -1,270 +0,0 @@
-(*****************************************************************************)
-(*                                                                           *)
-(* Open Source License                                                       *)
-(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
-(*                                                                           *)
-(* Permission is hereby granted, free of charge, to any person obtaining a   *)
-(* copy of this software and associated documentation files (the "Software"),*)
-(* to deal in the Software without restriction, including without limitation *)
-(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
-(* and/or sell copies of the Software, and to permit persons to whom the     *)
-(* Software is furnished to do so, subject to the following conditions:      *)
-(*                                                                           *)
-(* The above copyright notice and this permission notice shall be included   *)
-(* in all copies or substantial portions of the Software.                    *)
-(*                                                                           *)
-(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
-(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
-(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
-(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
-(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
-(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
-(* DEALINGS IN THE SOFTWARE.                                                 *)
-(*                                                                           *)
-(*****************************************************************************)
-
-open Tezos_protocol_008_PtEdo2Zk.Protocol
-open Tezos_base__TzPervasives
-open Alpha_context
-open Tezos_micheline
-open Micheline
-open Micheline_printer
-
-let rec assoc ~equal k = function
-  | [] ->
-      None
-  | (kk, v) :: kvs ->
-      if equal k kk then Some v else assoc ~equal k kvs
-
-let hd = function x :: _ -> Some x | [] -> None
-
-let anon = {comment = None}
-
-let print_expr ppf expr =
-  expr |> Michelson_v1_primitives.strings_of_prims
-  |> Micheline.inject_locations (fun _ -> anon)
-  |> print_expr ppf
-
-let print_expr_unwrapped ppf expr =
-  expr |> Michelson_v1_primitives.strings_of_prims
-  |> Micheline.inject_locations (fun _ -> anon)
-  |> print_expr_unwrapped ppf
-
-let print_var_annots ppf = List.iter (Format.fprintf ppf "%s ")
-
-let print_annot_expr_unwrapped ppf (expr, annot) =
-  Format.fprintf ppf "%a%a" print_var_annots annot print_expr_unwrapped expr
-
-let print_stack ppf = function
-  | [] ->
-      Format.fprintf ppf "[]"
-  | more ->
-      Format.fprintf
-        ppf
-        "@[<hov 0>[ %a ]@]"
-        (Format.pp_print_list
-           ~pp_sep:(fun ppf () -> Format.fprintf ppf "@ : ")
-           print_annot_expr_unwrapped)
-        more
-
-let print_execution_trace ppf trace =
-  Format.pp_print_list
-    (fun ppf (loc, gas, stack) ->
-      Format.fprintf
-        ppf
-        "- @[<v 0>location: %d (remaining gas: %a)@,[ @[<v 0>%a ]@]@]"
-        loc
-        Gas.pp
-        gas
-        (Format.pp_print_list (fun ppf (e, annot) ->
-             Format.fprintf
-               ppf
-               "@[<v 0>%a  \t%s@]"
-               print_expr
-               e
-               (match annot with None -> "" | Some a -> a)))
-        stack)
-    ppf
-    trace
-
-let print_big_map_diff ppf lazy_storage_diff =
-  let diff =
-    Contract.Legacy_big_map_diff.of_lazy_storage_diff lazy_storage_diff
-  in
-  let pp_map ppf id =
-    if Compare.Z.(id < Z.zero) then
-      Format.fprintf ppf "temp(%s)" (Z.to_string (Z.neg id))
-    else Format.fprintf ppf "map(%s)" (Z.to_string id)
-  in
-  Format.fprintf
-    ppf
-    "@[<v 0>%a@]"
-    (Format.pp_print_list ~pp_sep:Format.pp_print_space (fun ppf ->
-       function
-       | Contract.Legacy_big_map_diff.Clear id ->
-           Format.fprintf ppf "Clear %a" pp_map id
-       | Contract.Legacy_big_map_diff.Alloc {big_map; key_type; value_type} ->
-           Format.fprintf
-             ppf
-             "New %a of type (big_map %a %a)"
-             pp_map
-             big_map
-             print_expr
-             key_type
-             print_expr
-             value_type
-       | Contract.Legacy_big_map_diff.Copy {src; dst} ->
-           Format.fprintf ppf "Copy %a to %a" pp_map src pp_map dst
-       | Contract.Legacy_big_map_diff.Update {big_map; diff_key; diff_value; _}
-         ->
-           Format.fprintf
-             ppf
-             "%s %a[%a]%a"
-             (match diff_value with None -> "Unset" | Some _ -> "Set")
-             pp_map
-             big_map
-             print_expr
-             diff_key
-             (fun ppf -> function None -> () | Some x ->
-                   Format.fprintf ppf " to %a" print_expr x)
-             diff_value))
-    (diff :> Contract.Legacy_big_map_diff.item list)
-
-let inject_types type_map parsed =
-  let rec inject_expr = function
-    | Seq (loc, items) ->
-        Seq (inject_loc `before loc, List.map inject_expr items)
-    | Prim (loc, name, items, annot) ->
-        Prim (inject_loc `after loc, name, List.map inject_expr items, annot)
-    | Int (loc, value) ->
-        Int (inject_loc `after loc, value)
-    | String (loc, value) ->
-        String (inject_loc `after loc, value)
-    | Bytes (loc, value) ->
-        Bytes (inject_loc `after loc, value)
-  and inject_loc which loc =
-    let comment =
-      let ( >?? ) = Option.bind in
-      assoc
-        ~equal:Int.equal
-        loc
-        parsed.Michelson_v1_parser.expansion_table
-      >?? fun (_, locs) ->
-      let locs = List.sort compare locs in
-      hd locs
-      >?? fun head_loc ->
-      assoc ~equal:Int.equal head_loc type_map
-      >?? fun (bef, aft) ->
-      let stack = match which with `before -> bef | `after -> aft in
-      Some (Format.asprintf "%a" print_stack stack)
-    in
-    {comment}
-  in
-  inject_expr (root parsed.unexpanded)
-
-let unparse ?type_map parse expanded =
-  let source =
-    match type_map with
-    | Some type_map ->
-        let (unexpanded, unexpansion_table) =
-          expanded |> Michelson_v1_primitives.strings_of_prims |> root
-          |> Michelson_v1_macros.unexpand_rec |> Micheline.extract_locations
-        in
-        let rec inject_expr = function
-          | Seq (loc, items) ->
-              Seq (inject_loc `before loc, List.map inject_expr items)
-          | Prim (loc, name, items, annot) ->
-              Prim
-                (inject_loc `after loc, name, List.map inject_expr items, annot)
-          | Int (loc, value) ->
-              Int (inject_loc `after loc, value)
-          | String (loc, value) ->
-              String (inject_loc `after loc, value)
-          | Bytes (loc, value) ->
-              Bytes (inject_loc `after loc, value)
-        and inject_loc which loc =
-          let comment =
-            let ( >?? ) = Option.bind in
-            assoc ~equal:Int.equal loc unexpansion_table
-            >?? fun loc ->
-            assoc ~equal:Int.equal loc type_map
-            >?? fun (bef, aft) ->
-            let stack = match which with `before -> bef | `after -> aft in
-            Some (Format.asprintf "%a" print_stack stack)
-          in
-          {comment}
-        in
-        unexpanded |> root |> inject_expr
-        |> Format.asprintf "%a" Micheline_printer.print_expr
-    | None ->
-        expanded |> Michelson_v1_primitives.strings_of_prims |> root
-        |> Michelson_v1_macros.unexpand_rec |> Micheline.strip_locations
-        |> Micheline_printer.printable (fun n -> n)
-        |> Format.asprintf "%a" Micheline_printer.print_expr
-  in
-  match parse source with
-  | (res, []) ->
-      res
-  | (_, _ :: _) ->
-      Stdlib.failwith "Michelson_v1_printer.unparse"
-
-let unparse_toplevel ?type_map =
-  unparse ?type_map Michelson_v1_parser.parse_toplevel
-
-let unparse_expression = unparse Michelson_v1_parser.parse_expression
-
-let unparse_invalid expanded =
-  let source =
-    expanded |> root |> Michelson_v1_macros.unexpand_rec
-    |> Micheline.strip_locations
-    |> Micheline_printer.printable (fun n -> n)
-    |> Format.asprintf "%a" Micheline_printer.print_expr_unwrapped
-  in
-  fst (Michelson_v1_parser.parse_toplevel source)
-
-let ocaml_constructor_of_prim prim =
-  (* Assuming all the prim constructor prefixes match the
-     [[Michelson_v1_primitives.namespace]]. *)
-  let prefix =
-    Michelson_v1_primitives.(namespace prim |> string_of_namespace)
-  in
-  Format.asprintf "%s_%s" prefix @@ Michelson_v1_primitives.string_of_prim prim
-
-let micheline_string_of_expression ~zero_loc expression =
-  let string_of_list : string list -> string =
-   fun xs -> String.concat "; " xs |> Format.asprintf "[%s]"
-  in
-  let show_loc loc = if zero_loc then 0 else loc in
-  let rec string_of_node = function
-    | Int (loc, i) ->
-        let z =
-          match Z.to_int i with
-          | 0 ->
-              "Z.zero"
-          | 1 ->
-              "Z.one"
-          | i ->
-              Format.asprintf "Z.of_int %d" i
-        in
-        Format.asprintf "Int (%d, %s)" (show_loc loc) z
-    | String (loc, s) ->
-        Format.asprintf "String (%d, \"%s\")" (show_loc loc) s
-    | Bytes (loc, b) ->
-        Format.asprintf
-          "Bytes (%d, Bytes.of_string \"%s\")"
-          (show_loc loc)
-          Bytes.(escaped b |> to_string)
-    | Prim (loc, prim, nodes, annot) ->
-        Format.asprintf
-          "Prim (%d, %s, %s, %s)"
-          (show_loc loc)
-          (ocaml_constructor_of_prim prim)
-          (string_of_list @@ List.map string_of_node nodes)
-          (string_of_list @@ List.map (Format.asprintf "\"%s\"") annot)
-    | Seq (loc, nodes) ->
-        Format.asprintf
-          "Seq (%d, %s)"
-          (show_loc loc)
-          (string_of_list @@ List.map string_of_node nodes)
-  in
-  string_of_node (root expression)
diff --git a/vendors/ligo-utils/proto-alpha-utils/michelson_v1_printer.mli b/vendors/ligo-utils/proto-alpha-utils/michelson_v1_printer.mli
deleted file mode 100644
index 334ede78b..000000000
--- a/vendors/ligo-utils/proto-alpha-utils/michelson_v1_printer.mli
+++ /dev/null
@@ -1,65 +0,0 @@
-(*****************************************************************************)
-(*                                                                           *)
-(* Open Source License                                                       *)
-(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. <contact@tezos.com>     *)
-(*                                                                           *)
-(* Permission is hereby granted, free of charge, to any person obtaining a   *)
-(* copy of this software and associated documentation files (the "Software"),*)
-(* to deal in the Software without restriction, including without limitation *)
-(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
-(* and/or sell copies of the Software, and to permit persons to whom the     *)
-(* Software is furnished to do so, subject to the following conditions:      *)
-(*                                                                           *)
-(* The above copyright notice and this permission notice shall be included   *)
-(* in all copies or substantial portions of the Software.                    *)
-(*                                                                           *)
-(* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
-(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
-(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
-(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
-(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
-(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
-(* DEALINGS IN THE SOFTWARE.                                                 *)
-(*                                                                           *)
-(*****************************************************************************)
-
-open Tezos_protocol_008_PtEdo2Zk.Protocol
-open Alpha_context
-open Tezos_micheline
-
-val print_expr : Format.formatter -> Script_repr.expr -> unit
-
-val print_expr_unwrapped : Format.formatter -> Script_repr.expr -> unit
-
-val print_execution_trace :
-  Format.formatter ->
-  (Script.location * Gas.t * (Script.expr * string option) list) list ->
-  unit
-
-val print_big_map_diff : Format.formatter -> Lazy_storage.diffs -> unit
-
-(** Insert the type map returned by the typechecker as comments in a
-    printable Micheline AST. *)
-val inject_types :
-  Script_tc_errors.type_map ->
-  Michelson_v1_parser.parsed ->
-  Micheline_printer.node
-
-(** Unexpand the macros and produce the result of parsing an
-    intermediate pretty printed source. Useful when working with
-    contracts extracted from the blockchain and not local files. *)
-val unparse_toplevel :
-  ?type_map:Script_tc_errors.type_map ->
-  Script.expr ->
-  Michelson_v1_parser.parsed
-
-val unparse_expression : Script.expr -> Michelson_v1_parser.parsed
-
-(** Unexpand the macros and produce the result of parsing an
-    intermediate pretty printed source. Works on generic trees,for
-    programs that fail to be converted to a specific script version. *)
-val unparse_invalid : string Micheline.canonical -> Michelson_v1_parser.parsed
-
-val ocaml_constructor_of_prim : Michelson_v1_primitives.prim -> string
-
-val micheline_string_of_expression : zero_loc:bool -> Script.expr -> string
diff --git a/vendors/ligo-utils/proto-alpha-utils/proto-alpha-utils.opam b/vendors/ligo-utils/proto-alpha-utils/proto-alpha-utils.opam
index eef84f420..bd83767c2 100644
--- a/vendors/ligo-utils/proto-alpha-utils/proto-alpha-utils.opam
+++ b/vendors/ligo-utils/proto-alpha-utils/proto-alpha-utils.opam
@@ -43,6 +43,7 @@ depends: [
   "tezos-protocol-environment"
   "tezos-protocol-008-PtEdo2Zk"
   "tezos-protocol-008-PtEdo2Zk-parameters"
+  "client_utils-008-PtEdo2Zk"
   # "tezos-client-008-PtEdo2Zk"
   "tezos-memory-proto-alpha"
   "simple-utils"
-- 
GitLab


From 1a91a54e7a4b2b83624ba51aac25a989dfa43e3f Mon Sep 17 00:00:00 2001
From: Ulrik Strid <ulrik.strid@outlook.com>
Date: Wed, 26 May 2021 22:47:22 +0200
Subject: [PATCH 04/12] Untangle some more stuff

---
 .../client_utils-008-PtEdo2Zk.opam            |  1 +
 .../ligo-utils/client_utils_008_PtEdo2Zk/dune |  4 +++-
 .../operation_result.ml                       | 19 ++++++++-----------
 3 files changed, 12 insertions(+), 12 deletions(-)

diff --git a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam
index 672138279..db5330647 100644
--- a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam
+++ b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam
@@ -15,6 +15,7 @@ depends: [
   "tezos-protocol-008-PtEdo2Zk"
   "tezos-protocol-008-PtEdo2Zk-parameters"
   "tezos-memory-proto-alpha"
+  "tezos-client-base"
   # "tezos-client-008-PtEdo2Zk"
   "alcotest-lwt" {with-test}
 ]
diff --git a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/dune b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/dune
index e481f0f97..78cfa25c6 100644
--- a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/dune
+++ b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/dune
@@ -10,10 +10,12 @@
   tezos-protocol-008-PtEdo2Zk-parameters
   tezos-protocol-environment
   tezos-memory-proto-alpha
+  tezos-lwt-result-stdlib
   data-encoding
+  tezos-client-base
   simple-utils
   tezos-utils
   tezos-shell-services
   tezos-error-monad)
  (flags
-  (:standard -open Simple_utils -open Tezos_base__TzPervasives)))
+  (:standard -open Simple_utils -open Tezos_base__TzPervasives -open Tezos_client_base)))
diff --git a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/operation_result.ml b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/operation_result.ml
index 3e40bef72..da5879948 100644
--- a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/operation_result.ml
+++ b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/operation_result.ml
@@ -36,7 +36,7 @@ let pp_manager_operation_content (type kind) source internal pp_result ppf
         ppf
         "@[<v 2>%s:@,Amount: %s%a@,From: %a@,To: %a"
         (if internal then "Internal transaction" else "Transaction")
-        Client_proto_args.tez_sym
+        "\xEA\x9C\xA9"
         Tez.pp
         amount
         Contract.pp
@@ -50,8 +50,7 @@ let pp_manager_operation_content (type kind) source internal pp_result ppf
           Format.fprintf ppf "@,Entrypoint: %s" entrypoint ) ;
       ( if not (Script_repr.is_unit_parameter parameters) then
         let expr =
-          WithExceptions.Option.to_exn
-            ~none:(Failure "ill-serialized argument")
+          Option.get
             (Data_encoding.force_decode parameters)
         in
         Format.fprintf
@@ -68,16 +67,14 @@ let pp_manager_operation_content (type kind) source internal pp_result ppf
         (if internal then "Internal origination" else "Origination")
         Contract.pp
         source
-        Client_proto_args.tez_sym
+        "\xEA\x9C\xA9"
         Tez.pp
         credit ;
       let code =
-        WithExceptions.Option.to_exn
-          ~none:(Failure "ill-serialized code")
+        Option.get
           (Data_encoding.force_decode code)
       and storage =
-        WithExceptions.Option.to_exn
-          ~none:(Failure "ill-serialized storage")
+        Option.get
           (Data_encoding.force_decode storage)
       in
       let {Michelson_v1_parser.source; _} =
@@ -171,9 +168,9 @@ let pp_balance_updates ppf = function
       in
       let pp_update ppf = function
         | Credited amount ->
-            Format.fprintf ppf "+%s%a" Client_proto_args.tez_sym Tez.pp amount
+            Format.fprintf ppf "+%s%a" "\xEA\x9C\xA9" Tez.pp amount
         | Debited amount ->
-            Format.fprintf ppf "-%s%a" Client_proto_args.tez_sym Tez.pp amount
+            Format.fprintf ppf "-%s%a" "\xEA\x9C\xA9" Tez.pp amount
       in
       let pp_one ppf (balance, update) =
         let to_fill = column_size + 3 - String.length balance in
@@ -344,7 +341,7 @@ let pp_manager_operation_contents_and_result ppf
      Storage limit: %s bytes"
     Signature.Public_key_hash.pp
     source
-    Client_proto_args.tez_sym
+    "\xEA\x9C\xA9"
     Tez.pp
     fee
     (Z.to_string counter)
-- 
GitLab


From 54f0b459e5b151bc0bc98561020de479dc55d01d Mon Sep 17 00:00:00 2001
From: Ulrik Strid <ulrik.strid@outlook.com>
Date: Thu, 27 May 2021 08:11:21 +0200
Subject: [PATCH 05/12] Add error_reporter to client utils

---
 .../client_utils_008_PtEdo2Zk/client_utils_008_PtEdo2Zk.ml       | 1 +
 1 file changed, 1 insertion(+)

diff --git a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils_008_PtEdo2Zk.ml b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils_008_PtEdo2Zk.ml
index 20242c058..ae2df69f5 100644
--- a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils_008_PtEdo2Zk.ml
+++ b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils_008_PtEdo2Zk.ml
@@ -4,3 +4,4 @@ module Michelson_v1_parser = Michelson_v1_parser
 
 module Michelson_v1_printer = Michelson_v1_printer
 
+module Michelson_v1_error_reporter = Michelson_v1_error_reporter
-- 
GitLab


From 691f03affa1dc22c6f74da90cee53378f265e19e Mon Sep 17 00:00:00 2001
From: Ulrik Strid <ulrik.strid@outlook.com>
Date: Thu, 27 May 2021 13:48:56 +0200
Subject: [PATCH 06/12] Remove tezos-client-base

---
 .../client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam   | 1 -
 vendors/ligo-utils/client_utils_008_PtEdo2Zk/dune              | 3 +--
 2 files changed, 1 insertion(+), 3 deletions(-)

diff --git a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam
index db5330647..672138279 100644
--- a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam
+++ b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam
@@ -15,7 +15,6 @@ depends: [
   "tezos-protocol-008-PtEdo2Zk"
   "tezos-protocol-008-PtEdo2Zk-parameters"
   "tezos-memory-proto-alpha"
-  "tezos-client-base"
   # "tezos-client-008-PtEdo2Zk"
   "alcotest-lwt" {with-test}
 ]
diff --git a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/dune b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/dune
index 78cfa25c6..da78ff81c 100644
--- a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/dune
+++ b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/dune
@@ -12,10 +12,9 @@
   tezos-memory-proto-alpha
   tezos-lwt-result-stdlib
   data-encoding
-  tezos-client-base
   simple-utils
   tezos-utils
   tezos-shell-services
   tezos-error-monad)
  (flags
-  (:standard -open Simple_utils -open Tezos_base__TzPervasives -open Tezos_client_base)))
+  (:standard -open Simple_utils -open Tezos_base__TzPervasives)))
-- 
GitLab


From 97af9db5dc8ff54cd054f666f02582fdeaa6e851 Mon Sep 17 00:00:00 2001
From: Ulrik Strid <ulrik.strid@outlook.com>
Date: Mon, 5 Jul 2021 16:18:28 +0200
Subject: [PATCH 07/12] Tweak vendors

---
 .../client_utils_008_PtEdo2Zk/michelson_v1_error_reporter.ml    | 2 --
 .../client_utils_008_PtEdo2Zk/michelson_v1_parser.mli           | 1 -
 2 files changed, 3 deletions(-)

diff --git a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_error_reporter.ml b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_error_reporter.ml
index c6d3e99a8..00f1ee5e1 100644
--- a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_error_reporter.ml
+++ b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_error_reporter.ml
@@ -37,8 +37,6 @@ let rec assoc ~equal k = function
   | (kk, v) :: kvs ->
       if equal k kk then Some v else assoc ~equal k kvs
 
-let hd = function x :: _ -> Some x | [] -> None
-
 let print_ty ppf ty = Michelson_v1_printer.print_expr_unwrapped ppf ty
 
 let print_var_annot ppf annot = List.iter (Format.fprintf ppf "@ %s") annot
diff --git a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_parser.mli b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_parser.mli
index 0c184fff7..b1553faa5 100644
--- a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_parser.mli
+++ b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/michelson_v1_parser.mli
@@ -23,7 +23,6 @@
 (*                                                                           *)
 (*****************************************************************************)
 
-open Tezos_protocol_008_PtEdo2Zk.Protocol
 open Memory_proto_alpha.Protocol.Alpha_context
 open Tezos_micheline
 
-- 
GitLab


From 662c8322447c7d0ea2fafd7061ab437d7661e250 Mon Sep 17 00:00:00 2001
From: Ulrik Strid <ulrik.strid@outlook.com>
Date: Mon, 5 Jul 2021 16:41:53 +0200
Subject: [PATCH 08/12] Add new client_utils library to Docker

---
 Dockerfile | 1 +
 1 file changed, 1 insertion(+)

diff --git a/Dockerfile b/Dockerfile
index c83e05719..9e455d2f2 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -30,6 +30,7 @@ COPY vendors/Preprocessor/Preprocessor.opam /ligo/vendors/Preprocessor/Preproces
 COPY vendors/Michelson/Michelson.opam /ligo/vendors/Michelson/Michelson.opam
 COPY vendors/LexerLib/LexerLib.opam /ligo/vendors/LexerLib/LexerLib.opam
 COPY vendors/ligo-utils/proto-alpha-utils/proto-alpha-utils.opam /ligo/vendors/ligo-utils/proto-alpha-utils/proto-alpha-utils.opam
+COPY vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam /ligo/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam
 COPY vendors/ligo-utils/tezos-utils/tezos-utils.opam /ligo/vendors/ligo-utils/tezos-utils/tezos-utils.opam
 COPY vendors/ligo-utils/memory-proto-alpha/tezos-memory-proto-alpha.opam /ligo/vendors/ligo-utils/memory-proto-alpha/tezos-memory-proto-alpha.opam
 COPY vendors/ligo-utils/simple-utils/simple-utils.opam /ligo/vendors/ligo-utils/simple-utils/simple-utils.opam
-- 
GitLab


From e134d9e3b2543dc9c2f2a5fdc0f21c3759638e8b Mon Sep 17 00:00:00 2001
From: Ulrik Strid <ulrik.strid@outlook.com>
Date: Mon, 5 Jul 2021 16:44:43 +0200
Subject: [PATCH 09/12] Capitalize Preprocessor dependency

---
 ligo.opam | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ligo.opam b/ligo.opam
index b7bdd345e..0cad0da78 100644
--- a/ligo.opam
+++ b/ligo.opam
@@ -28,7 +28,7 @@ depends: [
   "terminal_size"
   "pprint"
   "ParserLib"
-  "preprocessor"
+  "Preprocessor"
   "LexerLib"
   "UnionFind"
   "RedBlackTrees"
-- 
GitLab


From 6b5a42e0c2d50f632fd9873e2ef8999163ad597b Mon Sep 17 00:00:00 2001
From: Ulrik Strid <ulrik.strid@outlook.com>
Date: Mon, 5 Jul 2021 17:05:29 +0200
Subject: [PATCH 10/12] bls12-381-unix doesn't exist in 0.3.15

---
 src/bin/dune | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/bin/dune b/src/bin/dune
index 593d828f1..bb03a0992 100644
--- a/src/bin/dune
+++ b/src/bin/dune
@@ -45,7 +45,7 @@
   (public_name ligo)
   (instrumentation (backend bisect_ppx))
   (libraries
-    bls12-381-unix
+    bls12-381
     simple-utils
     cmdliner
     ligo
-- 
GitLab


From 004c65d0f2bfcc4a1c5b7e742c15c0397fe4e99c Mon Sep 17 00:00:00 2001
From: Ulrik Strid <ulrik.strid@outlook.com>
Date: Mon, 5 Jul 2021 17:10:42 +0200
Subject: [PATCH 11/12] Use Client_utils_008_PtEdo2Zk

---
 src/main/main_errors/formatter.ml | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/main/main_errors/formatter.ml b/src/main/main_errors/formatter.ml
index 6cdd79c6f..f158a0eea 100644
--- a/src/main/main_errors/formatter.ml
+++ b/src/main/main_errors/formatter.ml
@@ -128,24 +128,24 @@ let rec error_ppformat : display_format:string display_format ->
     | `Main_unparse_michelson_result errs ->
       let errs = List.map ~f:( fun e -> match e with `Tezos_alpha_error a -> a) errs in
       Format.fprintf f "@[<hv>Error(s) occurred while unparsing the Michelson result:@.%a @]"
-      (Tezos_client_008_PtEdo2Zk.Michelson_v1_error_reporter.report_errors ~details:true ~show_source:true ?parsed:(None)) errs
+      (Client_utils_008_PtEdo2Zk.Michelson_v1_error_reporter.report_errors ~details:true ~show_source:true ?parsed:(None)) errs
 
     | `Main_parse_payload _ -> Format.fprintf f "@[<hv>Error parsing message. @]" (* internal testing *)
     | `Main_pack_payload _ -> Format.fprintf f "@[<hv>Error packing message. @]" (* internal testing *)
     | `Main_parse_michelson_input errs ->
       let errs = List.map ~f:( fun e -> match e with `Tezos_alpha_error a -> a) errs in
       Format.fprintf f "@[<hv>Error(s) occurred while parsing the Michelson input:@.%a @]"
-      (Tezos_client_008_PtEdo2Zk.Michelson_v1_error_reporter.report_errors ~details:true ~show_source:true ?parsed:(None)) errs
+      (Client_utils_008_PtEdo2Zk.Michelson_v1_error_reporter.report_errors ~details:true ~show_source:true ?parsed:(None)) errs
 
     | `Main_parse_michelson_code errs ->
       let errs = List.map ~f:( fun e -> match e with `Tezos_alpha_error a -> a) errs in
       Format.fprintf f "@[<hv>Error(s) occurred while checking the contract:@.%a @]"
-        (Tezos_client_008_PtEdo2Zk.Michelson_v1_error_reporter.report_errors ~details:true ~show_source:true ?parsed:(None)) errs
+        (Client_utils_008_PtEdo2Zk.Michelson_v1_error_reporter.report_errors ~details:true ~show_source:true ?parsed:(None)) errs
 
     | `Main_michelson_execution_error errs ->
       let errs = List.map ~f:( fun e -> match e with `Tezos_alpha_error a -> a) errs in
       Format.fprintf f "@[<hv>Error(s) occurred while executing the contract:@.%a @]"
-      (Tezos_client_008_PtEdo2Zk.Michelson_v1_error_reporter.report_errors ~details:true ~show_source:true ?parsed:(None)) errs
+      (Client_utils_008_PtEdo2Zk.Michelson_v1_error_reporter.report_errors ~details:true ~show_source:true ?parsed:(None)) errs
 
     | `Main_preproc e -> Preprocessing.Errors.error_ppformat ~display_format f e
     | `Main_parser e -> Parsing.Errors.error_ppformat ~display_format f e
@@ -175,7 +175,7 @@ let rec error_ppformat : display_format:string display_format ->
     | `Main_interpret_target_lang_error (loc, errs) ->
       Format.fprintf f "@[<v 4>%a@.An uncaught error occured in the object language:@.%a@]"
         Snippet.pp loc
-        (Tezos_client_008_PtEdo2Zk.Michelson_v1_error_reporter.report_errors ~details:true ~show_source:true ?parsed:(None)) errs
+        (Client_utils_008_PtEdo2Zk.Michelson_v1_error_reporter.report_errors ~details:true ~show_source:true ?parsed:(None)) errs
     | `Main_interpret_boostrap_not_enough loc ->
       Format.fprintf f "@[<hv>%a@.We need at least two boostrap accounts for the default source and baker@]"
       Snippet.pp loc
-- 
GitLab


From b16ebc8028eb0502c787b6cc1c06d65b67875f6a Mon Sep 17 00:00:00 2001
From: Ulrik Strid <ulrik.strid@outlook.com>
Date: Tue, 6 Jul 2021 08:27:58 +0200
Subject: [PATCH 12/12] Clean up comments etc

---
 src/bin/dune                                                    | 1 -
 .../client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam    | 1 -
 vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/dune          | 2 --
 .../ligo-008-PtEdo2Zk-test-helpers.opam                         | 1 -
 vendors/ligo-utils/proto-alpha-utils/dune                       | 1 -
 vendors/ligo-utils/proto-alpha-utils/proto-alpha-utils.opam     | 2 --
 vendors/ligo-utils/tezos-utils/tezos-utils.opam                 | 1 -
 7 files changed, 9 deletions(-)

diff --git a/src/bin/dune b/src/bin/dune
index bb03a0992..72b69f146 100644
--- a/src/bin/dune
+++ b/src/bin/dune
@@ -45,7 +45,6 @@
   (public_name ligo)
   (instrumentation (backend bisect_ppx))
   (libraries
-    bls12-381
     simple-utils
     cmdliner
     ligo
diff --git a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam
index 672138279..e8cdd9595 100644
--- a/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam
+++ b/vendors/ligo-utils/client_utils_008_PtEdo2Zk/client_utils-008-PtEdo2Zk.opam
@@ -15,7 +15,6 @@ depends: [
   "tezos-protocol-008-PtEdo2Zk"
   "tezos-protocol-008-PtEdo2Zk-parameters"
   "tezos-memory-proto-alpha"
-  # "tezos-client-008-PtEdo2Zk"
   "alcotest-lwt" {with-test}
 ]
 build: [
diff --git a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/dune b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/dune
index 13fe4c0da..20351007b 100644
--- a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/dune
+++ b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/dune
@@ -10,13 +10,11 @@
             tezos-protocol-008-PtEdo2Zk-parameters
             tezos-error-monad
             client_utils-008-PtEdo2Zk
-            ;tezos-client-008-PtEdo2Zk
  )
  (flags (:standard -open Tezos_base__TzPervasives
                    -open Tezos_micheline
                    -open Tezos_stdlib_unix
                    -open Tezos_protocol_008_PtEdo2Zk
-                   ;-open Tezos_client_008_PtEdo2Zk
                    -open Client_utils_008_PtEdo2Zk
                    -open Tezos_protocol_environment_008_PtEdo2Zk
                    -open Tezos_shell_services)))
diff --git a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/ligo-008-PtEdo2Zk-test-helpers.opam b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/ligo-008-PtEdo2Zk-test-helpers.opam
index 48c767a00..a51f3b357 100644
--- a/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/ligo-008-PtEdo2Zk-test-helpers.opam
+++ b/vendors/ligo-utils/ligo_008_PtEdo2Zk_test_helpers/ligo-008-PtEdo2Zk-test-helpers.opam
@@ -14,7 +14,6 @@ depends: [
   "tezos-protocol-008-PtEdo2Zk"
   "tezos-protocol-008-PtEdo2Zk-parameters"
   "client_utils-008-PtEdo2Zk"
-  # "tezos-client-008-PtEdo2Zk"
   "alcotest-lwt"
 ]
 build: [
diff --git a/vendors/ligo-utils/proto-alpha-utils/dune b/vendors/ligo-utils/proto-alpha-utils/dune
index 2cf189b77..c48cdfced 100644
--- a/vendors/ligo-utils/proto-alpha-utils/dune
+++ b/vendors/ligo-utils/proto-alpha-utils/dune
@@ -7,7 +7,6 @@
   tezos-protocol-008-PtEdo2Zk
   tezos-protocol-008-PtEdo2Zk-parameters
   tezos-protocol-environment
-  ;tezos-client-008-PtEdo2Zk
   tezos-memory-proto-alpha
   client_utils-008-PtEdo2Zk
   data-encoding
diff --git a/vendors/ligo-utils/proto-alpha-utils/proto-alpha-utils.opam b/vendors/ligo-utils/proto-alpha-utils/proto-alpha-utils.opam
index bd83767c2..282fd91e1 100644
--- a/vendors/ligo-utils/proto-alpha-utils/proto-alpha-utils.opam
+++ b/vendors/ligo-utils/proto-alpha-utils/proto-alpha-utils.opam
@@ -18,7 +18,6 @@ depends: [
   "cstruct"
   "ezjsonm"
   "hex"
-  # "hidapi"
   "ipaddr"
   "macaddr"
   "irmin"
@@ -44,7 +43,6 @@ depends: [
   "tezos-protocol-008-PtEdo2Zk"
   "tezos-protocol-008-PtEdo2Zk-parameters"
   "client_utils-008-PtEdo2Zk"
-  # "tezos-client-008-PtEdo2Zk"
   "tezos-memory-proto-alpha"
   "simple-utils"
   "tezos-utils"
diff --git a/vendors/ligo-utils/tezos-utils/tezos-utils.opam b/vendors/ligo-utils/tezos-utils/tezos-utils.opam
index b64ca85db..45cf0088b 100644
--- a/vendors/ligo-utils/tezos-utils/tezos-utils.opam
+++ b/vendors/ligo-utils/tezos-utils/tezos-utils.opam
@@ -17,7 +17,6 @@ depends: [
   "cstruct"
   "ezjsonm"
   "hex"
-  # "hidapi"
   "irmin"
   "js_of_ocaml"
   "lwt"
-- 
GitLab

